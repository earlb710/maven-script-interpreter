// ============================================================================
// help.ebs - EBS Syntax Help Screen
// ============================================================================
// This script displays a help screen with a tree view on the left for
// navigation and a content area on the right for displaying help documents.
// ============================================================================


// Load help data from JSON file
// Note: Echo is disabled by default in Environment, so resource loading happens silently
var helpData: json = null;
try {
    // Read from classpath resources using the new resource loader
    // This loads from the application resources, not the file system
    var jsonContent: string = call file.readTextResource("help-lookup.json");
    helpData = call json.jsonFromString(jsonContent);
} exceptions {
    when ex {
        print "Warning: Could not load help-lookup.json: " + ex;
        print "Help will be displayed without JSON-based keyword descriptions";
    }
}

// Get all builtins from system registry
var systemHelpText: string = call system.help();

// Parse the help text to extract builtin information
// The format is: "builtin.name(param1:type, param2:type?) : returnType"
var builtinLines: array = call str.split(systemHelpText, "\n", 0);
var builtinsArray: array[*] = [];
var inBuiltinsSection: bool = false;

foreach line in builtinLines {
    var trimmedLine: string = call str.trim(line);
    if trimmedLine == "Builtins:" then {
        inBuiltinsSection = true;
    } else if inBuiltinsSection then {
        // Check if the original line (not trimmed) starts with space to identify indented builtin lines
        if trimmedLine != "" && call str.startsWith(line, " ") then {
            // Extract builtin name from line like "  array.add(array:array, value:any, index:integer?) : null"
            var parenIndex: int = call str.indexOf(trimmedLine, "(", 0);
            if parenIndex > 0 then {
                var builtinName: string = call str.substring(trimmedLine, 0, parenIndex);
                // Create a fresh JSON object for each builtin to avoid reference issues
                var builtinInfo: json = call json.jsonFromString("{}");
                builtinInfo = call json.set(builtinInfo, "name", builtinName);
                builtinInfo = call json.set(builtinInfo, "signature", trimmedLine);
                call array.add(builtinsArray, builtinInfo);
            }
        } else if trimmedLine == "" then {
            // Empty line - could be end of section or spacing within section
            // Continue to allow for spacing within the builtins section
        } else {
            // Non-indented, non-empty line marks end of builtins section
            inBuiltinsSection = false;
        }
    }
}

var builtinCount: int = builtinsArray.length;

// Load category information from help data
var builtinCategoryNames: json = null;
var builtinCategoryOrder: json = null;
if helpData != null then {
    var topics: json = call json.get(helpData, "topics");
    if topics != null then {
        builtinCategoryNames = call json.get(topics, "builtin_categories");
        builtinCategoryOrder = call json.get(topics, "builtin_category_order");
        if builtinCategoryNames != null then {
        } else {
        }
        if builtinCategoryOrder != null then {
        } else {
        }
    } else {
    }
} else {
}

// Categorize builtins by module
// Use json to store arrays of builtins for each category
// Use json.jsonFromString to create a fresh JSON object to avoid circular references
var builtinsByCategory: json = call json.jsonFromString("{}");
if builtinsArray != null then {
    var debugCount: int = 0;
    foreach builtin in builtinsArray {
        var builtinName: string = call json.getString(builtin, "name", "");
        if builtinName != "" then {
            // Extract category (module) from builtin name (e.g., "str.trim" -> "str")
            var dotIndex: int = call str.indexOf(builtinName, ".", 0);
            var category: string = "other";
            if dotIndex > 0 then {
                category = call str.substring(builtinName, 0, dotIndex);
            }
            
            // Debug first 5 categorizations
            if debugCount < 5 then {
                debugCount = debugCount + 1;
            }
            
            // Create child node with builtin name as a JSON object
            // Use json.jsonFromString to create a fresh JSON object to avoid circular references
            var childNode: json = call json.jsonFromString("{}");
            childNode = call json.set(childNode, "value", builtinName);
            childNode = call json.set(childNode, "icon", "icons/help-page.png");
            childNode = call json.set(childNode, "expanded", false);
            
            // Use json.add to append to the array at the category path
            // json.add automatically creates the array if it doesn't exist and appends the item
            builtinsByCategory = call json.add(builtinsByCategory, category, childNode);
        }
    }
} else {
}

// Add sub-nodes for scr.setProperty
// Check if "scr" category exists and find scr.setProperty in it
var scrCategory: json = call json.getArray(builtinsByCategory, "scr");
if scrCategory != null then {
    var scrSetPropertyIndex: int = -1;
    var i: int = 0;
    while i < scrCategory.length {
        var item: json = scrCategory[i];
        var itemValue: string = call json.getString(item, "value", "");
        if itemValue == "scr.setProperty" then {
            scrSetPropertyIndex = i;
            break;
        }
        i = i + 1;
    }
    
    // If scr.setProperty was found, add sub-nodes for each property
    if scrSetPropertyIndex >= 0 then {
        var scrSetPropertyNode: json = scrCategory[scrSetPropertyIndex];
        
        // Create array of property sub-nodes
        var propertyNodes: array[*] = [];
        
        // Add overview node first
        var overviewNode: json = call json.jsonFromString("{}");
        overviewNode = call json.set(overviewNode, "value", "Overview");
        overviewNode = call json.set(overviewNode, "icon", "icons/info-page.png");
        overviewNode = call json.set(overviewNode, "expanded", false);
        call array.add(propertyNodes, overviewNode);
        
        // Define property nodes in order
        var propertyNames: array[*] = [];
        call array.add(propertyNames, "value");
        call array.add(propertyNames, "editable");
        call array.add(propertyNames, "disabled");
        call array.add(propertyNames, "visible");
        call array.add(propertyNames, "tooltip");
        call array.add(propertyNames, "textColor");
        call array.add(propertyNames, "backgroundColor");
        call array.add(propertyNames, "colSpan");
        call array.add(propertyNames, "rowSpan");
        call array.add(propertyNames, "hgrow");
        call array.add(propertyNames, "vgrow");
        call array.add(propertyNames, "margin");
        call array.add(propertyNames, "padding");
        call array.add(propertyNames, "prefWidth");
        call array.add(propertyNames, "prefHeight");
        call array.add(propertyNames, "minWidth");
        call array.add(propertyNames, "minHeight");
        call array.add(propertyNames, "maxWidth");
        call array.add(propertyNames, "maxHeight");
        call array.add(propertyNames, "alignment");
        
        // Create nodes for each property
        foreach propName in propertyNames {
            var propNode: json = call json.jsonFromString("{}");
            propNode = call json.set(propNode, "value", propName);
            propNode = call json.set(propNode, "icon", "icons/info-page.png");
            propNode = call json.set(propNode, "expanded", false);
            call array.add(propertyNodes, propNode);
        }
        
        // Convert array to JSON array
        var propNodesJson: json = call json.jsonFromString("[]");
        var j: int = 0;
        while j < propertyNodes.length {
            propNodesJson = call json.add(propNodesJson, "", propertyNodes[j]);
            j = j + 1;
        }
        
        // Add children to scr.setProperty node
        scrSetPropertyNode = call json.set(scrSetPropertyNode, "children", propNodesJson);
        scrSetPropertyNode = call json.set(scrSetPropertyNode, "expanded", false);
        
        // Update the node in the category array
        scrCategory = call json.set(scrCategory, scrSetPropertyIndex, scrSetPropertyNode);
        builtinsByCategory = call json.set(builtinsByCategory, "scr", scrCategory);
    }
}

// Build categorized builtin tree using category order from JSON
var builtinChildren: array[*];
var totalBuiltins: int = 0;

// Convert JSON array to regular array for sorting
var categoryOrderArray: array[*];
if builtinCategoryOrder != null then {
    var idx: int = 0;
    while idx < builtinCategoryOrder.length {
        var categoryKey: string = builtinCategoryOrder[idx];
        call array.add(categoryOrderArray, categoryKey);
        idx = idx + 1;
    }
    // Sort category order alphabetically
    call array.sort(categoryOrderArray, true);
}

if categoryOrderArray.length > 0 then {
    foreach categoryKey in categoryOrderArray {
        // Get category array from json using json.getArray to properly handle JSON arrays
        var categoryArray: json = call json.getArray(builtinsByCategory, categoryKey);
        if categoryArray != null then {
            // Sort builtin functions alphabetically within this category
            // Create a regular array to sort, then convert back
            var sortableArray: array[*];
            var i: int = 0;
            while i < categoryArray.length {
                var item: json = categoryArray[i];
                call array.add(sortableArray, item);
                i = i + 1;
            }
            
            // Sort by the "value" property (function name)
            var j: int = 0;
            while j < sortableArray.length - 1 {
                var k: int = j + 1;
                while k < sortableArray.length {
                    var item1: json = sortableArray[j];
                    var item2: json = sortableArray[k];
                    var name1: string = call json.getString(item1, "value", "");
                    var name2: string = call json.getString(item2, "value", "");
                    if name1 > name2 then {
                        sortableArray[j] = item2;
                        sortableArray[k] = item1;
                    }
                    k = k + 1;
                }
                j = j + 1;
            }
            
            // Convert sorted array back to JSON array
            var sortedCategoryArray: json = call json.jsonFromString("[]");
            var m: int = 0;
            while m < sortableArray.length {
                sortedCategoryArray = call json.add(sortedCategoryArray, "", sortableArray[m]);
                m = m + 1;
            }
            
            // Get display name from JSON, fallback to key
            var displayName: string = categoryKey;
            if builtinCategoryNames != null then {
                var jsonDisplayName: string = call json.getString(builtinCategoryNames, categoryKey, "");
                if jsonDisplayName != "" then {
                    displayName = jsonDisplayName;
                }
            }
            
            // Use displayName as the tree node value for visibility
            // Use json.jsonFromString to create a fresh JSON object to avoid circular references
            var categoryNode: json = call json.jsonFromString("{}");
            categoryNode = call json.set(categoryNode, "value", displayName);
            categoryNode = call json.set(categoryNode, "icon", "icons/tree-node.png");
            categoryNode = call json.set(categoryNode, "expanded", false);
            categoryNode = call json.set(categoryNode, "children", sortedCategoryArray);
            call array.add(builtinChildren, categoryNode);
            totalBuiltins = totalBuiltins + 1; // Count categories, not individual functions
        } else {
        }
    }
} else {
}


// Build the complete tree structure dynamically with icons
var structureChildren: array[*];
var tempNode: json;

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Basic");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(structureChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Variables");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(structureChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Operators");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(structureChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Functions");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(structureChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Imports");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(structureChildren, tempNode);

var flowChildren: array[*];

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Conditionals");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(flowChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Loops");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(flowChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Break and Continue");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(flowChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Exception Handling");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(flowChildren, tempNode);

var syntaxChildren: array[*];

// Add Getting Started as first item
tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Getting started");
tempNode = call json.set(tempNode, "icon", "icons/help-page.png");
call array.add(syntaxChildren, tempNode);

// Use json.jsonFromString to create a fresh JSON object to avoid circular references
var structureNode: json = call json.jsonFromString("{}");
structureNode = call json.set(structureNode, "value", "Structure");
structureNode = call json.set(structureNode, "icon", "icons/tree-node.png");
structureNode = call json.set(structureNode, "expanded", true);
structureNode = call json.set(structureNode, "children", structureChildren);
call array.add(syntaxChildren, structureNode);

// Data Types section
var dataChildren: array[*];

// Integer Types with sub-nodes
var integerChildren: array[*];

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Bitmap");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(integerChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Intmap");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(integerChildren, tempNode);

var integerNode: json = call json.jsonFromString("{}");
integerNode = call json.set(integerNode, "value", "Integer Types");
integerNode = call json.set(integerNode, "icon", "icons/tree-node.png");
integerNode = call json.set(integerNode, "expanded", true);
integerNode = call json.set(integerNode, "children", integerChildren);
call array.add(dataChildren, integerNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Floating Point");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(dataChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "String");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(dataChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Boolean");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(dataChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Date");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(dataChildren, tempNode);

// Use json.jsonFromString to create a fresh JSON object to avoid circular references
var dataNode: json = call json.jsonFromString("{}");
dataNode = call json.set(dataNode, "value", "Data");
dataNode = call json.set(dataNode, "icon", "icons/tree-node.png");
dataNode = call json.set(dataNode, "expanded", true);
dataNode = call json.set(dataNode, "children", dataChildren);
call array.add(syntaxChildren, dataNode);

// Collections section
var collectionsChildren: array[*];

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Arrays");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(collectionsChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "JSON");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(collectionsChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Records");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(collectionsChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Bitmap and Intmap");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(collectionsChildren, tempNode);

// Use json.jsonFromString to create a fresh JSON object to avoid circular references
var collectionsNode: json = call json.jsonFromString("{}");
collectionsNode = call json.set(collectionsNode, "value", "Collections");
collectionsNode = call json.set(collectionsNode, "icon", "icons/tree-node.png");
collectionsNode = call json.set(collectionsNode, "expanded", true);
collectionsNode = call json.set(collectionsNode, "children", collectionsChildren);
call array.add(syntaxChildren, collectionsNode);

// Use json.jsonFromString to create a fresh JSON object to avoid circular references
var flowNode: json = call json.jsonFromString("{}");
flowNode = call json.set(flowNode, "value", "Flow");
flowNode = call json.set(flowNode, "icon", "icons/tree-node.png");
flowNode = call json.set(flowNode, "expanded", true);
flowNode = call json.set(flowNode, "children", flowChildren);
call array.add(syntaxChildren, flowNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Keywords");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(syntaxChildren, tempNode);

// Use json.jsonFromString to create a fresh JSON object to avoid circular references
var builtinsNode: json = call json.jsonFromString("{}");
builtinsNode = call json.set(builtinsNode, "value", "Builtins");
builtinsNode = call json.set(builtinsNode, "icon", "icons/tree-node.png");
builtinsNode = call json.set(builtinsNode, "expanded", false);
builtinsNode = call json.set(builtinsNode, "children", builtinChildren);
call array.add(syntaxChildren, builtinsNode);

// Build screen children with sub-topics
var screenChildren: array[*];

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Screen data");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(screenChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Screen display");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(screenChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Screen areas");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(screenChildren, tempNode);

// Build Screen items with control type sub-nodes
var screenItemsChildren: array[*];

// Add control type nodes in alphabetical order
var controlTypes: array[*] = [];
call array.add(controlTypes, "button");
call array.add(controlTypes, "chart");
call array.add(controlTypes, "checkbox");
call array.add(controlTypes, "choicebox");
call array.add(controlTypes, "colorpicker");
call array.add(controlTypes, "combobox");
call array.add(controlTypes, "datepicker");
call array.add(controlTypes, "hyperlink");
call array.add(controlTypes, "imageview");
call array.add(controlTypes, "label");
call array.add(controlTypes, "listview");
call array.add(controlTypes, "passwordfield");
call array.add(controlTypes, "progressbar");
call array.add(controlTypes, "radiobutton");
call array.add(controlTypes, "separator");
call array.add(controlTypes, "slider");
call array.add(controlTypes, "spinner");
call array.add(controlTypes, "text");
call array.add(controlTypes, "textarea");
call array.add(controlTypes, "textfield");
call array.add(controlTypes, "togglebutton");
call array.add(controlTypes, "treeview");
call array.add(controlTypes, "webview");

foreach controlType in controlTypes {
    var ctNode: json = call json.jsonFromString("{}");
    ctNode = call json.set(ctNode, "value", controlType);
    ctNode = call json.set(ctNode, "icon", "icons/info-page.png");
    call array.add(screenItemsChildren, ctNode);
}

var screenItemsNode: json = call json.jsonFromString("{}");
screenItemsNode = call json.set(screenItemsNode, "value", "Screen items");
screenItemsNode = call json.set(screenItemsNode, "icon", "icons/tree-node.png");
screenItemsNode = call json.set(screenItemsNode, "expanded", false);
screenItemsNode = call json.set(screenItemsNode, "children", screenItemsChildren);
call array.add(screenChildren, screenItemsNode);

// Create screen node with children
var screenNode: json = call json.jsonFromString("{}");
screenNode = call json.set(screenNode, "value", "Screen");
screenNode = call json.set(screenNode, "icon", "icons/tree-node.png");
screenNode = call json.set(screenNode, "expanded", true);
screenNode = call json.set(screenNode, "children", screenChildren);
call array.add(syntaxChildren, screenNode);

var examplesChildren: array[*];

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Keywords");
tempNode = call json.set(tempNode, "icon", "icons/normal-page.png");
call array.add(examplesChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Builtins");
tempNode = call json.set(tempNode, "icon", "icons/normal-page.png");
call array.add(examplesChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Screen");
tempNode = call json.set(tempNode, "icon", "icons/normal-page.png");
call array.add(examplesChildren, tempNode);

// Build Guides section by programmatically loading files from guides directory
var guidesChildren: array[*];

// Get list of markdown files in guides directory
var guidesPath: string = "guides";
var guideFiles: json = call file.listFiles(guidesPath);

if guideFiles != null && guideFiles.length > 0 then {
    // Create a sortable array of guide filenames
    var guideNames: array[*];
    
    foreach guideFile in guideFiles {
        var fileName: string = call json.getString(guideFile, "name", "");
        var isDir: bool = call json.getBool(guideFile, "isDir", false);
        
        // Only include .md files, not directories
        if !isDir && call str.endsWith(fileName, ".md") then {
            call array.add(guideNames, fileName);
        }
    }
    
    // Sort guide names alphabetically
    call array.sort(guideNames, true);
    
    // Create tree nodes for each guide
    foreach guideName in guideNames {
        var guideNode: json = call json.jsonFromString("{}");
        // Use filename without extension as display name, replacing underscores with spaces
        var displayName: string = call str.replace(guideName, ".md", "");
        displayName = call str.replace(displayName, "_", " ");
        guideNode = call json.set(guideNode, "value", displayName);
        guideNode = call json.set(guideNode, "icon", "icons/help-page.png");
        guideNode = call json.set(guideNode, "expanded", false);
        // Store the actual filename as a custom property for later retrieval
        guideNode = call json.set(guideNode, "filename", guideName);
        call array.add(guidesChildren, guideNode);
    }
}

var rootChildren: array[*];

// Use json.jsonFromString to create a fresh JSON object to avoid circular references
var syntaxRootNode: json = call json.jsonFromString("{}");
syntaxRootNode = call json.set(syntaxRootNode, "value", "Syntax");
syntaxRootNode = call json.set(syntaxRootNode, "icon", "icons/tree-node.png");
syntaxRootNode = call json.set(syntaxRootNode, "expanded", true);
syntaxRootNode = call json.set(syntaxRootNode, "children", syntaxChildren);
call array.add(rootChildren, syntaxRootNode);

// Use json.jsonFromString to create a fresh JSON object to avoid circular references
var examplesRootNode: json = call json.jsonFromString("{}");
examplesRootNode = call json.set(examplesRootNode, "value", "Examples");
examplesRootNode = call json.set(examplesRootNode, "icon", "icons/tree-node.png");
examplesRootNode = call json.set(examplesRootNode, "expanded", true);
examplesRootNode = call json.set(examplesRootNode, "children", examplesChildren);
call array.add(rootChildren, examplesRootNode);

// Add Guides node if we found any guide files
if guidesChildren.length > 0 then {
    var guidesRootNode: json = call json.jsonFromString("{}");
    guidesRootNode = call json.set(guidesRootNode, "value", "Guides");
    guidesRootNode = call json.set(guidesRootNode, "icon", "icons/tree-node.png");
    guidesRootNode = call json.set(guidesRootNode, "expanded", true);
    guidesRootNode = call json.set(guidesRootNode, "children", guidesChildren);
    call array.add(rootChildren, guidesRootNode);
}

// Use json.jsonFromString to create a fresh JSON object to avoid circular references
var treeStructure: json = call json.jsonFromString("{}");
treeStructure = call json.set(treeStructure, "value", "Help Topics");
treeStructure = call json.set(treeStructure, "icon", "icons/tree-node.png");
treeStructure = call json.set(treeStructure, "expanded", true);
treeStructure = call json.set(treeStructure, "children", rootChildren);


// Load the screen definition from JSON file
var screenJsonText: string = call file.readTextResource("json/help-screen.json");
var screenJson: json = call json.jsonFromString(screenJsonText);

// Inject the dynamic tree structure into the screen definition
// Navigate to the treeItems property and set it
var areaArray: json = call json.get(screenJson, "area");
if areaArray != null && areaArray.length > 0 then {
    var mainLayout: json = areaArray[0];
    var areas: json = call json.get(mainLayout, "areas");
    if areas != null && areas.length > 0 then {
        var treeArea: json = areas[0];
        var nestedAreas: json = call json.get(treeArea, "areas");
        if nestedAreas != null && nestedAreas.length > 1 then {
            // First nested area (index 0) is the searchBox HBox
            // Second nested area (index 1) is the helpTreeArea VBox containing the tree
            var helpTreeArea: json = nestedAreas[1];
            var treeItems: json = call json.get(helpTreeArea, "items");
            if treeItems != null && treeItems.length > 0 then {
                var helpTreeItem: json = treeItems[0];
                var display: json = call json.get(helpTreeItem, "display");
                if display != null then {
                    // Wrap tree structure in array and set it
                    var treeItemsArray: array[*];
                    call array.add(treeItemsArray, treeStructure);
                    display = call json.set(display, "treeItems", treeItemsArray);
                    helpTreeItem = call json.set(helpTreeItem, "display", display);
                    treeItems = call json.set(treeItems, 0, helpTreeItem);
                    helpTreeArea = call json.set(helpTreeArea, "items", treeItems);
                    nestedAreas = call json.set(nestedAreas, 1, helpTreeArea);
                    
                    // Now populate the search combobox options
                    var searchBox: json = nestedAreas[0];
                    var searchItems: json = call json.get(searchBox, "items");
                    if searchItems != null && searchItems.length > 0 then {
                        var searchCombo: json = searchItems[0];
                        var comboDisplay: json = call json.get(searchCombo, "display");
                        if comboDisplay != null then {
                            // Collect all searchable topics
                            var searchOptions: array[*];
                            call collectSearchableTopics(treeStructure, "", searchOptions);
                            
                            // Sort the options alphabetically
                            call array.sort(searchOptions, true);
                            
                            // Set the options in the combobox display
                            comboDisplay = call json.set(comboDisplay, "options", searchOptions);
                            searchCombo = call json.set(searchCombo, "display", comboDisplay);
                            searchItems = call json.set(searchItems, 0, searchCombo);
                            searchBox = call json.set(searchBox, "items", searchItems);
                            nestedAreas = call json.set(nestedAreas, 0, searchBox);
                        }
                    }
                    
                    treeArea = call json.set(treeArea, "areas", nestedAreas);
                    areas = call json.set(areas, 0, treeArea);
                    mainLayout = call json.set(mainLayout, "areas", areas);
                    areaArray = call json.set(areaArray, 0, mainLayout);
                    screenJson = call json.set(screenJson, "area", areaArray);
                    print "Tree items and search options injected into screen definition";
                } else {
                }
            } else {
            }
        }
    }
}

// Function to convert plain text to HTML with <pre> tag
convertToHtml(text: string) return string {
    // Check if the content already contains HTML table tags
    var hasHtmlTable: bool = false;
    if call str.contains(text, "<table") then {
        hasHtmlTable = true;
    }
    
    var bodyContent: string = "";
    
    if hasHtmlTable then {
        // Content has HTML table - need to process heading but preserve table
        // Split to find the heading section and table section
        var tableStartIdx: int = call str.indexOf(text, "<table", 0);
        var beforeTable: string = "";
        var tableContent: string = "";
        
        if tableStartIdx > 0 then {
            beforeTable = call str.substring(text, 0, tableStartIdx);
            tableContent = call str.substring(text, tableStartIdx, text.length);
        } else {
            tableContent = text;
        }
        
        // Process the part before the table (headings, etc.)
        if beforeTable != "" then {
            var lines: array = call str.split(beforeTable, "\n");
            var processedLines: array = [];
            
            var i: int = 0;
            var lastWasHr: bool = false;
            while i < lines.length {
                var line: string = lines[i];
                var trimmedLine: string = call str.trim(line);
                
                // Check if line contains only ═, =, or - characters (more than 5)
                var isHrLine: bool = false;
                var lineLen: int = trimmedLine.length;
                if lineLen > 5 then {
                    var allSeparators: bool = true;
                    var j: int = 0;
                    while j < lineLen {
                        var ch: string = call str.substring(trimmedLine, j, j + 1);
                        if ch != "═" and ch != "=" and ch != "-" then {
                            allSeparators = false;
                            break;
                        }
                        j = j + 1;
                    }
                    if allSeparators then {
                        isHrLine = true;
                    }
                }
                
                if isHrLine then {
                    call array.add(processedLines, "<hr>");
                    lastWasHr = true;
                } else {
                    // Check if this is a title line
                    var isTitle: bool = false;
                    if lastWasHr and trimmedLine != "" then {
                        var nextIdx: int = i + 1;
                        if nextIdx < lines.length then {
                            var nextLine: string = lines[nextIdx];
                            var nextTrimmed: string = call str.trim(nextLine);
                            var nextLineLen: int = nextTrimmed.length;
                            if nextLineLen > 5 then {
                                var nextAllSep: bool = true;
                                var k: int = 0;
                                while k < nextLineLen {
                                    var nextCh: string = call str.substring(nextTrimmed, k, k + 1);
                                    if nextCh != "═" and nextCh != "=" and nextCh != "-" then {
                                        nextAllSep = false;
                                        break;
                                    }
                                    k = k + 1;
                                }
                                if nextAllSep then {
                                    isTitle = true;
                                }
                            }
                        }
                    }
                    
                    if isTitle then {
                        call array.add(processedLines, "<h2>" + line + "</h2>");
                    } else if trimmedLine != "" then {
                        call array.add(processedLines, line);
                    }
                    lastWasHr = false;
                }
                
                i = i + 1;
            }
            
            var beforeTableHtml: string = call str.join(processedLines, "<br>");
            beforeTableHtml = call str.replace(beforeTableHtml, "<hr><br>", "<hr>");
            beforeTableHtml = call str.replace(beforeTableHtml, "</h2><br><hr>", "</h2><hr>");
            bodyContent = beforeTableHtml + tableContent;
        } else {
            bodyContent = tableContent;
        }
    } else {
        // Split into lines to process line by line
        var lines: array = call str.split(text, "\n");
        var processedLines: array = [];
        
        var i: int = 0;
        var lastWasHr: bool = false;
        while i < lines.length {
            var line: string = lines[i];
            var trimmedLine: string = call str.trim(line);
            
            // Check if line contains only ═, =, or - characters (more than 5)
            var isHrLine: bool = false;
            var lineLen: int = trimmedLine.length;
            if lineLen > 5 then {
                var allSeparators: bool = true;
                var j: int = 0;
                while j < lineLen {
                    var ch: string = call str.substring(trimmedLine, j, j + 1);
                    if ch != "═" and ch != "=" and ch != "-" then {
                        allSeparators = false;
                        break;
                    }
                    j = j + 1;
                }
                if allSeparators then {
                    isHrLine = true;
                }
            }
            
            if isHrLine then {
                // Replace separator lines with <hr>
                call array.add(processedLines, "<hr>");
                lastWasHr = true;
            } else {
                // Check if this is a title line (comes after <hr> and before another <hr>)
                var isTitle: bool = false;
                if lastWasHr and trimmedLine != "" then {
                    // Look ahead to see if next non-empty line is also <hr>
                    var nextIdx: int = i + 1;
                    if nextIdx < lines.length then {
                        var nextLine: string = lines[nextIdx];
                        var nextTrimmed: string = call str.trim(nextLine);
                        var nextLineLen: int = nextTrimmed.length;
                        if nextLineLen > 5 then {
                            var nextAllSep: bool = true;
                            var k: int = 0;
                            while k < nextLineLen {
                                var nextCh: string = call str.substring(nextTrimmed, k, k + 1);
                                if nextCh != "═" and nextCh != "=" and nextCh != "-" then {
                                    nextAllSep = false;
                                    break;
                                }
                                k = k + 1;
                            }
                            if nextAllSep then {
                                isTitle = true;
                            }
                        }
                    }
                }
                
                if isTitle then {
                    // Wrap title in heading tags
                    call array.add(processedLines, "<h2>" + line + "</h2>");
                } else {
                    // Check if this is a subheading (starts with ▸ or ALL CAPS word followed by colon)
                    var isSubheading: bool = false;
                    if trimmedLine != "" then {
                        // Check for "▸ " prefix
                        if call str.startsWith(trimmedLine, "▸ ") then {
                            isSubheading = true;
                        } else {
                            // Check for ALL CAPS pattern like "OVERVIEW:", "SYNTAX:", "EXAMPLE 1:"
                            var colonIdx: int = call str.indexOf(trimmedLine, ":", 0);
                            if colonIdx > 0 then {
                                var beforeColon: string = call str.substring(trimmedLine, 0, colonIdx);
                                // Check if it's all uppercase letters, spaces, and numbers
                                var allUpper: bool = true;
                                var bcLen: int = beforeColon.length;
                                var m: int = 0;
                                while m < bcLen {
                                    var ch: string = call str.substring(beforeColon, m, m + 1);
                                    // Allow uppercase letters, spaces, numbers, and common punctuation (&, -, /)
                                    if ch != " " and ch != "&" and ch != "-" and ch != "/" and ch != "A" and ch != "B" and ch != "C" and ch != "D" and ch != "E" and ch != "F" and ch != "G" and ch != "H" and ch != "I" and ch != "J" and ch != "K" and ch != "L" and ch != "M" and ch != "N" and ch != "O" and ch != "P" and ch != "Q" and ch != "R" and ch != "S" and ch != "T" and ch != "U" and ch != "V" and ch != "W" and ch != "X" and ch != "Y" and ch != "Z" and ch != "0" and ch != "1" and ch != "2" and ch != "3" and ch != "4" and ch != "5" and ch != "6" and ch != "7" and ch != "8" and ch != "9" then {
                                        allUpper = false;
                                        break;
                                    }
                                    m = m + 1;
                                }
                                if allUpper and bcLen > 0 then {
                                    isSubheading = true;
                                }
                            }
                        }
                    }
                    
                    if isSubheading then {
                        // Wrap subheading in bold tags
                        call array.add(processedLines, "<b>" + line + "</b>");
                    } else {
                        // Add the line as-is
                        call array.add(processedLines, line);
                    }
                }
                lastWasHr = false;
            }
            
            i = i + 1;
        }
        
        // Join lines with <br>
        bodyContent = call str.join(processedLines, "<br>");
        
        // Remove extra <br> after <hr> tags
        bodyContent = call str.replace(bodyContent, "<hr><br>", "<hr>");
        
        // Remove extra <br> between heading and <hr>
        bodyContent = call str.replace(bodyContent, "</h2><br><hr>", "</h2><hr>");
    }
    
    // Wrap in HTML structure without pre tag
    var result: string = "<!DOCTYPE html><html><head><style>";
    result = result + "body { margin: 10px; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: 12px; }";
    result = result + "hr { border: 0; border-top: 1px solid #ccc; margin: 10px 0; }";
    result = result + "h2 { font-size: 18px; font-weight: bold; margin: 10px 0; color: #333; }";
    result = result + "b { font-weight: bold; color: #2c5aa0; }";
    result = result + "table { border-collapse: collapse; width: 100%; margin: 10px 0; }";
    result = result + "th, td { text-align: left; padding: 8px; border: 1px solid #ddd; }";
    result = result + "th { background-color: #e0e0e0; font-weight: bold; }";
    result = result + "tr:nth-child(even) { background-color: #f9f9f9; }";
    result = result + "</style></head><body>";
    result = result + bodyContent;
    result = result + "</body></html>";
    
    return result;
}

// Function to strip HTML tags from content
stripHtmlTags(text: string) return string {
    var cleaned: string = text;
    // Remove common HTML tags
    cleaned = call str.replace(cleaned, "<br>", "\n");
    cleaned = call str.replace(cleaned, "<b>", "");
    cleaned = call str.replace(cleaned, "</b>", "");
    cleaned = call str.replace(cleaned, "<code>", "");
    cleaned = call str.replace(cleaned, "</code>", "");
    cleaned = call str.replace(cleaned, "<i>", "");
    cleaned = call str.replace(cleaned, "</i>", "");
    return cleaned;
}

// Function to get keyword help from JSON
getKeywordHelp(keyword: string) return string {
    if helpData == null then {
        return "";
    }
    
    var keywords: json = call json.get(helpData, "keywords");
    if keywords == null then {
        return "";
    }
    
    foreach kw in keywords {
        var kwName: string = call json.getString(kw, "keyword", "");
        if kwName == keyword then {
            var desc: string = call json.getString(kw, "short_description", "");
            var longHelp: string = call json.getString(kw, "long_help", "");
            var example: string = call json.getString(kw, "example", "");
            var format: string = call json.getString(kw, "format", "text");
            
            var content: string = "";
            content = content + "KEYWORD: " + keyword + "\n";
            content = content + "───────────────────────────────────────────────────────\n\n";
            
            if desc != "" then {
                content = content + "DESCRIPTION:\n";
                content = content + desc + "\n\n";
            }
            
            if longHelp != "" then {
                content = content + "DETAILS:\n";
                // Process content based on format
                if format == "html" then {
                    // Remove HTML tags for textarea display
                    var cleanHelp: string = call stripHtmlTags(longHelp);
                    content = content + cleanHelp + "\n\n";
                } else {
                    // Plain text, use as-is
                    content = content + longHelp + "\n\n";
                }
            }
            
            if example != "" then {
                content = content + "EXAMPLE:\n";
                // Process example based on format
                if format == "html" then {
                    var cleanExample: string = call stripHtmlTags(example);
                    content = content + cleanExample + "\n";
                } else {
                    content = content + example + "\n";
                }
            }
            
            return content;
        }
    }
    
    return "";
}

// Function to get topic content from JSON
getTopicFromJson(topicKey: string) return string {
    if helpData == null then {
        return "";
    }
    
    var topics: json = call json.get(helpData, "topics");
    if topics == null then {
        return "";
    }
    
    var topic: json = call json.get(topics, topicKey);
    if topic == null then {
        return "";
    }
    
    var title: string = call json.getString(topic, "title", "");
    var content: string = call json.getString(topic, "content", "");
    
    if title == "" && content == "" then {
        return "";
    }
    
    var result: string = "";
    
    // Check if content already starts with a title section (═══ separator)
    var contentHasTitle: bool = false;
    if content != "" then {
        if call str.startsWith(content, "═══") then {
            contentHasTitle = true;
        }
    }
    
    // Only add title if content doesn't already have one
    if title != "" && !contentHasTitle then {
        result = "═══════════════════════════════════════════════════════\n";
        result = result + "  " + title + "\n";
        result = result + "═══════════════════════════════════════════════════════\n\n";
    }
    
    if content != "" then {
        result = result + content;
    }
    
    return result;
}

// Function to get builtin help from system registry
getBuiltinHelp(builtinName: string) return string {
    if builtinsArray == null then {
        return "Builtins data not available.";
    }
    
    // First try to get detailed help from system.help(keyword)
    var detailedHelp: string = call system.help(builtinName);
    if detailedHelp != "" && !call str.contains(detailedHelp, "No help found") then {
        return detailedHelp;
    }
    
    // Fall back to signature from parsed help data
    foreach builtin in builtinsArray {
        var name: string = call json.getString(builtin, "name", "");
        if name == builtinName then {
            var signature: string = call json.getString(builtin, "signature", "");
            
            var content: string = "";
            content = content + "═══════════════════════════════════════════════════════\n";
            content = content + "  " + name + "\n";
            content = content + "═══════════════════════════════════════════════════════\n\n";
            
            content = content + "▸ SIGNATURE\n";
            content = content + "───────────────────────────────────────────────────────\n";
            content = content + "call " + signature + "\n";
            content = content + "\n";
            
            // Try to get additional help from JSON lookup
            if helpData != null then {
                var builtinsJsonArray: json = call json.get(helpData, "builtins");
                if builtinsJsonArray != null then {
                    foreach builtinJson in builtinsJsonArray {
                        var funcName: string = call json.getString(builtinJson, "function", "");
                        if funcName == builtinName then {
                            var shortDesc: string = call json.getString(builtinJson, "short_description", "");
                            var longHelp: string = call json.getString(builtinJson, "long_help", "");
                            var example: string = call json.getString(builtinJson, "example", "");
                            var format: string = call json.getString(builtinJson, "format", "text");
                            
                            if shortDesc != "" then {
                                content = content + "▸ DESCRIPTION\n";
                                content = content + "───────────────────────────────────────────────────────\n";
                                content = content + shortDesc + "\n\n";
                            }
                            
                            if longHelp != "" then {
                                content = content + "▸ DETAILS\n";
                                content = content + "───────────────────────────────────────────────────────\n";
                                if format == "html" then {
                                    var cleanHelp: string = call stripHtmlTags(longHelp);
                                    content = content + cleanHelp + "\n\n";
                                } else {
                                    content = content + longHelp + "\n\n";
                                }
                            }
                            
                            if example != "" then {
                                content = content + "▸ EXAMPLE\n";
                                content = content + "───────────────────────────────────────────────────────\n";
                                if format == "html" then {
                                    var cleanExample: string = call stripHtmlTags(example);
                                    content = content + cleanExample + "\n";
                                } else {
                                    content = content + example + "\n";
                                }
                            }
                        }
                    }
                }
            }
            
            return content;
        }
    }
    
    return "No help found for builtin: " + builtinName;
}

// Function to get guide content from markdown file
getGuideContent(guideName: string) return string {
    // guideName could be the display name (with spaces) or filename
    // Try to find the matching guide file
    var guidesPath: string = "guides";
    var guideFiles: json = call file.listFiles(guidesPath);
    
    if guideFiles != null && guideFiles.length > 0 then {
        foreach guideFile in guideFiles {
            var fileName: string = call json.getString(guideFile, "name", "");
            var isDir: bool = call json.getBool(guideFile, "isDir", false);
            
            // Only check .md files
            if !isDir && call str.endsWith(fileName, ".md") then {
                // Create display name from filename
                var displayName: string = call str.replace(fileName, ".md", "");
                displayName = call str.replace(displayName, "_", " ");
                
                // Check if this matches the requested guide name
                if displayName == guideName || fileName == guideName then {
                    // Read the markdown file
                    try {
                        var filePath: string = guidesPath + "/" + fileName;
                        var markdownContent: string = call file.readTextFile(filePath);
                        
                        // Convert markdown to HTML using the builtin function
                        var htmlContent: string = call file.markdownToHtml(markdownContent, true);
                        
                        return htmlContent;
                    } exceptions {
                        when ex {
                            var errorMsg: string = "Error loading guide: " + ex;
                            return errorMsg;
                        }
                    }
                }
            }
        }
    }
    
    return "Guide not found: " + guideName;
}

// Function to get help content based on selected topic
getHelpContent(topic: string) return string {
    var content: string = "";
    
    // Check if this is a guide topic (matches a guide display name)
    // Try to load it as a guide first
    var guidesPath: string = "guides";
    var guideFiles: json = call file.listFiles(guidesPath);
    
    if guideFiles != null && guideFiles.length > 0 then {
        foreach guideFile in guideFiles {
            var fileName: string = call json.getString(guideFile, "name", "");
            var isDir: bool = call json.getBool(guideFile, "isDir", false);
            
            if !isDir && call str.endsWith(fileName, ".md") then {
                var displayName: string = call str.replace(fileName, ".md", "");
                displayName = call str.replace(displayName, "_", " ");
                
                if displayName == topic then {
                    return call getGuideContent(topic);
                }
            }
        }
    }
    
    // Check for scr.setProperty sub-topics first (special case)
    // Map property names to their topic keys
    if topic == "Overview" then {
        // Check if parent is scr.setProperty - for now just map to overview topic
        topic = "scr_setproperty_overview";
    } else if topic == "value" || topic == "text" then {
        topic = "scr_setproperty_value";
    } else if topic == "editable" then {
        topic = "scr_setproperty_editable";
    } else if topic == "disabled" then {
        topic = "scr_setproperty_disabled";
    } else if topic == "visible" then {
        topic = "scr_setproperty_visible";
    } else if topic == "tooltip" then {
        topic = "scr_setproperty_tooltip";
    } else if topic == "textColor" then {
        topic = "scr_setproperty_textcolor";
    } else if topic == "backgroundColor" then {
        topic = "scr_setproperty_backgroundcolor";
    } else if topic == "colSpan" then {
        topic = "scr_setproperty_colspan";
    } else if topic == "rowSpan" then {
        topic = "scr_setproperty_rowspan";
    } else if topic == "hgrow" then {
        topic = "scr_setproperty_hgrow";
    } else if topic == "vgrow" then {
        topic = "scr_setproperty_vgrow";
    } else if topic == "margin" then {
        topic = "scr_setproperty_margin";
    } else if topic == "padding" then {
        topic = "scr_setproperty_padding";
    } else if topic == "prefWidth" then {
        topic = "scr_setproperty_prefwidth";
    } else if topic == "prefHeight" then {
        topic = "scr_setproperty_prefheight";
    } else if topic == "minWidth" then {
        topic = "scr_setproperty_minwidth";
    } else if topic == "minHeight" then {
        topic = "scr_setproperty_minheight";
    } else if topic == "maxWidth" then {
        topic = "scr_setproperty_maxwidth";
    } else if topic == "maxHeight" then {
        topic = "scr_setproperty_maxheight";
    } else if topic == "alignment" then {
        topic = "scr_setproperty_alignment";
    }
    
    // Check if this is a builtin function name (contains a dot like "str.trim")
    // Valid builtin names have at least one char before the dot (e.g., "str.trim", "array.add")
    // Note: Other help topics use underscores (e.g., "structure_basic"), so dot detection is safe
    var dotIndex: int = call str.indexOf(topic, ".", 0);
    if dotIndex > 0 then {
        // This is a builtin function
        return call getBuiltinHelp(topic);
    }
    
    // Check if this topic matches a category display name
    if builtinCategoryNames != null && categoryOrderArray.length > 0 then {
        // Iterate through category names to find a match
        foreach categoryKey in categoryOrderArray {
            var displayName: string = call json.getString(builtinCategoryNames, categoryKey, "");
            if displayName == topic then {
                // Found matching category - show overview
                var categoryArray: json = call json.get(builtinsByCategory, categoryKey);
                
                content = "═══════════════════════════════════════════════════════\n";
                content = content + "  " + displayName + "\n";
                content = content + "═══════════════════════════════════════════════════════\n\n";
                content = content + "This category contains builtin functions.\n\n";
                content = content + "Select a function from the tree to view its documentation.\n\n";
                
                // List functions in this category
                if categoryArray != null then {
                    content = content + "▸ FUNCTIONS IN THIS CATEGORY\n";
                    content = content + "───────────────────────────────────────────────────────\n";
                    foreach funcNode in categoryArray {
                        var funcValue: string = call json.getString(funcNode, "value", "");
                        content = content + "  • " + funcValue + "\n";
                    }
                }
                
                return content;
            }
        }
    }
    
    // Map renamed tree node display names to topic keys
    // These mappings ensure the new display names (without underscores) map to the correct topic keys
    if topic == "Getting started" then {
        topic = "getting_started";
    }
    if topic == "Structure" then {
        topic = "structure";
    }
    if topic == "Basic" then {
        topic = "structure_basic";
    }
    if topic == "Variables" then {
        topic = "structure_variables";
    }
    if topic == "Operators" then {
        topic = "structure_operators";
    }
    if topic == "Functions" then {
        topic = "structure_functions";
    }
    if topic == "Imports" then {
        topic = "structure_imports";
    }
    if topic == "Data" then {
        topic = "data";
    }
    if topic == "Collections" then {
        topic = "collections";
    }
    if topic == "Flow" then {
        topic = "flow";
    }
    if topic == "Keywords" then {
        topic = "keywords";
    }
    if topic == "Builtins" then {
        topic = "builtins";
    }
    if topic == "Screen" then {
        topic = "screen";
    }
    
    // Map flow display names to topic keys
    if topic == "Conditionals" then {
        topic = "flow_conditionals";
    }
    if topic == "Loops" then {
        topic = "flow_loops";
    }
    if topic == "Break and Continue" then {
        topic = "flow_break_continue";
    }
    if topic == "Exception Handling" then {
        topic = "flow_exceptions";
    }
    
    // Map screen sub-topic display names to topic keys
    if topic == "Screen data" then {
        topic = "screen_data";
    }
    if topic == "Screen display" then {
        topic = "screen_display";
    }
    if topic == "Screen areas" then {
        topic = "screen_areas";
    }
    if topic == "Screen items" then {
        topic = "screen_items";
    }
    
    // Map collections display names to topic keys
    if topic == "Arrays" then {
        topic = "collections_arrays";
    }
    if topic == "JSON" then {
        topic = "collections_json";
    }
    if topic == "Records" then {
        topic = "collections_records";
    }
    if topic == "Bitmap and Intmap" then {
        topic = "collections_bitmap";
    }
    
    // Map data type display names to topic keys
    if topic == "Integer Types" then {
        topic = "data_integer";
    }
    if topic == "Floating Point" then {
        topic = "data_float";
    }
    if topic == "String" then {
        topic = "data_string";
    }
    if topic == "Boolean" then {
        topic = "data_boolean";
    }
    if topic == "Date" then {
        topic = "data_date";
    }
    if topic == "Bitmap" then {
        topic = "data_bitmap";
    }
    if topic == "Intmap" then {
        topic = "data_intmap";
    }
    
    // Handle example topic aliases (Keywords/examples_keywords, etc.)
    if topic == "examples_keywords" then {
        topic = "Keywords";
    }
    if topic == "examples_builtins" then {
        topic = "Builtins";
    }
    if topic == "examples_screen" then {
        topic = "Screen";
    }
    
    // Get all content from JSON
    var jsonContent: string = call getTopicFromJson(topic);
    if jsonContent != "" then {
        return jsonContent;
    }
    
    // If no specific topic found, return default content
    var defaultContent: string = call getTopicFromJson("default");
    if defaultContent != "" then {
        return defaultContent;
    }
    
    // Ultimate fallback if JSON fails
    content = "=== EBS Help ===\n\n";
    content = content + "Select a topic from the tree to view help documentation.\n";
    return content;
}

// Function to collect all searchable topics from tree structure
collectSearchableTopics(node: json, prefix: string, results: json) {
    // Get node value
    var nodeValue: string = call json.getString(node, "value", "");
    
    // Add this node to search results if it has a value
    if nodeValue != "" then {
        // Build full path for display
        var fullPath: string = "";
        if prefix != "" then {
            fullPath = prefix + " > " + nodeValue;
        } else {
            fullPath = nodeValue;
        }
        call array.add(results, fullPath);
    }
    
    // Recursively process children
    var children: json = call json.get(node, "children");
    if children != null && children.length > 0 then {
        var newPrefix: string = "";
        if prefix != "" then {
            newPrefix = prefix + " > " + nodeValue;
        } else {
            newPrefix = nodeValue;
        }
        
        var i: int = 0;
        while i < children.length {
            var child: json = children[i];
            call collectSearchableTopics(child, newPrefix, results);
            i = i + 1;
        }
    }
}

// Function to perform search
performSearch(query: string) {
    if query == "" then {
        return;
    }
    
    // Normalize query to lowercase for case-insensitive search
    var lowerQuery: string = call str.toLower(query);
    
    // Search through all searchable topics to find a match
    var allTopics: array[*];
    call collectSearchableTopics(treeStructure, "", allTopics);
    
    // Find the best match
    var bestMatch: string = "";
    var bestMatchFullPath: string = "";
    
    // Debug: Show search query
    print "=== Help Search Debug ===";
    print "Search query: " + query;
    
    foreach topicPath in allTopics {
        var lowerPath: string = call str.toLower(topicPath);
        
        // Extract the leaf name (last component after " > ")
        var leafName: string = topicPath;
        if call str.contains(topicPath, " > ") then {
            var parts: array = call str.split(topicPath, " > ", 0);
            var lastIdx: int = parts.length - 1;
            if lastIdx >= 0 then {
                leafName = parts[lastIdx];
            }
        }
        var lowerLeaf: string = call str.toLower(leafName);
        
        // Check for exact match on leaf name (highest priority)
        if lowerLeaf == lowerQuery then {
            bestMatch = leafName;
            bestMatchFullPath = topicPath;
            break;
        } else if call str.contains(lowerLeaf, lowerQuery) then {
            // Partial match on leaf name
            if bestMatch == "" then {
                bestMatch = leafName;
                bestMatchFullPath = topicPath;
            }
        } else if call str.contains(lowerPath, lowerQuery) then {
            // Partial match on full path
            if bestMatch == "" then {
                bestMatch = leafName;
                bestMatchFullPath = topicPath;
            }
        }
    }
    
    // Debug: Show search results
    print "Best match found: " + bestMatch;
    print "Full path: " + bestMatchFullPath;
    
    // If we found a match, update the selected topic via screen variable
    // Use the full path for tree selection (e.g., "Basic > Variables")
    // This will trigger tree selection and content update via the onChange event
    if bestMatch != "" then {
        print "Setting selectedTopic to: " + bestMatchFullPath;
        helpScreen.selectedTopic = bestMatchFullPath;
        print "selectedTopic set complete";
    } else {
        // Show message if no match found
        print "No match found";
        helpScreen.helpContent = call convertToHtml("No help topic found matching: " + query);
    }
    print "=== End Search Debug ===";
}

// Create the help screen from the modified JSON
screen helpScreen = screenJson;

// Set initial content by setting the screen variable (not scr.setProperty)
// The WebView is bound to helpContent variable, so we set that instead
helpScreen.helpContent = call convertToHtml(call getHelpContent(""));

// Show the screen
show screen helpScreen;

// Apply bold styling to all non-leaf nodes (nodes with children) in the tree
// Wait a moment for the screen to be fully initialized
call thread.sleep(100);

// Root node
call scr.setTreeItemBold("helpScreen", "Help Topics", true);

// Top-level nodes with children
call scr.setTreeItemBold("helpScreen", "Help Topics.Syntax", true);
call scr.setTreeItemBold("helpScreen", "Help Topics.Examples", true);
if guidesChildren.length > 0 then {
    call scr.setTreeItemBold("helpScreen", "Help Topics.Guides", true);
}

// Syntax section nodes with children
call scr.setTreeItemBold("helpScreen", "Help Topics.Syntax.Structure", true);
call scr.setTreeItemBold("helpScreen", "Help Topics.Syntax.Data", true);
call scr.setTreeItemBold("helpScreen", "Help Topics.Syntax.Collections", true);
call scr.setTreeItemBold("helpScreen", "Help Topics.Syntax.Flow", true);
call scr.setTreeItemBold("helpScreen", "Help Topics.Syntax.Builtins", true);
call scr.setTreeItemBold("helpScreen", "Help Topics.Syntax.Screen", true);

// Data section - Integer Types has children
call scr.setTreeItemBold("helpScreen", "Help Topics.Syntax.Data.Integer Types", true);

// Screen section - Screen items has children (control types)
call scr.setTreeItemBold("helpScreen", "Help Topics.Syntax.Screen.Screen items", true);

// Builtins section - all category nodes have children
if categoryOrderArray.length > 0 then {
    foreach categoryKey in categoryOrderArray {
        var displayName: string = categoryKey;
        if builtinCategoryNames != null then {
            var jsonDisplayName: string = call json.getString(builtinCategoryNames, categoryKey, "");
            if jsonDisplayName != "" then {
                displayName = jsonDisplayName;
            }
        }
        call scr.setTreeItemBold("helpScreen", "Help Topics.Syntax.Builtins." + displayName, true);
    }
}

