// ============================================================================
// help.ebs - EBS Syntax Help Screen
// ============================================================================
// This script displays a help screen with a tree view on the left for
// navigation and a content area on the right for displaying help documents.
// ============================================================================


// Load help data from JSON file
// Note: Echo is disabled by default in Environment, so resource loading happens silently
var helpData: json = null;
try {
    // Read from classpath resources using the new resource loader
    // This loads from the application resources, not the file system
    var jsonContent: string = call file.readTextResource("help-lookup.json");
    helpData = call json.jsonFromString(jsonContent);
} exceptions {
    when ex {
        print "Warning: Could not load help-lookup.json: " + ex;
        print "Help will be displayed without JSON-based keyword descriptions";
    }
}

// Get all builtins from system registry
var systemHelpText: string = call system.help();

// Parse the help text to extract builtin information
// The format is: "builtin.name(param1:type, param2:type?) : returnType"
var builtinLines: array = call str.split(systemHelpText, "\n", 0);
var builtinsArray: array[*] = [];
var inBuiltinsSection: bool = false;

foreach line in builtinLines {
    var trimmedLine: string = call str.trim(line);
    if trimmedLine == "Builtins:" then {
        inBuiltinsSection = true;
    } else if inBuiltinsSection then {
        // Check if the original line (not trimmed) starts with space to identify indented builtin lines
        if trimmedLine != "" && call str.startsWith(line, " ") then {
            // Extract builtin name from line like "  array.add(array:array, value:any, index:integer?) : null"
            var parenIndex: int = call str.indexOf(trimmedLine, "(", 0);
            if parenIndex > 0 then {
                var builtinName: string = call str.substring(trimmedLine, 0, parenIndex);
                // Create a fresh JSON object for each builtin to avoid reference issues
                var builtinInfo: json = call json.jsonFromString("{}");
                builtinInfo = call json.set(builtinInfo, "name", builtinName);
                builtinInfo = call json.set(builtinInfo, "signature", trimmedLine);
                call array.add(builtinsArray, builtinInfo);
            }
        } else if trimmedLine == "" then {
            // Empty line - could be end of section or spacing within section
            // Continue to allow for spacing within the builtins section
        } else {
            // Non-indented, non-empty line marks end of builtins section
            inBuiltinsSection = false;
        }
    }
}

var builtinCount: int = builtinsArray.length;

// Load category information from help data
var builtinCategoryNames: json = null;
var builtinCategoryOrder: json = null;
if helpData != null then {
    var topics: json = call json.get(helpData, "topics");
    if topics != null then {
        builtinCategoryNames = call json.get(topics, "builtin_categories");
        builtinCategoryOrder = call json.get(topics, "builtin_category_order");
        if builtinCategoryNames != null then {
        } else {
        }
        if builtinCategoryOrder != null then {
        } else {
        }
    } else {
    }
} else {
}

// Categorize builtins by module
// Use json to store arrays of builtins for each category
// Use json.jsonFromString to create a fresh JSON object to avoid circular references
var builtinsByCategory: json = call json.jsonFromString("{}");
if builtinsArray != null then {
    var debugCount: int = 0;
    foreach builtin in builtinsArray {
        var builtinName: string = call json.getString(builtin, "name", "");
        if builtinName != "" then {
            // Extract category (module) from builtin name (e.g., "str.trim" -> "str")
            var dotIndex: int = call str.indexOf(builtinName, ".", 0);
            var category: string = "other";
            if dotIndex > 0 then {
                category = call str.substring(builtinName, 0, dotIndex);
            }
            
            // Debug first 5 categorizations
            if debugCount < 5 then {
                debugCount = debugCount + 1;
            }
            
            // Create child node with builtin name as a JSON object
            // Use json.jsonFromString to create a fresh JSON object to avoid circular references
            var childNode: json = call json.jsonFromString("{}");
            childNode = call json.set(childNode, "value", builtinName);
            childNode = call json.set(childNode, "icon", "icons/help-page.png");
            
            // Use json.add to append to the array at the category path
            // json.add automatically creates the array if it doesn't exist and appends the item
            builtinsByCategory = call json.add(builtinsByCategory, category, childNode);
        }
    }
} else {
}

// Build categorized builtin tree using category order from JSON
var builtinChildren: array[*];
var totalBuiltins: int = 0;

if builtinCategoryOrder != null then {
    foreach categoryKey in builtinCategoryOrder {
        // Get category array from json using json.getArray to properly handle JSON arrays
        var categoryArray: json = call json.getArray(builtinsByCategory, categoryKey);
        if categoryArray != null then {
            // Debug: print first 3 function names if they exist
            var firstFunc: json = call json.get(categoryArray, "0");
            if firstFunc != null then {
                var firstName: string = call json.getString(firstFunc, "value", "");
            }
            var secondFunc: json = call json.get(categoryArray, "1");
            if secondFunc != null then {
                var secondName: string = call json.getString(secondFunc, "value", "");
            }
            var thirdFunc: json = call json.get(categoryArray, "2");
            if thirdFunc != null then {
                var thirdName: string = call json.getString(thirdFunc, "value", "");
            }
            // Get display name from JSON, fallback to key
            var displayName: string = categoryKey;
            if builtinCategoryNames != null then {
                var jsonDisplayName: string = call json.getString(builtinCategoryNames, categoryKey, "");
                if jsonDisplayName != "" then {
                    displayName = jsonDisplayName;
                }
            }
            
            // Use displayName as the tree node value for visibility
            // Use json.jsonFromString to create a fresh JSON object to avoid circular references
            var categoryNode: json = call json.jsonFromString("{}");
            categoryNode = call json.set(categoryNode, "value", displayName);
            categoryNode = call json.set(categoryNode, "icon", "icons/tree-node.png");
            categoryNode = call json.set(categoryNode, "expanded", false);
            categoryNode = call json.set(categoryNode, "children", categoryArray);
            call array.add(builtinChildren, categoryNode);
            totalBuiltins = totalBuiltins + 1; // Count categories, not individual functions
        } else {
        }
    }
} else {
}


// Build the complete tree structure dynamically with icons
var structureChildren: array[*];
var tempNode: json;

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "structure_basic");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(structureChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "structure_variables");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(structureChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "structure_operators");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(structureChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "structure_functions");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(structureChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "structure_imports");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(structureChildren, tempNode);

var flowChildren: array[*];

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Conditionals");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(flowChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Loops");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(flowChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Break and Continue");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(flowChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Exception Handling");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(flowChildren, tempNode);

var syntaxChildren: array[*];

// Add Getting Started as first item
tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "getting_started");
tempNode = call json.set(tempNode, "icon", "icons/help-page.png");
call array.add(syntaxChildren, tempNode);

// Use json.jsonFromString to create a fresh JSON object to avoid circular references
var structureNode: json = call json.jsonFromString("{}");
structureNode = call json.set(structureNode, "value", "structure");
structureNode = call json.set(structureNode, "icon", "icons/tree-node.png");
structureNode = call json.set(structureNode, "expanded", false);
structureNode = call json.set(structureNode, "children", structureChildren);
call array.add(syntaxChildren, structureNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "data");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(syntaxChildren, tempNode);

// Use json.jsonFromString to create a fresh JSON object to avoid circular references
var flowNode: json = call json.jsonFromString("{}");
flowNode = call json.set(flowNode, "value", "flow");
flowNode = call json.set(flowNode, "icon", "icons/tree-node.png");
flowNode = call json.set(flowNode, "expanded", false);
flowNode = call json.set(flowNode, "children", flowChildren);
call array.add(syntaxChildren, flowNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "keywords");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(syntaxChildren, tempNode);

// Use json.jsonFromString to create a fresh JSON object to avoid circular references
var builtinsNode: json = call json.jsonFromString("{}");
builtinsNode = call json.set(builtinsNode, "value", "builtins");
builtinsNode = call json.set(builtinsNode, "icon", "icons/tree-node.png");
builtinsNode = call json.set(builtinsNode, "expanded", false);
builtinsNode = call json.set(builtinsNode, "children", builtinChildren);
call array.add(syntaxChildren, builtinsNode);

// Build screen children with sub-topics
var screenChildren: array[*];

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "screen_data");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(screenChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "screen_display");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(screenChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "screen_areas");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(screenChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "screen_items");
tempNode = call json.set(tempNode, "icon", "icons/info-page.png");
call array.add(screenChildren, tempNode);

// Create screen node with children
var screenNode: json = call json.jsonFromString("{}");
screenNode = call json.set(screenNode, "value", "screen");
screenNode = call json.set(screenNode, "icon", "icons/tree-node.png");
screenNode = call json.set(screenNode, "expanded", false);
screenNode = call json.set(screenNode, "children", screenChildren);
call array.add(syntaxChildren, screenNode);

var examplesChildren: array[*];

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Keywords");
tempNode = call json.set(tempNode, "icon", "icons/normal-page.png");
call array.add(examplesChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Builtins");
tempNode = call json.set(tempNode, "icon", "icons/normal-page.png");
call array.add(examplesChildren, tempNode);

tempNode = call json.jsonFromString("{}");
tempNode = call json.set(tempNode, "value", "Screen");
tempNode = call json.set(tempNode, "icon", "icons/normal-page.png");
call array.add(examplesChildren, tempNode);

var rootChildren: array[*];

// Use json.jsonFromString to create a fresh JSON object to avoid circular references
var syntaxRootNode: json = call json.jsonFromString("{}");
syntaxRootNode = call json.set(syntaxRootNode, "value", "Syntax");
syntaxRootNode = call json.set(syntaxRootNode, "icon", "icons/tree-node.png");
syntaxRootNode = call json.set(syntaxRootNode, "expanded", false);
syntaxRootNode = call json.set(syntaxRootNode, "children", syntaxChildren);
call array.add(rootChildren, syntaxRootNode);

// Use json.jsonFromString to create a fresh JSON object to avoid circular references
var examplesRootNode: json = call json.jsonFromString("{}");
examplesRootNode = call json.set(examplesRootNode, "value", "Examples");
examplesRootNode = call json.set(examplesRootNode, "icon", "icons/tree-node.png");
examplesRootNode = call json.set(examplesRootNode, "expanded", true);
examplesRootNode = call json.set(examplesRootNode, "children", examplesChildren);
call array.add(rootChildren, examplesRootNode);

// Use json.jsonFromString to create a fresh JSON object to avoid circular references
var treeStructure: json = call json.jsonFromString("{}");
treeStructure = call json.set(treeStructure, "value", "Help Topics");
treeStructure = call json.set(treeStructure, "icon", "icons/tree-node.png");
treeStructure = call json.set(treeStructure, "expanded", true);
treeStructure = call json.set(treeStructure, "children", rootChildren);


// Load the screen definition from JSON file
var screenJsonText: string = call file.readTextResource("json/help-screen.json");
var screenJson: json = call json.jsonFromString(screenJsonText);

// Inject the dynamic tree structure into the screen definition
// Navigate to the treeItems property and set it
var areaArray: json = call json.get(screenJson, "area");
if areaArray != null && areaArray.length > 0 then {
    var mainLayout: json = areaArray[0];
    var areas: json = call json.get(mainLayout, "areas");
    if areas != null && areas.length > 0 then {
        var treeArea: json = areas[0];
        var items: json = call json.get(treeArea, "items");
        if items != null && items.length > 0 then {
            var helpTreeItem: json = items[0];
            var display: json = call json.get(helpTreeItem, "display");
            if display != null then {
                // Wrap tree structure in array and set it
                var treeItemsArray: array[*];
                call array.add(treeItemsArray, treeStructure);
                display = call json.set(display, "treeItems", treeItemsArray);
                helpTreeItem = call json.set(helpTreeItem, "display", display);
                items = call json.set(items, 0, helpTreeItem);
                treeArea = call json.set(treeArea, "items", items);
                areas = call json.set(areas, 0, treeArea);
                mainLayout = call json.set(mainLayout, "areas", areas);
                areaArray = call json.set(areaArray, 0, mainLayout);
                screenJson = call json.set(screenJson, "area", areaArray);
                print "Tree items injected into screen definition";
            } else {
            }
        }
    }
}

// Function to convert plain text to HTML with <pre> tag
convertToHtml(text: string) return string {
    // Split into lines to process line by line
    var lines: array = call str.split(text, "\n");
    var processedLines: array = [];
    
    var i: int = 0;
    while i < lines.length {
        var line: string = lines[i];
        var trimmedLine: string = call str.trim(line);
        
        // Check if line contains only ═, =, or - characters (more than 5)
        var isHrLine: bool = false;
        var lineLen: int = trimmedLine.length;
        if lineLen > 5 then {
            var allSeparators: bool = true;
            var j: int = 0;
            while j < lineLen {
                var ch: string = call str.substring(trimmedLine, j, j + 1);
                if ch != "═" and ch != "=" and ch != "-" then {
                    allSeparators = false;
                    break;
                }
                j = j + 1;
            }
            if allSeparators then {
                isHrLine = true;
            }
        }
        
        if isHrLine then {
            // Replace separator lines with <hr>
            call array.add(processedLines, "<hr>");
        } else {
            // Add the line as-is
            call array.add(processedLines, line);
        }
        
        i = i + 1;
    }
    
    // Join lines with <br>
    var bodyContent: string = call str.join(processedLines, "<br>");
    
    // Wrap in HTML structure without pre tag
    var result: string = "<!DOCTYPE html><html><head><style>";
    result = result + "body { margin: 10px; font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: 12px; }";
    result = result + "hr { border: 0; border-top: 1px solid #ccc; margin: 10px 0; }";
    result = result + "</style></head><body>";
    result = result + bodyContent;
    result = result + "</body></html>";
    
    return result;
}

// Function to strip HTML tags from content
stripHtmlTags(text: string) return string {
    var cleaned: string = text;
    // Remove common HTML tags
    cleaned = call str.replace(cleaned, "<br>", "\n");
    cleaned = call str.replace(cleaned, "<b>", "");
    cleaned = call str.replace(cleaned, "</b>", "");
    cleaned = call str.replace(cleaned, "<code>", "");
    cleaned = call str.replace(cleaned, "</code>", "");
    cleaned = call str.replace(cleaned, "<i>", "");
    cleaned = call str.replace(cleaned, "</i>", "");
    return cleaned;
}

// Function to get keyword help from JSON
getKeywordHelp(keyword: string) return string {
    if helpData == null then {
        return "";
    }
    
    var keywords: json = call json.get(helpData, "keywords");
    if keywords == null then {
        return "";
    }
    
    foreach kw in keywords {
        var kwName: string = call json.getString(kw, "keyword", "");
        if kwName == keyword then {
            var desc: string = call json.getString(kw, "short_description", "");
            var longHelp: string = call json.getString(kw, "long_help", "");
            var example: string = call json.getString(kw, "example", "");
            var format: string = call json.getString(kw, "format", "text");
            
            var content: string = "";
            content = content + "KEYWORD: " + keyword + "\n";
            content = content + "───────────────────────────────────────────────────────\n\n";
            
            if desc != "" then {
                content = content + "DESCRIPTION:\n";
                content = content + desc + "\n\n";
            }
            
            if longHelp != "" then {
                content = content + "DETAILS:\n";
                // Process content based on format
                if format == "html" then {
                    // Remove HTML tags for textarea display
                    var cleanHelp: string = call stripHtmlTags(longHelp);
                    content = content + cleanHelp + "\n\n";
                } else {
                    // Plain text, use as-is
                    content = content + longHelp + "\n\n";
                }
            }
            
            if example != "" then {
                content = content + "EXAMPLE:\n";
                // Process example based on format
                if format == "html" then {
                    var cleanExample: string = call stripHtmlTags(example);
                    content = content + cleanExample + "\n";
                } else {
                    content = content + example + "\n";
                }
            }
            
            return content;
        }
    }
    
    return "";
}

// Function to get topic content from JSON
getTopicFromJson(topicKey: string) return string {
    if helpData == null then {
        return "";
    }
    
    var topics: json = call json.get(helpData, "topics");
    if topics == null then {
        return "";
    }
    
    var topic: json = call json.get(topics, topicKey);
    if topic == null then {
        return "";
    }
    
    var title: string = call json.getString(topic, "title", "");
    var content: string = call json.getString(topic, "content", "");
    
    if title == "" && content == "" then {
        return "";
    }
    
    var result: string = "";
    if title != "" then {
        result = "═══════════════════════════════════════════════════════\n";
        result = result + "  " + title + "\n";
        result = result + "═══════════════════════════════════════════════════════\n\n";
    }
    
    if content != "" then {
        result = result + content;
    }
    
    return result;
}

// Function to get builtin help from system registry
getBuiltinHelp(builtinName: string) return string {
    if builtinsArray == null then {
        return "Builtins data not available.";
    }
    
    // First try to get detailed help from system.help(keyword)
    var detailedHelp: string = call system.help(builtinName);
    if detailedHelp != "" && !call str.contains(detailedHelp, "No help found") then {
        return detailedHelp;
    }
    
    // Fall back to signature from parsed help data
    foreach builtin in builtinsArray {
        var name: string = call json.getString(builtin, "name", "");
        if name == builtinName then {
            var signature: string = call json.getString(builtin, "signature", "");
            
            var content: string = "";
            content = content + "═══════════════════════════════════════════════════════\n";
            content = content + "  " + name + "\n";
            content = content + "═══════════════════════════════════════════════════════\n\n";
            
            content = content + "▸ SIGNATURE\n";
            content = content + "───────────────────────────────────────────────────────\n";
            content = content + "call " + signature + "\n";
            content = content + "\n";
            
            // Try to get additional help from JSON lookup
            if helpData != null then {
                var builtinsJsonArray: json = call json.get(helpData, "builtins");
                if builtinsJsonArray != null then {
                    foreach builtinJson in builtinsJsonArray {
                        var funcName: string = call json.getString(builtinJson, "function", "");
                        if funcName == builtinName then {
                            var shortDesc: string = call json.getString(builtinJson, "short_description", "");
                            var longHelp: string = call json.getString(builtinJson, "long_help", "");
                            var example: string = call json.getString(builtinJson, "example", "");
                            var format: string = call json.getString(builtinJson, "format", "text");
                            
                            if shortDesc != "" then {
                                content = content + "▸ DESCRIPTION\n";
                                content = content + "───────────────────────────────────────────────────────\n";
                                content = content + shortDesc + "\n\n";
                            }
                            
                            if longHelp != "" then {
                                content = content + "▸ DETAILS\n";
                                content = content + "───────────────────────────────────────────────────────\n";
                                if format == "html" then {
                                    var cleanHelp: string = call stripHtmlTags(longHelp);
                                    content = content + cleanHelp + "\n\n";
                                } else {
                                    content = content + longHelp + "\n\n";
                                }
                            }
                            
                            if example != "" then {
                                content = content + "▸ EXAMPLE\n";
                                content = content + "───────────────────────────────────────────────────────\n";
                                if format == "html" then {
                                    var cleanExample: string = call stripHtmlTags(example);
                                    content = content + cleanExample + "\n";
                                } else {
                                    content = content + example + "\n";
                                }
                            }
                        }
                    }
                }
            }
            
            return content;
        }
    }
    
    return "No help found for builtin: " + builtinName;
}

// Function to get help content based on selected topic
getHelpContent(topic: string) return string {
    var content: string = "";
    
    // Check if this is a builtin function name (contains a dot like "str.trim")
    // Valid builtin names have at least one char before the dot (e.g., "str.trim", "array.add")
    // Note: Other help topics use underscores (e.g., "structure_basic"), so dot detection is safe
    var dotIndex: int = call str.indexOf(topic, ".", 0);
    if dotIndex > 0 then {
        // This is a builtin function
        return call getBuiltinHelp(topic);
    }
    
    // Check if this topic matches a category display name
    if builtinCategoryNames != null && builtinCategoryOrder != null then {
        // Iterate through category names to find a match
        foreach categoryKey in builtinCategoryOrder {
            var displayName: string = call json.getString(builtinCategoryNames, categoryKey, "");
            if displayName == topic then {
                // Found matching category - show overview
                var categoryArray: json = call json.get(builtinsByCategory, categoryKey);
                
                content = "═══════════════════════════════════════════════════════\n";
                content = content + "  " + displayName + "\n";
                content = content + "═══════════════════════════════════════════════════════\n\n";
                content = content + "This category contains builtin functions.\n\n";
                content = content + "Select a function from the tree to view its documentation.\n\n";
                
                // List functions in this category
                if categoryArray != null then {
                    content = content + "▸ FUNCTIONS IN THIS CATEGORY\n";
                    content = content + "───────────────────────────────────────────────────────\n";
                    foreach funcNode in categoryArray {
                        var funcValue: string = call json.getString(funcNode, "value", "");
                        content = content + "  • " + funcValue + "\n";
                    }
                }
                
                return content;
            }
        }
    }
    
    // Map flow display names to topic keys
    if topic == "Conditionals" then {
        topic = "flow_conditionals";
    }
    if topic == "Loops" then {
        topic = "flow_loops";
    }
    if topic == "Break and Continue" then {
        topic = "flow_break_continue";
    }
    if topic == "Exception Handling" then {
        topic = "flow_exceptions";
    }
    
    // Handle example topic aliases (Keywords/examples_keywords, etc.)
    if topic == "examples_keywords" then {
        topic = "Keywords";
    }
    if topic == "examples_builtins" then {
        topic = "Builtins";
    }
    if topic == "examples_screen" then {
        topic = "Screen";
    }
    
    // Get all content from JSON
    var jsonContent: string = call getTopicFromJson(topic);
    if jsonContent != "" then {
        return jsonContent;
    }
    
    // If no specific topic found, return default content
    var defaultContent: string = call getTopicFromJson("default");
    if defaultContent != "" then {
        return defaultContent;
    }
    
    // Ultimate fallback if JSON fails
    content = "=== EBS Help ===\n\n";
    content = content + "Select a topic from the tree to view help documentation.\n";
    return content;
}

// Create the help screen from the modified JSON
screen helpScreen = screenJson;

// Set initial content by setting the screen variable (not scr.setProperty)
// The WebView is bound to helpContent variable, so we set that instead
helpScreen.helpContent = call convertToHtml(call getHelpContent(""));

// Show the screen
show screen helpScreen;

