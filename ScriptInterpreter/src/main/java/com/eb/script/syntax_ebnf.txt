
ScriptInterpreter Language – Syntax (EBNF-ish)
=============================================
This grammar is reconstructed from Parser.java / Token.java in the attached project.

LEXICAL
-------
keywords   = "var" | "print" | "call" | "return" | "if" | "then" | "else" | "while" | "do" | "break" | "exit" | "continue" 
           | "null" | "true" | "false" 
           | "import" | "foreach" | "in"
           | "try" | "exceptions" | "when"
           | "connect" | "use" | "cursor" | "open" | "close" | "connection"
           | "select" | "from" | "where" | "order" | "by" | "group" | "having"
           | "screen" | "show" | "hide"
           | "length" | "size" 
           | "typeof" ;                  (* typeof operator for runtime type inspection *)
datatypes  = "byte" | "int" | "integer" | "long" | "float" | "double" | "string" | "date" | "bool" | "boolean" | "json" | "record" ;
operators  = "+" | "-" | "*" | "/" | "^" | "=" | "!" | ">" | "<" | ">=" | "<=" | "==" | "!=" 
           | "and" | "or" | "&&" | "||" 
           | "=>" | "=<" ;
separators = ":" | "," | "." | ";" | "(" | ")" | "[" | "]" | "{" | "}" ;
identifier = letter ( letter | digit | "_" )* ;

PROGRAM
-------
program      = statement* ;

STATEMENTS
----------
statement    = varDecl
             | ifStmt
             | whileStmt
             | doWhileStmt
             | breakStmt
             | continueStmt
             | tryStmt
             | raiseStmt
             | block
             | namedBlock                  (*  name { ... }                     *)
             | namedBlockWithReturn        (*  name return Type { ... }         *)
             | namedBlockWithParams        (*  name (paramDefList?) [return T] { ... }  *)
             | callStmt
             | returnStmt
             | printStmt
             | assignmentStmt
             | screenStmt                  (*  screen <name> = {...};           *)
             | showScreenStmt              (*  show screen <name> [(...)] ;     *)
             | hideScreenStmt              (*  hide screen <name>;              *)
             | comment                     (*  // ...  — ignored by parser      *)
             ;

block        = "{" blockStatement* "}" ;
blockStatement = statement ;                    (* unrestricted; nests blocks   *)

namedBlock   = identifier "{" blockStatement* "}" ;

namedBlockWithReturn
             = identifier "return" typeName "{" blockStatement* "}" ;

namedBlockWithParams
             = identifier "(" paramDefList? ")" ("return" typeName)? "{" blockStatement* "}" ;

paramDefList = paramDef ( "," paramDef )* ;
paramDef     = identifier ":" typeName ("=" expression)? ;

callStmt     = "call" qualifiedName ( "(" callArgList? ")" )? ";" ;
returnStmt   = "return" expression ";" ;
printStmt    = "print"  expression ";" ;
breakStmt    = ("break"|"exit") ";" ;
continueStmt = "continue" ";" ;

assignmentStmt
             = lvalue "=" expression ";" ;

lvalue       = identifier ( indexSuffix )* ;
indexSuffix  = "[" indexList? "]" ;
indexList    = expression ( "," expression )* ;

CONTROL FLOW
------------
ifStmt       = "if" ( "(" expression ")" | expression "then" ) thenBranch elsePart? ;
thenBranch   = block | statement ;
elsePart     = "else" ( ifStmt | block | statement ) ;

whileStmt    = "while" ( "(" expression ")" | expression ["then"] ) block ;

doWhileStmt  = "do" block "while" "(" expression ")" ";" ;

EXCEPTION HANDLING
------------------
tryStmt      = "try" block "exceptions" "{" exceptionHandler+ "}" ;
exceptionHandler
             = "when" ( errorType | customExceptionName ) [ "(" identifier ")" ] block ;

(* Raise exceptions explicitly *)
raiseStmt    = "raise" "exception" exceptionName "(" argumentList? ")" ";" ;

(* Exception handlers can also be attached directly to named blocks and functions *)
namedBlockWithExceptions
             = identifier [ "(" paramDefList? ")" ] [ "return" typeName ] block 
               "exceptions" "{" exceptionHandler+ "}" ;

(* 
   Error types that can be caught:
   - ANY_ERROR      : Catches any error (catch-all handler, should be last)
   - IO_ERROR       : File I/O operations, streams, paths
   - DB_ERROR       : Database connection and query errors
   - TYPE_ERROR     : Type conversion and casting errors
   - NULL_ERROR     : Null pointer or null value errors
   - INDEX_ERROR    : Array index out of bounds errors
   - MATH_ERROR     : Division by zero, arithmetic errors
   - PARSE_ERROR    : JSON parsing, date parsing errors
   - NETWORK_ERROR  : HTTP and network connection errors
   - NOT_FOUND_ERROR: Variable or function not found errors
   - ACCESS_ERROR   : Permission or access denied errors
   - VALIDATION_ERROR: Validation errors
   
   Raising Exceptions:
   
   Standard exceptions only accept a single message parameter:
   
   raise exception IO_ERROR("File not found");
   raise exception MATH_ERROR("Invalid calculation");
   raise exception VALIDATION_ERROR("Input must be positive");
   
   Custom exceptions can be declared with multiple parameters:
   
   raise exception MyCustomError("error message", 42, true);
   raise exception ValidationFailed("field1", "must be numeric");
   
   Examples:
   
   // Raising a standard exception
   validateInput(value: int) {
       if (value < 0) {
           raise exception VALIDATION_ERROR("Value must be non-negative");
       }
   }
   
   // Raising a custom exception with multiple parameters
   checkBounds(index: int, min: int, max: int) {
       if (index < min or index > max) {
           raise exception OutOfBoundsError(index, min, max);
       }
   }
   
   // Catching raised exceptions
   try {
       checkBounds(10, 0, 5);
   } exceptions {
       when OutOfBoundsError(msg) {
           print "Bounds error: " + msg;
       }
   }
   
   // Using try-exceptions syntax
   try {
       var result = 10 / 0;  // Will throw MATH_ERROR
   } exceptions {
       when MATH_ERROR {
           print "Cannot divide by zero!";
       }
       when ANY_ERROR {
           print "An unexpected error occurred";
       }
   }
   
   // Exception handling with error message capture
   try {
       var data = #file.read("missing.txt");
   } exceptions {
       when IO_ERROR(msg) {
           print "File error: " + msg;
       }
   }
   
   // Function with exceptions (no try keyword needed)
   divide(a:int, b:int) return int {
       return a / b;
   } exceptions {
       when MATH_ERROR {
           print "Division error!";
       }
   }
   
   // Named block with exceptions
   riskyOperation {
       var data = #file.read("file.txt");
   } exceptions {
       when IO_ERROR(msg) {
           print "Error: " + msg;
       }
       when ANY_ERROR {
           print "Something went wrong";
       }
   }
*)

DECLARATIONS
------------
varDecl      = "var" identifier ( ":" typeName ( arrayDims )? )? ( "=" varInitializer )? ";" ;

arrayDims    = "[" ( "*" | ( expression ( "," expression )* ) )? "]" ;

varInitializer
             = ( arrayLiteral | expression )
               (* JSON special-case: if typeName is json and initializer starts with '{' or '[',
                  the parser slices the exact text segment and feeds it to Json.parse(). *)
             ;

qualifiedName = identifier ( "." identifier )* ;

typeName     = datatypes | identifier ;       (* allows user-defined aliasing via Token map *)

PARAMETER PASSING
-----------------
callArgList  = callArg ( "," callArg )* ;
callArg      = ( identifier "=" )? expression ;   (* supports named and positional parameters *)

ARRAYS & MEMBERS
----------------
arrayLiteral = ( "[" | "{" ) ( ( arrayLiteral | expression ) ( "," ( arrayLiteral | expression ) )* )? ( "]" | "}" ) ;
postfix      = primary ( indexSuffix )* ( "." "length" )* ;

EXPRESSIONS
-----------
expression   = logicalOr ;
logicalOr    = logicalAnd ( "or"  logicalAnd )* ;
logicalAnd   = relation  ( "and" relation  )* ;

(* In the published Parser.java, the method that handles comparison operators is stubbed/commented.
   The intended shape is shown below; actual behavior may accept fewer operators in this snapshot. *)

relation     = addition ( ( "==" | "!=" | ">" | ">=" | "<" | "<=" ) addition )? ;
addition     = multiplication ( ( "+" | "-" ) multiplication )* ;
multiplication = unary ( ( "*" | "/" ) unary )* ;
unary        = ( "+" | "-" | "!" | "typeof" ) unary | exponentiation ;
exponentiation = postfix ( "^" exponentiation )? ;   (* right-associative *)
primary      = literal
             | identifier
             | "(" expression ")"
             | callAsExpression
             | arrayLiteral
             | castExpression         (* type casting: type(expression) *)
             ;

castExpression
             = datatypes "(" expression ")" ;
             (* Examples: int("42"), string(123), record(jsonData) *)

callAsExpression
             = "call" qualifiedName ( "(" callArgList? ")" )? ;
callAsExpression
             = "#"qualifiedName ( "(" callArgList? ")" )? ;


(* SQL statements *)
sqlStatement    ::= connectStmt
                  | cursorStmt
                  | selectStmt ";" ;

(* Cursor must have a name and must use assignment to a SELECT *)
cursorStmt      ::= "cursor" identifier "=" selectStmt ";" ;


openCursorStmt  ::= "open"  identifier "(" openArgList? ")" ";" ;
closeCursorStmt ::= "close" identifier ";" ;

(* Connection spec left flexible *)

useConnBlock  ::= "use" identifier "{" statement* "}" ;
connectStmt       ::= "connect" identifier "=" connectionSpec ";" ;
closeConnStmt     ::= "close" "connection" identifier ";" ;
(* Connection spec you pass to the runtime:
   - a plain connection string (e.g., DSN/JDBC URL),
   - a JSON object with options,
   - or an existing identifier (e.g., a var holding JSON). *)
connectionSpec    ::= stringLiteral
                    | jsonLiteral
                    | identifier ;

(* Where it appears among other statements *)
statement         ::= ... | connectStmt | cursorStmt | openCursorStmt | closeCursorStmt | ... ;

(* SELECT core *)
selectBody        ::= selectList
                      "from" tableRefList
                      [ whereClause ]
                      [ groupByClause [ havingClause ] ]
                      [ orderByClause ] ;

selectList        ::= "*" | projection { "," projection } ;
projection        ::= valueExpr [ alias ] ;
alias             ::= ( "as" identifier ) | identifier ;  (* 'as' is parsed as an identifier *)

tableRefList      ::= tableRef { "," tableRef } ;
tableRef          ::= identifier [ alias ] ;

whereClause       ::= "where" booleanExpr ;

groupByClause     ::= "group" "by" groupList ;
groupList         ::= valueExpr { "," valueExpr } ;

havingClause      ::= "having" booleanExpr ;

orderByClause     ::= "order" "by" orderSpec { "," orderSpec } ;
orderSpec         ::= valueExpr [ orderDirection ] ;
orderDirection    ::= "asc" | "desc" ;     (* these are identifiers in your lexer *)

(* Expressions inside SELECT:
   You can either:
   - (A) parse a minimal expression subset here, or
   - (B) re-use/call your existing host language expression parser if appropriate, or
   - (C) accept them as raw SQL tokens until clause boundaries.

   Below we leave them abstract so you can plug in your chosen strategy. *)
valueExpr       ::= /* implementation-defined expression */
booleanExpr     ::= /* implementation-defined boolean expression */

(* Lexical atoms from your language/lexer *)
identifier      ::= /* your IDENTIFIER token */;
stringLiteral   ::= /* your STRING token */;
numericLiteral  ::= /* INTEGER | LONG | FLOAT | DOUBLE */;
jsonLiteral     ::= /* as in your language (Map/List/etc.) */;


literal      = integer | long | float | double | string | date | boolean | null ;

(* Properties *)
lengthExpr   = postfix "." "length" ;   (* already captured in postfix above *)

SCREEN STATEMENTS
-----------------
(* Screen definitions allow creating JavaFX windows with UI controls *)

screenStmt       = "screen" identifier "=" screenSpec ";" ;
                   (* Define a screen with configuration *)
                   (* Example: screen myScreen = { title: "My Screen", width: 800, height: 600 }; *)

showScreenStmt   = "show" "screen" identifier ( "(" expressionList? ")" )? ";" ;
                   (* Show a defined screen, optionally with parameters *)
                   (* Examples:
                      show screen myScreen;
                      show screen myScreen(x, y);
                      show screen myScreen(800, 600, "fullscreen");
                   *)

hideScreenStmt   = "hide" "screen" identifier ";" ;
                   (* Hide a visible screen *)
                   (* Example: hide screen myScreen; *)

screenSpec       = jsonLiteral | identifier ;
                   (* Screen configuration as JSON or reference to a variable *)
                   (* JSON format:
                      {
                        title: "Window Title",
                        width: 800,
                        height: 600,
                        maximize: false,
                        singleton: true,
                        vars: [...],
                        area: [...]
                      }
                   *)

expressionList   = expression ( "," expression )* ;
                   (* List of expressions for parameters *)

SCREEN CONFIGURATION
--------------------
(* Screen JSON specification supports the following properties:
   - title: string            - Window title (default: "Screen <name>")
   - width: number            - Window width in pixels (default: 800)
   - height: number           - Window height in pixels (default: 600)
   - maximize: boolean        - Start maximized (default: false)
   - singleton: boolean       - Reuse same window instance (default: true)
   - vars: array              - Variable definitions with display metadata
   - sets: array              - Variable sets for organizing variables
   - area: array              - Layout area definitions with items

   Example:
   screen myForm = {
     title: "User Form",
     width: 600,
     height: 400,
     vars: [
       { name: "username", type: "string", display: { type: "textfield", labelText: "Username" } },
       { name: "age", type: "int", display: { type: "spinner", min: 0, max: 120 } }
     ],
     area: [
       { name: "main", type: "vbox", items: [ ... ] }
     ]
   };

   show screen myForm;
   hide screen myForm;
*)

AREA DEFINITION PROPERTIES
--------------------------
(* Area definitions support the following properties:
   - name: string             - Required. Unique identifier for the area
   - type: string             - Container type (vbox, hbox, gridpane, flowpane, etc.)
   - layout: string           - Layout configuration (e.g., 'fill' to maximize space)
   - style: string            - JavaFX CSS style string
   - spacing: string          - Spacing between child elements (e.g., '10', '15')
   - padding: string          - Padding inside the area (e.g., '10', '10 5 10 5')
   - items: array             - UI items/controls within this area
   - areas: array             - Nested child areas for hierarchical layouts
   - numberOfRecords: number  - For multi-record expansion (see below)
   - recordRef: string        - Array variable reference for multi-record expansion
*)

MULTI-RECORD AREA EXPANSION
---------------------------
(* Areas can automatically expand template items for array-backed data using:
   - numberOfRecords: number  - Number of records to generate (e.g., 3)
   - recordRef: string        - Array variable name (e.g., "clients")
   
   When both are set, each item in the area is duplicated N times:
   - varRef is expanded: "age" becomes "clients[0].age", "clients[1].age", etc.
   - labelText is expanded: "Client - Name:" becomes "Client 1 - Name:", "Client 2 - Name:", etc.
   - item names are made unique: "fieldName" becomes "fieldName_0", "fieldName_1", etc.
   
   Example:
   screen clientForm = {
     vars: [
       { name: "clients", type: "array.record", default: { name: "", age: 0 } }
     ],
     area: [
       {
         name: "clientsArea",
         type: "vbox",
         numberOfRecords: 3,
         recordRef: "clients",
         items: [
           {
             name: "clientNameField",
             varRef: "name",
             display: { type: "textfield", labelText: "Client - Name:" }
           },
           {
             name: "clientAgeField", 
             varRef: "age",
             display: { type: "spinner", labelText: "Client - Age:" }
           }
         ]
       }
     ]
   };
   
   This expands to 6 items total (2 items × 3 records):
   - clients[0].name with label "Client 1 - Name:"
   - clients[0].age with label "Client 1 - Age:"
   - clients[1].name with label "Client 2 - Name:"
   - clients[1].age with label "Client 2 - Age:"
   - clients[2].name with label "Client 3 - Name:"
   - clients[2].age with label "Client 3 - Age:"
*)

ITEM PROPERTY BUILTINS
----------------------
(* Built-in functions for getting and setting item properties at runtime:

   scr.getProperty(item, property) -> ANY
     Gets a property value from an area item.
     - item: string in format "screenName.itemName"
     - property: property name (case-insensitive)
     
     Example:
       var isVisible = #scr.getProperty("myScreen.clientNameField", "visible");
       var tooltip = #scr.getProperty("myScreen.ageField", "tooltip");

   scr.setProperty(item, property, value) -> BOOL
     Sets a property value on an area item.
     - item: string in format "screenName.itemName"
     - property: property name (case-insensitive)
     - value: value to set
     
     Example:
       #scr.setProperty("myScreen.clientNameField", "visible", false);
       #scr.setProperty("myScreen.ageField", "tooltip", "Enter client age");
       #scr.setProperty("myScreen.nameField", "textColor", "#FF0000");

   Supported Item Properties:
   
   | Property        | Type    | Description                                           |
   |-----------------|---------|-------------------------------------------------------|
   | editable        | boolean | Whether the control can be edited                     |
   | disabled        | boolean | Whether the control is disabled (grayed out)          |
   | visible         | boolean | Whether the control is visible                        |
   | tooltip         | string  | Hover tooltip text                                    |
   | textColor       | string  | Text color (CSS color, e.g., "#FF0000", "red")        |
   | backgroundColor | string  | Background color (CSS color, e.g., "#FFFFFF", "blue") |
   | colSpan         | number  | Column span for GridPane layouts                      |
   | rowSpan         | number  | Row span for GridPane layouts                         |
   | hgrow           | string  | Horizontal grow priority: "ALWAYS", "SOMETIMES", "NEVER" |
   | vgrow           | string  | Vertical grow priority: "ALWAYS", "SOMETIMES", "NEVER"   |
   | margin          | string  | Margin around item (e.g., "10", "10 5", "10 5 10 5")  |
   | padding         | string  | Padding inside item (e.g., "10", "10 5", "10 5 10 5") |
   | prefWidth       | string  | Preferred width (e.g., "200", "50%")                  |
   | prefHeight      | string  | Preferred height (e.g., "100", "30%")                 |
   | minWidth        | string  | Minimum width                                         |
   | minHeight       | string  | Minimum height                                        |
   | maxWidth        | string  | Maximum width                                         |
   | maxHeight       | string  | Maximum height                                        |
   | alignment       | string  | Alignment: "center", "top-left", "bottom-right", etc. |
*)

AREA PROPERTY BUILTINS
----------------------
(* Built-in functions for getting and setting area properties at runtime:

   scr.getAreaProperty(area, property) -> ANY
     Gets a property value from an area definition.
     - area: string in format "screenName.areaName"
     - property: property name (case-insensitive)
      
     Example:
       var numRecords = #scr.getAreaProperty("myScreen.clientsArea", "numberOfRecords");
       var spacing = #scr.getAreaProperty("myScreen.mainArea", "spacing");

   scr.setAreaProperty(area, property, value) -> BOOL
     Sets a property value on an area definition.
     - area: string in format "screenName.areaName"
     - property: property name (case-insensitive)
     - value: value to set
      
     Note: screenName and areaType are read-only properties.
      
     Example:
       #scr.setAreaProperty("myScreen.clientsArea", "numberOfRecords", 5);
       #scr.setAreaProperty("myScreen.mainArea", "spacing", "20");
       #scr.setAreaProperty("myScreen.clientsArea", "recordRef", "employees");

   Supported Area Properties:
   
   | Property           | Type    | R/W | Description                                        |
   |--------------------|---------|-----|----------------------------------------------------|
   | name               | string  | R/W | Area identifier                                    |
   | type               | string  | R/W | Container type (vbox, hbox, gridpane, etc.)        |
   | areaType           | string  | R   | Resolved area type (read-only)                     |
   | cssClass           | string  | R/W | CSS class name                                     |
   | layout             | string  | R/W | Layout configuration (e.g., "fill")                |
   | style              | string  | R/W | JavaFX CSS style string                            |
   | screenName         | string  | R   | Associated screen name (read-only)                 |
   | displayName        | string  | R/W | Display name for UI elements                       |
   | title              | string  | R/W | Title for titled containers                        |
   | groupBorder        | string  | R/W | Border style: none, raised, inset, lowered, line   |
   | groupBorderColor   | string  | R/W | Border color in hex (e.g., "#4a9eff")              |
   | groupLabelText     | string  | R/W | Label text on the group border                     |
   | groupLabelAlignment| string  | R/W | Label alignment: left, center, right               |
   | groupLabelOffset   | string  | R/W | Label position: top, on, bottom                    |
   | spacing            | string  | R/W | Spacing between children (e.g., "10", "15")        |
   | padding            | string  | R/W | Padding inside area (e.g., "10", "10 5 10 5")      |
   | gainFocus          | string  | R/W | Code to execute when focus enters area             |
   | lostFocus          | string  | R/W | Code to execute when focus leaves area             |
   | numberOfRecords    | number  | R/W | Number of records for multi-record expansion       |
   | recordRef          | string  | R/W | Array variable name for multi-record expansion     |
*)

COMMENTS
--------
lineComment  = "//" .* ("\n"|EOF) ;       (* Parser ignores these via the COMMENT token *)

NOTES
-----
• Property access currently recognizes only .length as a special form.
• Indexing supports multi-dimensional forms: a[i], a[i,j], and repeated suffixes a[i][j].
• Named blocks are function-like; built-ins are resolved during a post-parse pass.
• JSON literals for variables of type 'json' are captured verbatim from the source and parsed via Json.parse().
• Operator support in this snapshot:
  – '+' '-' (left-assoc), '*' '/' (intended left-assoc), '^' (right-assoc), '!' unary
  – 'and' 'or' boolean connectives
  – Relational operators are present in tokens but the dedicated method in Parser.java is commented/stubbed.
• Screen statements support JavaFX window creation with declarative UI configuration
• Screen show statements can accept optional parameters for runtime configuration
• Screens can be singleton (reuse same window) or multi-instance (create new windows)

