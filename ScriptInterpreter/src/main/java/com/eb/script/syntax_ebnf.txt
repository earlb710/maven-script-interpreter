
ScriptInterpreter Language – Syntax (EBNF-ish)
=============================================
This grammar is reconstructed from Parser.java / Token.java in the attached project.

LEXICAL
-------
keywords   = "var" | "print" | "call" | "return" | "if" | "then" | "else" | "while" | "do" | "break" | "exit" | "continue" 
           | "null" | "true" | "false" 
           | "import" | "foreach" | "in"
           | "connect" | "use" | "cursor" | "open" | "close" | "connection"
           | "select" | "from" | "where" | "order" | "by" | "group" | "having"
           | "screen" | "show" | "hide"
           | "length" | "size" 
           | "typeof" ;                  (* typeof operator for runtime type inspection *)
datatypes  = "byte" | "int" | "integer" | "long" | "float" | "double" | "string" | "date" | "bool" | "boolean" | "json" | "record" ;
operators  = "+" | "-" | "*" | "/" | "^" | "=" | "!" | ">" | "<" | ">=" | "<=" | "==" | "!=" 
           | "and" | "or" | "&&" | "||" 
           | "=>" | "=<" ;
separators = ":" | "," | "." | ";" | "(" | ")" | "[" | "]" | "{" | "}" ;
identifier = letter ( letter | digit | "_" )* ;

PROGRAM
-------
program      = statement* ;

STATEMENTS
----------
statement    = varDecl
             | ifStmt
             | whileStmt
             | doWhileStmt
             | breakStmt
             | continueStmt
             | block
             | namedBlock                  (*  name { ... }                     *)
             | namedBlockWithReturn        (*  name return Type { ... }         *)
             | namedBlockWithParams        (*  name (paramDefList?) [return T] { ... }  *)
             | callStmt
             | returnStmt
             | printStmt
             | assignmentStmt
             | screenStmt                  (*  screen <name> = {...};           *)
             | showScreenStmt              (*  show screen <name> [(...)] ;     *)
             | hideScreenStmt              (*  hide screen <name>;              *)
             | comment                     (*  // ...  — ignored by parser      *)
             ;

block        = "{" blockStatement* "}" ;
blockStatement = statement ;                    (* unrestricted; nests blocks   *)

namedBlock   = identifier "{" blockStatement* "}" ;

namedBlockWithReturn
             = identifier "return" typeName "{" blockStatement* "}" ;

namedBlockWithParams
             = identifier "(" paramDefList? ")" ("return" typeName)? "{" blockStatement* "}" ;

paramDefList = paramDef ( "," paramDef )* ;
paramDef     = identifier ":" typeName ("=" expression)? ;

callStmt     = "call" qualifiedName ( "(" callArgList? ")" )? ";" ;
returnStmt   = "return" expression ";" ;
printStmt    = "print"  expression ";" ;
breakStmt    = ("break"|"exit") ";" ;
continueStmt = "continue" ";" ;

assignmentStmt
             = lvalue "=" expression ";" ;

lvalue       = identifier ( indexSuffix )* ;
indexSuffix  = "[" indexList? "]" ;
indexList    = expression ( "," expression )* ;

CONTROL FLOW
------------
ifStmt       = "if" ( "(" expression ")" | expression "then" ) thenBranch elsePart? ;
thenBranch   = block | statement ;
elsePart     = "else" ( ifStmt | block | statement ) ;

whileStmt    = "while" ( "(" expression ")" | expression ["then"] ) block ;

doWhileStmt  = "do" block "while" "(" expression ")" ";" ;

DECLARATIONS
------------
varDecl      = "var" identifier ( ":" typeName ( arrayDims )? )? ( "=" varInitializer )? ";" ;

arrayDims    = "[" ( "*" | ( expression ( "," expression )* ) )? "]" ;

varInitializer
             = ( arrayLiteral | expression )
               (* JSON special-case: if typeName is json and initializer starts with '{' or '[',
                  the parser slices the exact text segment and feeds it to Json.parse(). *)
             ;

qualifiedName = identifier ( "." identifier )* ;

typeName     = datatypes | identifier ;       (* allows user-defined aliasing via Token map *)

PARAMETER PASSING
-----------------
callArgList  = callArg ( "," callArg )* ;
callArg      = ( identifier "=" )? expression ;   (* supports named and positional parameters *)

ARRAYS & MEMBERS
----------------
arrayLiteral = ( "[" | "{" ) ( ( arrayLiteral | expression ) ( "," ( arrayLiteral | expression ) )* )? ( "]" | "}" ) ;
postfix      = primary ( indexSuffix )* ( "." "length" )* ;

EXPRESSIONS
-----------
expression   = logicalOr ;
logicalOr    = logicalAnd ( "or"  logicalAnd )* ;
logicalAnd   = relation  ( "and" relation  )* ;

(* In the published Parser.java, the method that handles comparison operators is stubbed/commented.
   The intended shape is shown below; actual behavior may accept fewer operators in this snapshot. *)

relation     = addition ( ( "==" | "!=" | ">" | ">=" | "<" | "<=" ) addition )? ;
addition     = multiplication ( ( "+" | "-" ) multiplication )* ;
multiplication = unary ( ( "*" | "/" ) unary )* ;
unary        = ( "+" | "-" | "!" | "typeof" ) unary | exponentiation ;
exponentiation = postfix ( "^" exponentiation )? ;   (* right-associative *)
primary      = literal
             | identifier
             | "(" expression ")"
             | callAsExpression
             | arrayLiteral
             | castExpression         (* type casting: type(expression) *)
             ;

castExpression
             = datatypes "(" expression ")" ;
             (* Examples: int("42"), string(123), record(jsonData) *)

callAsExpression
             = "call" qualifiedName ( "(" callArgList? ")" )? ;
callAsExpression
             = "#"qualifiedName ( "(" callArgList? ")" )? ;


(* SQL statements *)
sqlStatement    ::= connectStmt
                  | cursorStmt
                  | selectStmt ";" ;

(* Cursor must have a name and must use assignment to a SELECT *)
cursorStmt      ::= "cursor" identifier "=" selectStmt ";" ;


openCursorStmt  ::= "open"  identifier "(" openArgList? ")" ";" ;
closeCursorStmt ::= "close" identifier ";" ;

(* Connection spec left flexible *)

useConnBlock  ::= "use" identifier "{" statement* "}" ;
connectStmt       ::= "connect" identifier "=" connectionSpec ";" ;
closeConnStmt     ::= "close" "connection" identifier ";" ;
(* Connection spec you pass to the runtime:
   - a plain connection string (e.g., DSN/JDBC URL),
   - a JSON object with options,
   - or an existing identifier (e.g., a var holding JSON). *)
connectionSpec    ::= stringLiteral
                    | jsonLiteral
                    | identifier ;

(* Where it appears among other statements *)
statement         ::= ... | connectStmt | cursorStmt | openCursorStmt | closeCursorStmt | ... ;

(* SELECT core *)
selectBody        ::= selectList
                      "from" tableRefList
                      [ whereClause ]
                      [ groupByClause [ havingClause ] ]
                      [ orderByClause ] ;

selectList        ::= "*" | projection { "," projection } ;
projection        ::= valueExpr [ alias ] ;
alias             ::= ( "as" identifier ) | identifier ;  (* 'as' is parsed as an identifier *)

tableRefList      ::= tableRef { "," tableRef } ;
tableRef          ::= identifier [ alias ] ;

whereClause       ::= "where" booleanExpr ;

groupByClause     ::= "group" "by" groupList ;
groupList         ::= valueExpr { "," valueExpr } ;

havingClause      ::= "having" booleanExpr ;

orderByClause     ::= "order" "by" orderSpec { "," orderSpec } ;
orderSpec         ::= valueExpr [ orderDirection ] ;
orderDirection    ::= "asc" | "desc" ;     (* these are identifiers in your lexer *)

(* Expressions inside SELECT:
   You can either:
   - (A) parse a minimal expression subset here, or
   - (B) re-use/call your existing host language expression parser if appropriate, or
   - (C) accept them as raw SQL tokens until clause boundaries.

   Below we leave them abstract so you can plug in your chosen strategy. *)
valueExpr       ::= /* implementation-defined expression */
booleanExpr     ::= /* implementation-defined boolean expression */

(* Lexical atoms from your language/lexer *)
identifier      ::= /* your IDENTIFIER token */;
stringLiteral   ::= /* your STRING token */;
numericLiteral  ::= /* INTEGER | LONG | FLOAT | DOUBLE */;
jsonLiteral     ::= /* as in your language (Map/List/etc.) */;


literal      = integer | long | float | double | string | date | boolean | null ;

(* Properties *)
lengthExpr   = postfix "." "length" ;   (* already captured in postfix above *)

SCREEN STATEMENTS
-----------------
(* Screen definitions allow creating JavaFX windows with UI controls *)

screenStmt       = "screen" identifier "=" screenSpec ";" ;
                   (* Define a screen with configuration *)
                   (* Example: screen myScreen = { title: "My Screen", width: 800, height: 600 }; *)

showScreenStmt   = "show" "screen" identifier ( "(" expressionList? ")" )? ";" ;
                   (* Show a defined screen, optionally with parameters *)
                   (* Examples:
                      show screen myScreen;
                      show screen myScreen(x, y);
                      show screen myScreen(800, 600, "fullscreen");
                   *)

hideScreenStmt   = "hide" "screen" identifier ";" ;
                   (* Hide a visible screen *)
                   (* Example: hide screen myScreen; *)

screenSpec       = jsonLiteral | identifier ;
                   (* Screen configuration as JSON or reference to a variable *)
                   (* JSON format:
                      {
                        title: "Window Title",
                        width: 800,
                        height: 600,
                        maximize: false,
                        singleton: true,
                        vars: [...],
                        area: [...]
                      }
                   *)

expressionList   = expression ( "," expression )* ;
                   (* List of expressions for parameters *)

SCREEN CONFIGURATION
--------------------
(* Screen JSON specification supports the following properties:
   - title: string            - Window title (default: "Screen <name>")
   - width: number            - Window width in pixels (default: 800)
   - height: number           - Window height in pixels (default: 600)
   - maximize: boolean        - Start maximized (default: false)
   - singleton: boolean       - Reuse same window instance (default: true)
   - vars: array              - Variable definitions with display metadata
   - sets: array              - Variable sets for organizing variables
   - area: array              - Layout area definitions with items

   Example:
   screen myForm = {
     title: "User Form",
     width: 600,
     height: 400,
     vars: [
       { name: "username", type: "string", display: { type: "textfield", labelText: "Username" } },
       { name: "age", type: "int", display: { type: "spinner", min: 0, max: 120 } }
     ],
     area: [
       { name: "main", type: "vbox", items: [ ... ] }
     ]
   };

   show screen myForm;
   hide screen myForm;
*)

COMMENTS
--------
lineComment  = "//" .* ("\n"|EOF) ;       (* Parser ignores these via the COMMENT token *)

NOTES
-----
• Property access currently recognizes only .length as a special form.
• Indexing supports multi-dimensional forms: a[i], a[i,j], and repeated suffixes a[i][j].
• Named blocks are function-like; built-ins are resolved during a post-parse pass.
• JSON literals for variables of type 'json' are captured verbatim from the source and parsed via Json.parse().
• Operator support in this snapshot:
  – '+' '-' (left-assoc), '*' '/' (intended left-assoc), '^' (right-assoc), '!' unary
  – 'and' 'or' boolean connectives
  – Relational operators are present in tokens but the dedicated method in Parser.java is commented/stubbed.
• Screen statements support JavaFX window creation with declarative UI configuration
• Screen show statements can accept optional parameters for runtime configuration
• Screens can be singleton (reuse same window) or multi-instance (create new windows)

