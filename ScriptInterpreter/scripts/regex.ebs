// ============================================================================
// regex.ebs - Interactive Regular Expression Tester
// ============================================================================
// This script provides an interactive screen for testing regular expressions.
// Features:
//   - Input field for sample source text (multiline textarea)
//   - Input field for regex pattern
//   - Checkboxes for regex options/flags
//   - Append Results option to accumulate results
//   - Advanced regex filters: OR, AND, NOT pattern matching
//   - Buttons to execute regex operations (find first, find all, replace)
//   - Display area for showing match results
// ============================================================================

print "====================================================================";
print "       Regex Tester - Interactive Regular Expression Tool";
print "====================================================================";
print "";
print "Loading regex tester screen...";
print "";

// Helper function to remove all flag prefixes from a pattern
// Removes patterns like (?i), (?m), (?s), (?ims), (?im), etc.
removeAllFlags(pattern: string) return string {
    var result: string = pattern;
    
    // Remove all flag prefix patterns: (?...) where ... contains only i, m, s
    // We need to handle various combinations like (?i), (?m), (?s), (?im), (?is), (?ms), (?ims)
    while call str.startsWith(result, "(?") {
        var endParen: int = call str.indexOf(result, ")");
        if endParen > 2 then {
            // Check if all chars between (? and ) are valid flags (i, m, s)
            var flagPart: string = call str.substring(result, 2, endParen);
            var isValidFlagBlock: bool = true;
            // Use str.charArray to get the characters as an array, then use .length
            var flagChars = call str.charArray(flagPart);
            var flagLen: int = flagChars.length;
            var j: int = 0;
            while j < flagLen {
                var c: string = call str.charAt(flagPart, j);
                if c != "i" and c != "m" and c != "s" then {
                    isValidFlagBlock = false;
                }
                j = j + 1;
            }
            if isValidFlagBlock then {
                result = call str.substring(result, endParen + 1);
            } else {
                // Not a flag block, stop trying to remove
                break;
            }
        } else {
            break;
        }
    }
    
    return result;
}

// Helper function to build regex pattern with flags
buildRegexPattern(pattern: string, caseInsensitive: bool, multiline: bool, dotAll: bool) return string {
    var flags: string = "";
    
    // Build flag prefix for Java regex
    // (?i) = case insensitive
    // (?m) = multiline (^ and $ match line boundaries)
    // (?s) = dotall (. matches newlines)
    if caseInsensitive or multiline or dotAll then {
        flags = "(?";
        if caseInsensitive then {
            flags = flags + "i";
        }
        if multiline then {
            flags = flags + "m";
        }
        if dotAll then {
            flags = flags + "s";
        }
        flags = flags + ")";
    }
    
    return flags + pattern;
}

// Function to sync the regex pattern field with checkbox states
// This adds/removes flags from the pattern text as checkboxes are toggled
syncPatternWithFlags {
    var currentPattern: string = regexScreen.regexPattern;
    
    // First, remove any existing flags from the pattern
    var cleanPattern: string = call removeAllFlags(currentPattern);
    
    // Now rebuild with current checkbox states
    var newPattern: string = call buildRegexPattern(
        cleanPattern,
        regexScreen.caseInsensitive,
        regexScreen.multilineMode,
        regexScreen.dotAllMode
    );
    
    // Update the pattern field
    regexScreen.regexPattern = newPattern;
}

// Helper function to check if a match satisfies OR filter patterns
// Returns true if match contains ANY of the OR patterns
checkOrFilter(match: string, orPatterns: string) return bool {
    if orPatterns == "" then {
        return true;
    }
    
    var patterns = call str.split(orPatterns, ",");
    var i: int = 0;
    while i < patterns.length {
        var pattern: string = call str.trim(patterns[i]);
        if pattern != "" then {
            // Check for +/* wildcard syntax
            if call str.contains(pattern, "+/*") then {
                // Split by +/* and check if match contains all parts
                var parts = call str.split(pattern, "\\+/\\*");
                var allPartsMatch: bool = true;
                var j: int = 0;
                while j < parts.length {
                    var part: string = call str.trim(parts[j]);
                    if part != "" and not call str.contains(match, part) then {
                        allPartsMatch = false;
                    }
                    j = j + 1;
                }
                if allPartsMatch then {
                    return true;
                }
            } else {
                // Simple contains check
                if call str.contains(match, pattern) then {
                    return true;
                }
            }
        }
        i = i + 1;
    }
    return false;
}

// Helper function to check if a match satisfies AND filter patterns
// Returns true if match contains ALL of the AND patterns
checkAndFilter(match: string, andPatterns: string) return bool {
    if andPatterns == "" then {
        return true;
    }
    
    var patterns = call str.split(andPatterns, ",");
    var i: int = 0;
    while i < patterns.length {
        var pattern: string = call str.trim(patterns[i]);
        if pattern != "" then {
            // Check for +/* wildcard syntax
            if call str.contains(pattern, "+/*") then {
                // Split by +/* and check if match contains all parts
                var parts = call str.split(pattern, "\\+/\\*");
                var j: int = 0;
                while j < parts.length {
                    var part: string = call str.trim(parts[j]);
                    if part != "" and not call str.contains(match, part) then {
                        return false;
                    }
                    j = j + 1;
                }
            } else {
                // Simple contains check
                if not call str.contains(match, pattern) then {
                    return false;
                }
            }
        }
        i = i + 1;
    }
    return true;
}

// Helper function to check if a match satisfies NOT filter patterns
// Returns true if match does NOT contain any of the NOT patterns
checkNotFilter(match: string, notPatterns: string) return bool {
    if notPatterns == "" then {
        return true;
    }
    
    var patterns = call str.split(notPatterns, ",");
    var i: int = 0;
    while i < patterns.length {
        var pattern: string = call str.trim(patterns[i]);
        if pattern != "" then {
            // Check for +/* wildcard syntax
            if call str.contains(pattern, "+/*") then {
                // Split by +/* and check if match contains all parts
                var parts = call str.split(pattern, "\\+/\\*");
                var allPartsMatch: bool = true;
                var j: int = 0;
                while j < parts.length {
                    var part: string = call str.trim(parts[j]);
                    if part != "" and not call str.contains(match, part) then {
                        allPartsMatch = false;
                    }
                    j = j + 1;
                }
                if allPartsMatch then {
                    return false;
                }
            } else {
                // Simple contains check - if pattern is found, exclude the match
                if call str.contains(match, pattern) then {
                    return false;
                }
            }
        }
        i = i + 1;
    }
    return true;
}

// Helper function to apply all filters to a match
// Returns true if the match passes all filters (OR, AND, NOT)
applyFilters(match: string) return bool {
    var orPatterns: string = regexScreen.orPatterns;
    var andPatterns: string = regexScreen.andPatterns;
    var notPatterns: string = regexScreen.notPatterns;
    
    // Check OR filter first (match must satisfy at least one OR pattern)
    if not call checkOrFilter(match, orPatterns) then {
        return false;
    }
    
    // Check AND filter (match must satisfy all AND patterns)
    if not call checkAndFilter(match, andPatterns) then {
        return false;
    }
    
    // Check NOT filter (match must not satisfy any NOT pattern)
    if not call checkNotFilter(match, notPatterns) then {
        return false;
    }
    
    return true;
}

// Function to perform find first match
performFindFirst {
    var sourceText: string = regexScreen.sourceText;
    var regexPattern: string = regexScreen.regexPattern;
    var appendResults: bool = regexScreen.appendResults;
    
    if regexPattern == "" then {
        regexScreen.resultText = "Error: Please enter a regex pattern";
        return;
    }
    
    // Build result header
    var resultHeader: string = "Finding first match...\n";
    resultHeader = resultHeader + "Pattern: " + regexPattern + "\n";
    
    // Show active filters
    if regexScreen.orPatterns != "" then {
        resultHeader = resultHeader + "OR Filter: " + regexScreen.orPatterns + "\n";
    }
    if regexScreen.andPatterns != "" then {
        resultHeader = resultHeader + "AND Filter: " + regexScreen.andPatterns + "\n";
    }
    if regexScreen.notPatterns != "" then {
        resultHeader = resultHeader + "NOT Filter: " + regexScreen.notPatterns + "\n";
    }
    resultHeader = resultHeader + "\n";
    
    // Set or append result header
    if appendResults then {
        regexScreen.resultText = regexScreen.resultText + "\n--- New Search ---\n" + resultHeader;
    } else {
        regexScreen.resultText = resultHeader;
    }
    
    try {
        var match: string = call str.findRegex(sourceText, regexPattern);
        
        if match == null then {
            regexScreen.resultText = regexScreen.resultText + "No match found.";
        } else {
            // Apply filters to the match
            if call applyFilters(match) then {
                regexScreen.resultText = regexScreen.resultText + "Match found:\n'" + match + "'";
            } else {
                regexScreen.resultText = regexScreen.resultText + "Match found but filtered out by OR/AND/NOT filters.";
            }
        }
    } exceptions {
        when ANY_ERROR(msg) {
            regexScreen.resultText = regexScreen.resultText + "Error: " + msg;
        }
    }
}

// Function to perform find all matches
performFindAll {
    var sourceText: string = regexScreen.sourceText;
    var regexPattern: string = regexScreen.regexPattern;
    var appendResults: bool = regexScreen.appendResults;
    
    if regexPattern == "" then {
        regexScreen.resultText = "Error: Please enter a regex pattern";
        return;
    }
    
    // Build result header
    var resultHeader: string = "Finding all matches...\n";
    resultHeader = resultHeader + "Pattern: " + regexPattern + "\n";
    
    // Show active filters
    if regexScreen.orPatterns != "" then {
        resultHeader = resultHeader + "OR Filter: " + regexScreen.orPatterns + "\n";
    }
    if regexScreen.andPatterns != "" then {
        resultHeader = resultHeader + "AND Filter: " + regexScreen.andPatterns + "\n";
    }
    if regexScreen.notPatterns != "" then {
        resultHeader = resultHeader + "NOT Filter: " + regexScreen.notPatterns + "\n";
    }
    resultHeader = resultHeader + "\n";
    
    // Set or append result header
    if appendResults then {
        regexScreen.resultText = regexScreen.resultText + "\n--- New Search ---\n" + resultHeader;
    } else {
        regexScreen.resultText = resultHeader;
    }
    
    try {
        var matches = call str.findAllRegex(sourceText, regexPattern);
        
        if matches.length == 0 then {
            regexScreen.resultText = regexScreen.resultText + "No matches found.";
        } else {
            // Apply filters and count filtered results
            var filteredCount: int = 0;
            var filteredResults: string = "";
            var totalCount: int = 0;
            
            foreach match in matches {
                totalCount = totalCount + 1;
                if call applyFilters(match) then {
                    filteredCount = filteredCount + 1;
                    filteredResults = filteredResults + "[" + filteredCount + "] '" + match + "'\n";
                }
            }
            
            if filteredCount == 0 then {
                regexScreen.resultText = regexScreen.resultText + "Found " + totalCount + " match(es), but all were filtered out by OR/AND/NOT filters.";
            } else {
                regexScreen.resultText = regexScreen.resultText + "Found " + filteredCount + " match(es) after filtering (from " + totalCount + " total):\n\n";
                regexScreen.resultText = regexScreen.resultText + filteredResults;
            }
        }
    } exceptions {
        when ANY_ERROR(msg) {
            regexScreen.resultText = regexScreen.resultText + "Error: " + msg;
        }
    }
}

// Function to perform replace all
performReplaceAll {
    var sourceText: string = regexScreen.sourceText;
    var regexPattern: string = regexScreen.regexPattern;
    var replacementText: string = regexScreen.replacementText;
    var appendResults: bool = regexScreen.appendResults;
    
    if regexPattern == "" then {
        regexScreen.resultText = "Error: Please enter a regex pattern";
        return;
    }
    
    // Build result header
    var resultHeader: string = "Replacing matches...\n";
    resultHeader = resultHeader + "Pattern: " + regexPattern + "\n";
    resultHeader = resultHeader + "Replacement: '" + replacementText + "'\n\n";
    
    // Set or append result header
    if appendResults then {
        regexScreen.resultText = regexScreen.resultText + "\n--- New Replace ---\n" + resultHeader;
    } else {
        regexScreen.resultText = resultHeader;
    }
    
    try {
        var result: string = call str.replaceAll(sourceText, regexPattern, replacementText);
        regexScreen.resultText = regexScreen.resultText + "Result:\n" + result;
    } exceptions {
        when ANY_ERROR(msg) {
            regexScreen.resultText = regexScreen.resultText + "Error: " + msg;
        }
    }
}

// Function to perform replace first only (literal string matching - not regex)
performReplaceLiteral {
    var sourceText: string = regexScreen.sourceText;
    var searchText: string = regexScreen.regexPattern;
    var replacementText: string = regexScreen.replacementText;
    var appendResults: bool = regexScreen.appendResults;
    
    if searchText == "" then {
        regexScreen.resultText = "Error: Please enter text to search for";
        return;
    }
    
    // Note: This uses literal string matching (not regex)
    // Useful when you want to find/replace exact text without regex interpretation
    
    var resultHeader: string = "Replace First (LITERAL text match - not regex)...\n";
    resultHeader = resultHeader + "Search for: '" + searchText + "'\n";
    resultHeader = resultHeader + "Replace with: '" + replacementText + "'\n\n";
    resultHeader = resultHeader + "Note: This treats the pattern as literal text, not a regex.\n";
    resultHeader = resultHeader + "Special characters like . * + are matched literally.\n\n";
    
    // Set or append result header
    if appendResults then {
        regexScreen.resultText = regexScreen.resultText + "\n--- New Replace ---\n" + resultHeader;
    } else {
        regexScreen.resultText = resultHeader;
    }
    
    try {
        var result: string = call str.replaceFirst(sourceText, searchText, replacementText);
        regexScreen.resultText = regexScreen.resultText + "Result:\n" + result;
    } exceptions {
        when ANY_ERROR(msg) {
            regexScreen.resultText = regexScreen.resultText + "Error: " + msg;
        }
    }
}

// Function to clear all fields
clearFields {
    regexScreen.sourceText = "";
    regexScreen.regexPattern = "";
    regexScreen.replacementText = "";
    regexScreen.resultText = "";
    regexScreen.caseInsensitive = false;
    regexScreen.multilineMode = false;
    regexScreen.dotAllMode = false;
    regexScreen.appendResults = false;
    regexScreen.orPatterns = "";
    regexScreen.andPatterns = "";
    regexScreen.notPatterns = "";
}

// Function to load sample data
loadSampleData {
    regexScreen.sourceText = "Hello World!\nThis is a test.\nEmail: user@example.com\nPhone: 123-456-7890\nAnother email: admin@test.org\nDate: 2024-12-25\nThe quick brown fox jumps over the lazy dog.\nHELLO again!";
    regexScreen.regexPattern = "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}";
    regexScreen.resultText = "Sample data loaded!\n\nTry clicking 'Find All' to find email addresses,\nor modify the regex pattern to test other patterns.\n\nSample patterns to try:\n- \\d+ (find numbers)\n- \\w+ (find words)\n- [A-Z][a-z]+ (find capitalized words)\n- \\d{4}-\\d{2}-\\d{2} (find dates like YYYY-MM-DD)\n\nFilter Examples:\n- OR Filter: 'user, admin' - matches containing 'user' OR 'admin'\n- AND Filter: 'example' - matches must contain 'example'\n- NOT Filter: 'test' - exclude matches containing 'test'\n- Wildcard: 'user+/*com' - matches containing both 'user' AND 'com'";
}

// Create the regex tester screen
screen regexScreen = {
    "title": "Regex Tester - Interactive Regular Expression Tool",
    "width": 850,
    "height": 1000,
    "vars": [
        {
            "name": "sourceText",
            "type": "string",
            "default": "",
            "display": {
                "type": "textarea",
                "labelText": "Source Text:",
                "promptHelp": "Enter text to search/match against",
                "maxLength": 80
            }
        },
        {
            "name": "regexPattern",
            "type": "string",
            "default": "",
            "display": {
                "type": "textfield",
                "labelText": "Regex Pattern:",
                "promptHelp": "Enter your regular expression pattern",
                "maxLength": 60
            }
        },
        {
            "name": "replacementText",
            "type": "string",
            "default": "",
            "display": {
                "type": "textfield",
                "labelText": "Replacement:",
                "promptHelp": "Replacement text for replace operations",
                "maxLength": 60
            }
        },
        {
            "name": "caseInsensitive",
            "type": "bool",
            "default": false,
            "display": {
                "type": "checkbox",
                "labelText": "Case Insensitive (?i)",
                "onChange": "call syncPatternWithFlags();"
            }
        },
        {
            "name": "multilineMode",
            "type": "bool",
            "default": false,
            "display": {
                "type": "checkbox",
                "labelText": "Multiline Mode (?m) - ^ and $ match line boundaries",
                "onChange": "call syncPatternWithFlags();"
            }
        },
        {
            "name": "dotAllMode",
            "type": "bool",
            "default": false,
            "display": {
                "type": "checkbox",
                "labelText": "Dot All Mode (?s) - . matches newlines",
                "onChange": "call syncPatternWithFlags();"
            }
        },
        {
            "name": "appendResults",
            "type": "bool",
            "default": false,
            "display": {
                "type": "checkbox",
                "labelText": "Append Results (accumulate output instead of replacing)"
            }
        },
        {
            "name": "orPatterns",
            "type": "string",
            "default": "",
            "display": {
                "type": "textfield",
                "labelText": "OR Filter:",
                "promptHelp": "Comma-separated patterns - match ANY (e.g., user,admin or user+/*com)",
                "maxLength": 60
            }
        },
        {
            "name": "andPatterns",
            "type": "string",
            "default": "",
            "display": {
                "type": "textfield",
                "labelText": "AND Filter:",
                "promptHelp": "Comma-separated patterns - match must contain ALL (e.g., @,example)",
                "maxLength": 60
            }
        },
        {
            "name": "notPatterns",
            "type": "string",
            "default": "",
            "display": {
                "type": "textfield",
                "labelText": "NOT Filter:",
                "promptHelp": "Comma-separated patterns - exclude matches containing ANY (e.g., test,admin)",
                "maxLength": 60
            }
        },
        {
            "name": "resultText",
            "type": "string",
            "default": "Results will appear here...",
            "display": {
                "type": "textarea",
                "labelText": "Results:",
                "editable": false,
                "maxLength": 80
            }
        }
    ],
    "area": [
        {
            "name": "mainArea",
            "type": "vbox",
            "style": "-fx-spacing: 2; -fx-padding: 2;",
            "areas": [
                {
                    "name": "titleArea",
                    "type": "hbox",
                    "style": "-fx-alignment: CENTER;",
                    "items": [
                        {
                            "name": "titleLabel",
                            "display": {
                                "type": "label",
                                "labelText": "Interactive Regular Expression Tester",
                                "itemColor": "#000088",
                                "itemBold": true,
                                "itemUnderline": true,
                                "itemFontSize": "20"
                            }
                        }
                    ]
                },
                {
                    "name": "inputArea",
                    "type": "vbox",
                    "groupBorder": "lowered",
                    "groupBorderColor": "#cccccc",
                    "groupLabelText": "Input",
                    "groupLabelColor": "#444444",
                    "groupLabelOffset": "bottom",
                    "padding": "4",
                    "style": "-fx-spacing: 8; -fx-padding: 10;",
                    "items": [
                        {"name": "sourceTextItem", "varRef": "sourceText"},
                        {"name": "regexPatternItem", "varRef": "regexPattern"},
                        {"name": "replacementItem", "varRef": "replacementText"}
                    ]
                },
                {
                    "name": "optionsArea",
                    "type": "vbox",
                    "groupBorder": "lowered",
                    "groupBorderColor": "#cccccc",
                    "groupLabelText": "Regex Options",
                    "groupLabelOffset": "bottom",
                    "padding": "4",
                    "groupLabelColor": "#444444",
                    "style": "-fx-spacing: 5; -fx-padding: 10;",
                    "items": [
                        {"name": "caseInsensitiveItem", "varRef": "caseInsensitive"},
                        {"name": "multilineModeItem", "varRef": "multilineMode"},
                        {"name": "dotAllModeItem", "varRef": "dotAllMode"},
                        {"name": "appendResultsItem", "varRef": "appendResults"}
                    ]
                },
                {
                    "name": "filtersArea",
                    "type": "vbox",
                    "groupBorder": "lowered",
                    "groupBorderColor": "#cccccc",
                    "groupLabelText": "Match Filters (comma-separated, use +/* for AND within pattern)",
                    "groupLabelOffset": "bottom",
                    "padding": "4",
                    "groupLabelColor": "#444444",
                    "style": "-fx-spacing: 5; -fx-padding: 10;",
                    "items": [
                        {"name": "orPatternsItem", "varRef": "orPatterns"},
                        {"name": "andPatternsItem", "varRef": "andPatterns"},
                        {"name": "notPatternsItem", "varRef": "notPatterns"}
                    ]
                },
                {
                    "name": "buttonArea",
                    "type": "hbox",
                    "style": "-fx-spacing: 10; -fx-alignment: CENTER;",
                    "items": [
                        {
                            "name": "findFirstBtn",
                            "display": {
                                "type": "button",
                                "labelText": "Find First",
                                "tooltip": "Find the first match of the regex pattern",
                                "onClick": "call performFindFirst();"
                            }
                        },
                        {
                            "name": "findAllBtn",
                            "display": {
                                "type": "button",
                                "labelText": "Find All",
                                "tooltip": "Find all matches of the regex pattern",
                                "onClick": "call performFindAll();"
                            }
                        },
                        {
                            "name": "replaceAllBtn",
                            "display": {
                                "type": "button",
                                "labelText": "Replace All",
                                "tooltip": "Replace all matches with replacement text",
                                "onClick": "call performReplaceAll();"
                            }
                        },
                        {
                            "name": "replaceLiteralBtn",
                            "display": {
                                "type": "button",
                                "labelText": "Replace Literal",
                                "tooltip": "Replace first occurrence using LITERAL text match (NOT regex) - special chars are not interpreted",
                                "onClick": "call performReplaceLiteral();"
                            }
                        }
                    ]
                },
                {
                    "name": "utilButtonArea",
                    "type": "hbox",
                    "style": "-fx-spacing: 10; -fx-alignment: CENTER;",
                    "items": [
                        {
                            "name": "loadSampleBtn",
                            "display": {
                                "type": "button",
                                "labelText": "Load Sample Data",
                                "tooltip": "Load example text and pattern",
                                "onClick": "call loadSampleData();"
                            }
                        },
                        {
                            "name": "clearBtn",
                            "display": {
                                "type": "button",
                                "labelText": "Clear All",
                                "tooltip": "Clear all input fields",
                                "onClick": "call clearFields();"
                            }
                        },
                        {
                            "name": "closeBtn",
                            "display": {
                                "type": "button",
                                "labelText": "Close",
                                "tooltip": "Close the regex tester",
                                "onClick": "close screen;"
                            }
                        }
                    ]
                },
                {
                    "name": "resultArea",
                    "type": "vbox",
                    "groupBorder": "lowered",
                    "groupBorderColor": "#cccccc",
                    "groupLabelText": "Output",
                    "groupLabelColor": "#444444",
                    "groupLabelOffset": "bottom",
                    "padding": "4",
                    "style": "-fx-spacing: 5; -fx-padding: 10;",
                    "items": [
                        {"name": "resultTextItem", "varRef": "resultText"}
                    ]
                },
                {
                    "name": "helpArea",
                    "type": "vbox",
                    "style": "-fx-spacing: 2; -fx-padding: 5;",
                    "items": [
                        {
                            "name": "helpLabel1",
                            "display": {
                                "type": "label",
                                "labelText": "Common Patterns: \\d+ (digits), \\w+ (word chars), [A-Za-z]+ (letters), .+ (any chars)"
                            }
                        },
                        {
                            "name": "helpLabel2",
                            "display": {
                                "type": "label",
                                "labelText": "Note: Use \\\\ for backslash in patterns (e.g., \\\\d+ for digits)"
                            }
                        },
                        {
                            "name": "helpLabel3",
                            "display": {
                                "type": "label",
                                "labelText": "Filters: OR=any match, AND=all must match, NOT=exclude. Use +/* for AND within a pattern."
                            }
                        }
                    ]
                }
            ]
        }
    ]
};

// Show the screen
print "Regex Tester screen created successfully!";
print "";
print "Features:";
print "  - Enter source text in the textarea";
print "  - Enter regex pattern to test";
print "  - Use checkboxes to enable regex flags:";
print "    * Case Insensitive (?i) - ignore case";
print "    * Multiline Mode (?m) - ^ and $ match line boundaries";
print "    * Dot All Mode (?s) - . matches newlines";
print "    * Append Results - accumulate output instead of replacing";
print "  - Match Filters (applied after regex matching):";
print "    * OR Filter: comma-separated patterns, match ANY (e.g., user,admin)";
print "    * AND Filter: comma-separated patterns, match must contain ALL";
print "    * NOT Filter: comma-separated patterns, exclude matches containing ANY";
print "    * Use +/* within a pattern for AND logic (e.g., user+/*com)";
print "  - Click 'Find First' to find first match";
print "  - Click 'Find All' to find all matches";
print "  - Click 'Replace All' for regex replacement";
print "  - Click 'Replace Literal' for literal text replacement (not regex)";
print "  - Click 'Load Sample Data' to see examples";
print "";
print "Showing regex tester screen...";
show screen regexScreen;

print "";
print "Regex Tester is now active!";
print "====================================================================";
