// Test castling when destination is under attack
print "=========================================";
print "Testing Castling with Destination Attack";
print "=========================================";
print "";

// Define the types needed
ChessCell typeof bitmap { cellColor: 0, pieceType: 1-6, pieceColor: 7 };
posType typeof record { x: int, y: int };

// Constants
var EMPTY: int = 0;
var PAWN: int = 1;
var ROOK: int = 2;
var KNIGHT: int = 3;
var BISHOP: int = 4;
var QUEEN: int = 5;
var KING: int = 6;
var WHITE: int = 0;
var BLACK: int = 1;

// Create test board
var board: array.bitmap[64];

// Castling tracking variables
var whiteKingMoved: bool = false;
var blackKingMoved: bool = false;
var whiteKingsideRookMoved: bool = false;
var whiteQueensideRookMoved: bool = false;
var blackKingsideRookMoved: bool = false;
var blackQueensideRookMoved: bool = false;

// Helper functions
boardIndex(row: int, col: int) return int {
    return row * 8 + col;
}

modulo(a: int, b: int) return int {
    var q: int = a / b;
    return a - (q * b);
}

isValidPosition(x: int, y: int) return bool {
    return x >= 0 && x < 8 && y >= 0 && y < 8;
}

function getPieceAt(x: int, y: int) return int {
    if call isValidPosition(x, y) then {
        var idx: int = call boardIndex(y, x);
        var cellValue: int = board[idx];
        return cellValue;
    } else {
        return -1;
    }
}

function isOccupiedByColor(x: int, y: int, color: int) return bool {
    var cellValue: int = call getPieceAt(x, y);
    if cellValue == -1 then {
        return false;
    }
    var cell = ChessCell(cellValue);
    return cell.pieceType != EMPTY && cell.pieceColor == color;
}

encodeCellValue(cellColor: int, pieceType: int, pieceColor: int) return int {
    return cellColor + (pieceType * 2) + (pieceColor * 128);
}

// Import move functions
import "chess-moves.ebs";

// Initialize empty board
print "Initializing test board...";
var row: int = 0;
var col: int = 0;
var idx: int = 0;

for (row = 0; row < 8; row++) {
    for (col = 0; col < 8; col++) {
        var cellColor: int = call modulo(row + col, 2);
        idx = call boardIndex(row, col);
        board[idx] = call encodeCellValue(cellColor, EMPTY, WHITE);
    }
}

// Test 1: Kingside castling with destination under attack
print "";
print "Test 1: Kingside castling with g1 under attack";
print "------------------------------------------------";
print "White king at e1, rook at h1, black rook attacking g1";

// Place white king at e1 (x=4, y=7)
board[call boardIndex(7, 4)] = call encodeCellValue(1, KING, WHITE);

// Place white rook at h1 (x=7, y=7)
board[call boardIndex(7, 7)] = call encodeCellValue(0, ROOK, WHITE);

// Place black rook at g3 (x=6, y=5) - attacks g1 (x=6, y=7)
board[call boardIndex(5, 6)] = call encodeCellValue(0, ROOK, BLACK);

print "Getting valid moves for white king at (4, 7)...";
var moves = call validMoves(4, 7);
print "Found " + moves.length + " valid moves";

var foundKingsideCastle: bool = false;
var i: int = 0;
for (i = 0; i < moves.length; i = i + 1) {
    var move: posType = moves[i];
    if move.x == 6 && move.y == 7 then {
        foundKingsideCastle = true;
    }
}

if foundKingsideCastle then {
    print "✗ ERROR: Kingside castling should be blocked (g1 under attack)!";
} else {
    print "✓ Kingside castling correctly blocked (destination under attack)";
}

// Test 2: Queenside castling with destination under attack
print "";
print "Test 2: Queenside castling with c1 under attack";
print "------------------------------------------------";
print "Adding white queenside rook, black bishop attacking c1";

// Clear the black rook
board[call boardIndex(5, 6)] = call encodeCellValue(0, EMPTY, WHITE);

// Place white rook at a1 (x=0, y=7)
board[call boardIndex(7, 0)] = call encodeCellValue(1, ROOK, WHITE);

// Place black bishop at a3 (x=0, y=5) - attacks c1 (x=2, y=7)
board[call boardIndex(5, 0)] = call encodeCellValue(1, BISHOP, BLACK);

print "Getting valid moves for white king at (4, 7)...";
moves = call validMoves(4, 7);
print "Found " + moves.length + " valid moves";

var foundQueensideCastle: bool = false;
for (i = 0; i < moves.length; i = i + 1) {
    var move2: posType = moves[i];
    if move2.x == 2 && move2.y == 7 then {
        foundQueensideCastle = true;
    }
}

if foundQueensideCastle then {
    print "✗ ERROR: Queenside castling should be blocked (c1 under attack)!";
} else {
    print "✓ Queenside castling correctly blocked (destination under attack)";
}

// Test 3: Kingside castling with f1 under attack (through check)
print "";
print "Test 3: Castling through check (f1 under attack)";
print "--------------------------------------------------";
print "Black rook attacking f1 (king would pass through check)";

// Clear the black bishop
board[call boardIndex(5, 0)] = call encodeCellValue(1, EMPTY, WHITE);

// Place black rook at f3 (x=5, y=5) - attacks f1 (x=5, y=7)
board[call boardIndex(5, 5)] = call encodeCellValue(1, ROOK, BLACK);

print "Getting valid moves for white king at (4, 7)...";
moves = call validMoves(4, 7);
print "Found " + moves.length + " valid moves";

var foundThroughCheck: bool = false;
for (i = 0; i < moves.length; i = i + 1) {
    var move3: posType = moves[i];
    if move3.x == 6 && move3.y == 7 then {
        foundThroughCheck = true;
    }
}

if foundThroughCheck then {
    print "✗ ERROR: Kingside castling should be blocked (passing through check)!";
} else {
    print "✓ Kingside castling correctly blocked (king passes through check)";
}

// Summary
print "";
print "=========================================";
print "Test Summary";
print "=========================================";

var totalTests: int = 3;
var passedTests: int = 0;

if !foundKingsideCastle then { passedTests = passedTests + 1; }
if !foundQueensideCastle then { passedTests = passedTests + 1; }
if !foundThroughCheck then { passedTests = passedTests + 1; }

print "Tests passed: " + passedTests + " / " + totalTests;

if passedTests == totalTests then {
    print "✓ All tests PASSED!";
} else {
    print "✗ Some tests FAILED!";
}

print "";
print "Test complete!";
