// Test castling when rook is missing or captured
print "============================================";
print "Testing Castling with Missing/Captured Rook";
print "============================================";
print "";

// Define the types needed
ChessCell typeof bitmap { cellColor: 0, pieceType: 1-6, pieceColor: 7 };
posType typeof record { x: int, y: int };

// Constants
var EMPTY: int = 0;
var PAWN: int = 1;
var ROOK: int = 2;
var KNIGHT: int = 3;
var BISHOP: int = 4;
var QUEEN: int = 5;
var KING: int = 6;
var WHITE: int = 0;
var BLACK: int = 1;

// Create test board
var board: array.bitmap[64];

// Castling tracking variables
var whiteKingMoved: bool = false;
var blackKingMoved: bool = false;
var whiteKingsideRookMoved: bool = false;
var whiteQueensideRookMoved: bool = false;
var blackKingsideRookMoved: bool = false;
var blackQueensideRookMoved: bool = false;

// Helper functions
boardIndex(row: int, col: int) return int {
    return row * 8 + col;
}

modulo(a: int, b: int) return int {
    var q: int = a / b;
    return a - (q * b);
}

isValidPosition(x: int, y: int) return bool {
    return x >= 0 && x < 8 && y >= 0 && y < 8;
}

function getPieceAt(x: int, y: int) return int {
    if call isValidPosition(x, y) then {
        var idx: int = call boardIndex(y, x);
        var cellValue: int = board[idx];
        return cellValue;
    } else {
        return -1;
    }
}

function isOccupiedByColor(x: int, y: int, color: int) return bool {
    var cellValue: int = call getPieceAt(x, y);
    if cellValue == -1 then {
        return false;
    }
    var cell = ChessCell(cellValue);
    return cell.pieceType != EMPTY && cell.pieceColor == color;
}

encodeCellValue(cellColor: int, pieceType: int, pieceColor: int) return int {
    return cellColor + (pieceType * 2) + (pieceColor * 128);
}

// Import move functions
import "chess-moves.ebs";

// Initialize empty board
print "Initializing test board...";
var row: int = 0;
var col: int = 0;
var idx: int = 0;

for (row = 0; row < 8; row++) {
    for (col = 0; col < 8; col++) {
        var cellColor: int = call modulo(row + col, 2);
        idx = call boardIndex(row, col);
        board[idx] = call encodeCellValue(cellColor, EMPTY, WHITE);
    }
}

// Test 1: Kingside castling with rook missing
print "";
print "Test 1: Kingside castling with rook missing";
print "--------------------------------------------";
print "White king at e1, NO rook at h1";

// Place white king at e1 (x=4, y=7)
board[call boardIndex(7, 4)] = call encodeCellValue(1, KING, WHITE);

// Don't place the rook at h1 - it's missing/captured

print "Getting valid moves for white king at (4, 7)...";
var moves = call validMoves(4, 7);
print "Found " + moves.length + " valid moves";

var foundKingsideCastle: bool = false;
var i: int = 0;
for (i = 0; i < moves.length; i = i + 1) {
    var move: posType = moves[i];
    if move.x == 6 && move.y == 7 then {
        foundKingsideCastle = true;
    }
}

if foundKingsideCastle then {
    print "✗ ERROR: Kingside castling should not be possible without rook!";
} else {
    print "✓ Kingside castling correctly prevented (rook missing)";
}

// Test 2: Queenside castling with wrong piece
print "";
print "Test 2: Queenside castling with bishop instead of rook";
print "-------------------------------------------------------";
print "White king at e1, bishop (not rook) at a1";

// Place a bishop at a1 instead of rook (x=0, y=7)
board[call boardIndex(7, 0)] = call encodeCellValue(1, BISHOP, WHITE);

print "Getting valid moves for white king at (4, 7)...";
moves = call validMoves(4, 7);
print "Found " + moves.length + " valid moves";

var foundQueensideCastle: bool = false;
for (i = 0; i < moves.length; i = i + 1) {
    var move2: posType = moves[i];
    if move2.x == 2 && move2.y == 7 then {
        foundQueensideCastle = true;
    }
}

if foundQueensideCastle then {
    print "✗ ERROR: Queenside castling should not be possible with bishop!";
} else {
    print "✓ Queenside castling correctly prevented (wrong piece)";
}

// Test 3: Valid castling with rook present
print "";
print "Test 3: Valid castling when rook is present";
print "--------------------------------------------";
print "Adding rook at h1, should allow castling";

// Add rook at h1 (x=7, y=7)
board[call boardIndex(7, 7)] = call encodeCellValue(0, ROOK, WHITE);

print "Getting valid moves for white king at (4, 7)...";
moves = call validMoves(4, 7);
print "Found " + moves.length + " valid moves";

var foundValidCastle: bool = false;
for (i = 0; i < moves.length; i = i + 1) {
    var move3: posType = moves[i];
    if move3.x == 6 && move3.y == 7 then {
        foundValidCastle = true;
    }
}

if foundValidCastle then {
    print "✓ Kingside castling correctly allowed (rook present)";
} else {
    print "✗ ERROR: Kingside castling should be allowed with rook present!";
}

// Summary
print "";
print "============================================";
print "Test Summary";
print "============================================";

var totalTests: int = 3;
var passedTests: int = 0;

if !foundKingsideCastle then { passedTests = passedTests + 1; }
if !foundQueensideCastle then { passedTests = passedTests + 1; }
if foundValidCastle then { passedTests = passedTests + 1; }

print "Tests passed: " + passedTests + " / " + totalTests;

if passedTests == totalTests then {
    print "✓ All tests PASSED!";
} else {
    print "✗ Some tests FAILED!";
}

print "";
print "Test complete!";
