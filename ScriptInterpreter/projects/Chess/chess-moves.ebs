// Chess Move Calculation Functions
// ==================================
// This file contains all the move calculation logic for chess pieces.
// It is imported by chess-game.ebs.
//
// Functions:
//   - Helper functions for board access and position validation
//   - Move calculation for each piece type (pawn, knight, bishop, rook, queen, king)
//   - Main validMoves() function that determines legal moves for any piece

// Define the chess cell bitmap type for bit-level field access
ChessCell typeof bitmap { cellColor: 0, pieceType: 1-6, pieceColor: 7 };

// Define position type for x,y coordinates
posType typeof record { x: int, y: int };

// Helper function to create a posType record from x, y coordinates
function createPos(x: int, y: int) return posType {
    var jsonStr: string = '{"x": ' + x + ', "y": ' + y + '}';
    var jsonData: json = call json.jsonfromstring(jsonStr);
    var pos: posType = record(jsonData);
    return pos;
}

// Get all possible moves for a pawn at given position
function getPawnMoves(x: int, y: int, color: int) return array {
    var moves: posType[] = [];
    var direction: int;
    var startRow: int;
    
    if color == WHITE then {
        direction = -1;
        startRow = 6;
    } else {
        direction = 1;
        startRow = 1;
    }
    
    // Move forward one square
    var forwardX: int = x;
    var forwardY: int = y + direction;
    if call isValidPosition(forwardX, forwardY) then {
        var cellValue: int = call getPieceAt(forwardX, forwardY);
        var cell = ChessCell(cellValue);
        var pt1: int = cell.pieceType;
        if pt1 == EMPTY then {
            var forward: posType = call createPos(forwardX, forwardY);
            call array.add(moves, forward);
            
            // Move forward two squares from starting position
            if y == startRow then {
                var forward2X: int = x;
                var forward2Y: int = y + (direction * 2);
                var cellValue2: int = call getPieceAt(forward2X, forward2Y);
                var cell2 = ChessCell(cellValue2);
                var pt2: int = cell2.pieceType;
                if pt2 == EMPTY then {
                    var forward2: posType = call createPos(forward2X, forward2Y);
                    call array.add(moves, forward2);
                }
            }
        }
    }
    
    // Calculate enemy color once
    var enemyColor: int;
    if color == WHITE then {
        enemyColor = BLACK;
    } else {
        enemyColor = WHITE;
    }
    
    // Capture left diagonal
    var captureLeftX: int = x - 1;
    var captureLeftY: int = y + direction;
    if call isValidPosition(captureLeftX, captureLeftY) then {
        if call isOccupiedByColor(captureLeftX, captureLeftY, enemyColor) then {
            var captureLeft: posType = call createPos(captureLeftX, captureLeftY);
            call array.add(moves, captureLeft);
        }
    }
    
    // Capture right diagonal
    var captureRightX: int = x + 1;
    var captureRightY: int = y + direction;
    if call isValidPosition(captureRightX, captureRightY) then {
        if call isOccupiedByColor(captureRightX, captureRightY, enemyColor) then {
            var captureRight: posType = call createPos(captureRightX, captureRightY);
            call array.add(moves, captureRight);
        }
    }
    
    return moves;
}

// Get all possible moves for a knight at given position
function getKnightMoves(x: int, y: int) return array {
    var moves: posType[] = [];
    var offsets: int[16];
    
    // Knight move offsets: 8 possible L-shaped moves
    offsets[0] = -2; offsets[1] = -1;  // up 2, left 1
    offsets[2] = -2; offsets[3] = 1;   // up 2, right 1
    offsets[4] = 2; offsets[5] = -1;   // down 2, left 1
    offsets[6] = 2; offsets[7] = 1;    // down 2, right 1
    offsets[8] = -1; offsets[9] = -2;  // up 1, left 2
    offsets[10] = -1; offsets[11] = 2; // up 1, right 2
    offsets[12] = 1; offsets[13] = -2; // down 1, left 2
    offsets[14] = 1; offsets[15] = 2;  // down 1, right 2
    
    var i: int = 0;
    for (i = 0; i < 16; i = i + 2) {
        var newY: int = y + offsets[i];
        var newX: int = x + offsets[i + 1];
        if call isValidPosition(newX, newY) then {
            var newPos: posType = call createPos(newX, newY);
            call array.add(moves, newPos);
        }
    }
    
    return moves;
}

// Check if castling is allowed for a given king position and side
// side: 1 for kingside, -1 for queenside
// This checks: 1) pieces haven't moved, 2) squares are empty, 3) king not in check, 4) king doesn't move through check
function canCastle(kingX: int, kingY: int, kingColor: int, side: int) return bool {
    // Determine which pieces need to be checked based on color
    var kingMoved: bool;
    var rookMoved: bool;
    var rookX: int;
    
    if kingColor == WHITE then {
        // White king should be at e1 (x=4, y=7)
        if kingX != 4 || kingY != 7 then {
            return false;
        }
        kingMoved = whiteKingMoved;
        
        if side == 1 then {
            // Kingside - rook at h1 (x=7, y=7)
            rookMoved = whiteKingsideRookMoved;
            rookX = 7;
        } else {
            // Queenside - rook at a1 (x=0, y=7)
            rookMoved = whiteQueensideRookMoved;
            rookX = 0;
        }
    } else {
        // Black king should be at e8 (x=4, y=0)
        if kingX != 4 || kingY != 0 then {
            return false;
        }
        kingMoved = blackKingMoved;
        
        if side == 1 then {
            // Kingside - rook at h8 (x=7, y=0)
            rookMoved = blackKingsideRookMoved;
            rookX = 7;
        } else {
            // Queenside - rook at a8 (x=0, y=0)
            rookMoved = blackQueensideRookMoved;
            rookX = 0;
        }
    }
    
    // Check if king or rook has moved
    if kingMoved || rookMoved then {
        return false;
    }
    
    // Verify that the rook is actually present at the expected position
    var rookCellValue: int = call getPieceAt(rookX, kingY);
    if rookCellValue == -1 then {
        return false;  // Invalid position
    }
    
    var rookCell = ChessCell(rookCellValue);
    if rookCell.pieceType != ROOK || rookCell.pieceColor != kingColor then {
        return false;  // Rook is not present or wrong color
    }
    
    // Check if squares between king and rook are empty
    var startX: int;
    var endX: int;
    if side == 1 then {
        // Kingside: check f and g files (x=5, x=6)
        startX = kingX + 1;
        endX = rookX;
    } else {
        // Queenside: check b, c, d files (x=1, x=2, x=3)
        startX = rookX + 1;
        endX = kingX;
    }
    
    var checkX: int = startX;
    for (checkX = startX; checkX < endX; checkX = checkX + 1) {
        var cellValue: int = call getPieceAt(checkX, kingY);
        if cellValue != -1 then {
            var cell = ChessCell(cellValue);
            if cell.pieceType != EMPTY then {
                return false;  // Square is occupied
            }
        }
    }
    
    // Check if king is currently in check
    if call isKingInCheck(kingColor) then {
        return false;
    }
    
    // Determine opponent color
    var opponentColor: int;
    if kingColor == WHITE then {
        opponentColor = BLACK;
    } else {
        opponentColor = WHITE;
    }
    
    // Check if king would move through check or end in check
    // King moves from e-file (x=4) to g-file (x=6) for kingside or c-file (x=2) for queenside
    if side == 1 then {
        // Kingside: check f-file (x=5) and g-file (x=6)
        if call isSquareAttacked(5, kingY, opponentColor) then {
            return false;
        }
        if call isSquareAttacked(6, kingY, opponentColor) then {
            return false;
        }
    } else {
        // Queenside: check d-file (x=3) and c-file (x=2)
        if call isSquareAttacked(3, kingY, opponentColor) then {
            return false;
        }
        if call isSquareAttacked(2, kingY, opponentColor) then {
            return false;
        }
    }
    
    return true;
}

// Get all possible moves for a king at given position
function getKingMoves(x: int, y: int) return array {
    var moves: posType[] = [];
    var offsets: int[16];
    
    // King move offsets: 8 directions (one square each)
    offsets[0] = -1; offsets[1] = -1;  // up-left
    offsets[2] = -1; offsets[3] = 0;   // up
    offsets[4] = -1; offsets[5] = 1;   // up-right
    offsets[6] = 0; offsets[7] = -1;   // left
    offsets[8] = 0; offsets[9] = 1;    // right
    offsets[10] = 1; offsets[11] = -1; // down-left
    offsets[12] = 1; offsets[13] = 0;  // down
    offsets[14] = 1; offsets[15] = 1;  // down-right
    
    var i: int = 0;
    for (i = 0; i < 16; i = i + 2) {
        var newY: int = y + offsets[i];
        var newX: int = x + offsets[i + 1];
        if call isValidPosition(newX, newY) then {
            var newPos: posType = call createPos(newX, newY);
            call array.add(moves, newPos);
        }
    }
    
    // Add castling moves if allowed
    var cellValue: int = call getPieceAt(x, y);
    if cellValue != -1 then {
        var cell = ChessCell(cellValue);
        var kingColor: int = cell.pieceColor;
        
        // Check kingside castling
        if call canCastle(x, y, kingColor, 1) then {
            var kingsideCastle: posType = call createPos(x + 2, y);  // King moves 2 squares to the right
            call array.add(moves, kingsideCastle);
        }
        
        // Check queenside castling
        if call canCastle(x, y, kingColor, -1) then {
            var queensideCastle: posType = call createPos(x - 2, y);  // King moves 2 squares to the left
            call array.add(moves, queensideCastle);
        }
    }
    
    return moves;
}

// Get all possible moves for a rook at given position
function getRookMoves(x: int, y: int) return array {
    var moves: posType[] = [];
    var directions: int[8];
    
    // Rook move directions: up, down, left, right
    directions[0] = -1; directions[1] = 0;  // up
    directions[2] = 1; directions[3] = 0;   // down
    directions[4] = 0; directions[5] = -1;  // left
    directions[6] = 0; directions[7] = 1;   // right
    
    var d: int = 0;
    for (d = 0; d < 8; d = d + 2) {
        var dy: int = directions[d];
        var dx: int = directions[d + 1];
        var step: int = 1;
        var blocked: bool = false;
        
        while !blocked {
            var newY: int = y + (dy * step);
            var newX: int = x + (dx * step);
            
            if call isValidPosition(newX, newY) then {
                var newPos: posType = call createPos(newX, newY);
                call array.add(moves, newPos);
                
                // Check if blocked by any piece
                var cellValue: int = call getPieceAt(newX, newY);
                var cell = ChessCell(cellValue);
                if cell.pieceType != EMPTY then {
                    blocked = true;
                }
                
                step = step + 1;
            } else {
                blocked = true;
            }
        }
    }
    
    return moves;
}

// Get all possible moves for a bishop at given position
function getBishopMoves(x: int, y: int) return array {
    var moves: posType[] = [];
    var directions: int[8];
    
    // Bishop move directions: diagonals
    directions[0] = -1; directions[1] = -1;  // up-left
    directions[2] = -1; directions[3] = 1;   // up-right
    directions[4] = 1; directions[5] = -1;   // down-left
    directions[6] = 1; directions[7] = 1;    // down-right
    
    var d: int = 0;
    for (d = 0; d < 8; d = d + 2) {
        var dy: int = directions[d];
        var dx: int = directions[d + 1];
        var step: int = 1;
        var blocked: bool = false;
        
        while !blocked {
            var newY: int = y + (dy * step);
            var newX: int = x + (dx * step);
            
            if call isValidPosition(newX, newY) then {
                var newPos: posType = call createPos(newX, newY);
                call array.add(moves, newPos);
                
                // Check if blocked by any piece
                var cellValue: int = call getPieceAt(newX, newY);
                var cell = ChessCell(cellValue);
                if cell.pieceType != EMPTY then {
                    blocked = true;
                }
                
                step = step + 1;
            } else {
                blocked = true;
            }
        }
    }
    
    return moves;
}

// Get all possible moves for a queen at given position
function getQueenMoves(x: int, y: int) return array {
    var moves: posType[] = [];
    
    // Queen moves = Rook moves + Bishop moves
    var rookMoves = call getRookMoves(x, y);
    var bishopMoves = call getBishopMoves(x, y);
    
    var i: int = 0;
    var len: int = rookMoves.length;
    for (i = 0; i < len; i = i + 1) {
        call array.add(moves, rookMoves[i]);
    }
    
    len = bishopMoves.length;
    for (i = 0; i < len; i = i + 1) {
        call array.add(moves, bishopMoves[i]);
    }
    
    return moves;
}

// Main function: Get all valid moves for a piece at the given position
// Returns a posType array of valid moves on the board
function validMoves(x: int, y: int) return array {
    var validMovesList: posType[] = [];
    var allMoves = [];
    
    // Get the piece at the current position
    var cellValue: int = call getPieceAt(x, y);
    if cellValue == -1 then {
        return validMovesList;  // Empty array for invalid position
    }
    
    var cell = ChessCell(cellValue);
    var pt: int = cell.pieceType;
    var pc: int = cell.pieceColor;
    var pieceType: int = pt;
    var pieceColor: int = pc;
    
    // Get all possible moves based on piece type
    if pieceType == PAWN then {
        allMoves = call getPawnMoves(x, y, pieceColor);
    } else if pieceType == ROOK then {
        allMoves = call getRookMoves(x, y);
    } else if pieceType == KNIGHT then {
        allMoves = call getKnightMoves(x, y);
    } else if pieceType == BISHOP then {
        allMoves = call getBishopMoves(x, y);
    } else if pieceType == QUEEN then {
        allMoves = call getQueenMoves(x, y);
    } else if pieceType == KING then {
        allMoves = call getKingMoves(x, y);
    } else {
        return validMovesList;  // Empty piece
    }
    
    // Filter moves to only include valid ones
    // (don't capture own pieces, stay on board, etc.)
    var i: int = 0;
    var len: int = allMoves.length;
    for (i = 0; i < len; i = i + 1) {
        var move: posType = allMoves[i];
        var targetX: int = move.x;
        var targetY: int = move.y;
        
        // Check if target position is valid
        if call isValidPosition(targetX, targetY) then {
            var targetCellValue: int = call getPieceAt(targetX, targetY);
            var targetCell = ChessCell(targetCellValue);
            
            // Can move to empty square or capture opponent's piece
            if targetCell.pieceType == EMPTY || targetCell.pieceColor != pieceColor then {
                call array.add(validMovesList, move);
            }
        }
    }
    
    return validMovesList;
}

// Find the position of the king for a given color
// Returns a posType with x and y coordinates, or x=-1, y=-1 if not found
function findKing(kingColor: int) return posType {
    var x: int = 0;
    var y: int = 0;
    
    for (y = 0; y < 8; y = y + 1) {
        for (x = 0; x < 8; x = x + 1) {
            var cellValue: int = call getPieceAt(x, y);
            if cellValue != -1 then {
                var cell = ChessCell(cellValue);
                if cell.pieceType == KING && cell.pieceColor == kingColor then {
                    return call createPos(x, y);
                }
            }
        }
    }
    
    // King not found (shouldn't happen in a valid game)
    return call createPos(-1, -1);
}

// Check if a square is under attack by the given color
// Returns true if any piece of attackerColor can move to (targetX, targetY)
function isSquareAttacked(targetX: int, targetY: int, attackerColor: int) return bool {
    var x: int = 0;
    var y: int = 0;
    
    // Check all squares for attacking pieces
    for (y = 0; y < 8; y = y + 1) {
        for (x = 0; x < 8; x = x + 1) {
            var cellValue: int = call getPieceAt(x, y);
            if cellValue != -1 then {
                var cell = ChessCell(cellValue);
                
                // Only check pieces of the attacker's color
                if cell.pieceType != EMPTY && cell.pieceColor == attackerColor then {
                    // Get moves for this piece (without filtering for check)
                    var moves = [];
                    var pieceType: int = cell.pieceType;
                    
                    if pieceType == PAWN then {
                        moves = call getPawnMoves(x, y, attackerColor);
                    } else if pieceType == ROOK then {
                        moves = call getRookMoves(x, y);
                    } else if pieceType == KNIGHT then {
                        moves = call getKnightMoves(x, y);
                    } else if pieceType == BISHOP then {
                        moves = call getBishopMoves(x, y);
                    } else if pieceType == QUEEN then {
                        moves = call getQueenMoves(x, y);
                    } else if pieceType == KING then {
                        moves = call getKingMoves(x, y);
                    }
                    
                    // Check if any move targets the square in question
                    var i: int = 0;
                    var len: int = moves.length;
                    for (i = 0; i < len; i = i + 1) {
                        var move: posType = moves[i];
                        if move.x == targetX && move.y == targetY then {
                            return true;
                        }
                    }
                }
            }
        }
    }
    
    return false;
}

// Check if the king of the given color is currently in check
function isKingInCheck(kingColor: int) return bool {
    var kingPos: posType = call findKing(kingColor);
    
    // If king not found, return false (shouldn't happen)
    if kingPos.x == -1 then {
        return false;
    }
    
    // Determine opponent color
    var opponentColor: int;
    if kingColor == WHITE then {
        opponentColor = BLACK;
    } else {
        opponentColor = WHITE;
    }
    
    // Check if the king's position is under attack by the opponent
    return call isSquareAttacked(kingPos.x, kingPos.y, opponentColor);
}

// Check if making a move would leave the player's own king in check
// This simulates the move temporarily and checks for check
function wouldMoveExposeKing(fromX: int, fromY: int, toX: int, toY: int, playerColor: int) return bool {
    // Get the piece being moved
    var fromCellValue: int = call getPieceAt(fromX, fromY);
    var toCellValue: int = call getPieceAt(toX, toY);
    
    if fromCellValue == -1 then {
        return false;
    }
    
    var fromCell = ChessCell(fromCellValue);
    
    // Temporarily make the move
    var fromIndex: int = call boardIndex(fromY, fromX);
    var toIndex: int = call boardIndex(toY, toX);
    
    // Save original values
    var originalFrom: int = board[fromIndex];
    var originalTo: int = board[toIndex];
    
    // Make the move on the board
    board[toIndex] = fromCellValue;
    // Clear the source square but preserve cell color
    // Note: piece color is irrelevant when pieceType is EMPTY, using WHITE for consistency
    var emptyCellValue: int = call encodeCellValue(fromCell.cellColor, EMPTY, WHITE);
    board[fromIndex] = emptyCellValue;
    
    // Check if king is now in check
    var inCheck: bool = call isKingInCheck(playerColor);
    
    // Restore the board
    board[fromIndex] = originalFrom;
    board[toIndex] = originalTo;
    
    return inCheck;
}

// Check if making a move would put the opponent's king in check
function wouldMoveCheckOpponent(fromX: int, fromY: int, toX: int, toY: int, playerColor: int) return bool {
    // Get the piece being moved
    var fromCellValue: int = call getPieceAt(fromX, fromY);
    var toCellValue: int = call getPieceAt(toX, toY);
    
    if fromCellValue == -1 then {
        return false;
    }
    
    var fromCell = ChessCell(fromCellValue);
    
    // Determine opponent color
    var opponentColor: int;
    if playerColor == WHITE then {
        opponentColor = BLACK;
    } else {
        opponentColor = WHITE;
    }
    
    // Temporarily make the move
    var fromIndex: int = call boardIndex(fromY, fromX);
    var toIndex: int = call boardIndex(toY, toX);
    
    // Save original values
    var originalFrom: int = board[fromIndex];
    var originalTo: int = board[toIndex];
    
    // Make the move on the board
    board[toIndex] = fromCellValue;
    // Clear the source square but preserve cell color
    // Note: piece color is irrelevant when pieceType is EMPTY, using WHITE for consistency
    var emptyCellValue: int = call encodeCellValue(fromCell.cellColor, EMPTY, WHITE);
    board[fromIndex] = emptyCellValue;
    
    // Check if opponent's king is now in check
    var checksOpponent: bool = call isKingInCheck(opponentColor);
    
    // Restore the board
    board[fromIndex] = originalFrom;
    board[toIndex] = originalTo;
    
    return checksOpponent;
}

// Check if a player has any legal moves (used for checkmate/stalemate detection)
function hasAnyLegalMoves(playerColor: int) return bool {
    var x: int = 0;
    var y: int = 0;
    
    // Check all squares for player's pieces
    for (y = 0; y < 8; y = y + 1) {
        for (x = 0; x < 8; x = x + 1) {
            var cellValue: int = call getPieceAt(x, y);
            if cellValue != -1 then {
                var cell = ChessCell(cellValue);
                
                // Only check pieces of the player's color
                if cell.pieceType != EMPTY && cell.pieceColor == playerColor then {
                    // Get all possible moves for this piece
                    var moves = call validMoves(x, y);
                    
                    // Check each move to see if it's legal (doesn't expose king)
                    var i: int = 0;
                    var len: int = moves.length;
                    for (i = 0; i < len; i = i + 1) {
                        var move: posType = moves[i];
                        
                        // Check if this move would expose the king
                        var exposesKing: bool = call wouldMoveExposeKing(x, y, move.x, move.y, playerColor);
                        
                        if !exposesKing then {
                            // Found at least one legal move
                            return true;
                        }
                    }
                }
            }
        }
    }
    
    // No legal moves found
    return false;
}

// Check if the given player is in checkmate
function isCheckmate(playerColor: int) return bool {
    // Checkmate requires: king is in check AND no legal moves
    var inCheck: bool = call isKingInCheck(playerColor);
    if !inCheck then {
        return false;
    }
    
    var hasLegalMoves: bool = call hasAnyLegalMoves(playerColor);
    return !hasLegalMoves;
}

// Check if the game is in stalemate (draw)
function isStalemate(playerColor: int) return bool {
    // Stalemate requires: king is NOT in check AND no legal moves
    var inCheck: bool = call isKingInCheck(playerColor);
    if inCheck then {
        return false;
    }
    
    var hasLegalMoves: bool = call hasAnyLegalMoves(playerColor);
    return !hasLegalMoves;
}
