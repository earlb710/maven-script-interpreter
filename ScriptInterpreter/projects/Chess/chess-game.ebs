// Import chess move calculation functions
import "chess-moves.ebs";

// EBS Chess Game Application
// ===========================
// This script demonstrates using the array.bitmap type for efficient chess board encoding.
//
// Board Encoding:
//   - Uses array.bitmap[64] to store 8x8 chess board
//   - Each cell encoded as a bitmap byte:
//     * Bit 0: Cell color (0=light, 1=dark) - for checkerboard pattern
//     * Bits 1-6: Piece type (0=empty, 1=pawn, 2=rook, 3=knight, 4=bishop, 5=queen, 6=king)
//     * Bit 7: Piece color (0=white, 1=black)
//
// Features:
//   - Console display with Unicode chess symbols
//   - Graphical JavaFX GridPane chess board with SVG piece images
//   - Row labels (1-8) and column labels (a-h)
//   - Timer display for both players
//   - New Game button to reset the board
//
// Usage:
//   Run in EBS Console: /open scripts/app/chess.ebs then Ctrl+Enter


// Define chess piece record type with piece name, color, and position
// Piece codes: K=King, Q=Queen, R=Rook, B=Bishop, N=Knight, P=Pawn
// Color codes: W=White, B=Black
ChessPiece typeof record { piece: string, color: string, pos: posType };

// Array of all 32 chess pieces with their starting positions
var pieces: ChessPiece[32];

// Piece type constants
var EMPTY: int = 0;
var PAWN: int = 1;
var ROOK: int = 2;
var KNIGHT: int = 3;
var BISHOP: int = 4;
var QUEEN: int = 5;
var KING: int = 6;

// Piece color constants
var WHITE: int = 0;
var BLACK: int = 1;

// UI Color scheme - Named colors for easy customization via config screen
var COLOR_BG_MAIN: string = "#2c2c2c";           // Main background - dark gray
var COLOR_BG_TIMER: string = "#3c3c3c";          // Timer area background - medium dark gray
var COLOR_BG_BOARD: string = "#654321";          // Board container background - brown
var COLOR_CELL_LIGHT: string = "#f0d9b5";        // Light chess squares - light wood (beige)
var COLOR_CELL_DARK: string = "#b58863";         // Dark chess squares - dark wood (brown)
var COLOR_TEXT_WHITE: string = "#ffffff";        // White text - for labels on dark backgrounds
var COLOR_TEXT_RULER: string = "#ffcc00";        // Ruler text (a-h, 1-8) - bright gold for high contrast
var COLOR_TEXT_SEPARATOR: string = "#cccccc";    // Separator text - light gray (improved from #666666)
var COLOR_TEXT_TIMER_LABEL: string = "#ffff00";  // Timer label text - bright yellow
var COLOR_TIMER_WHITE: string = "#00ff00";       // White player timer - bright green
var COLOR_TIMER_BLACK: string = "#ff6600";       // Black player timer - orange
var COLOR_TIMER_ACTIVE: string = "#ffff00";      // Active player timer - bright yellow
var COLOR_TIMER_INACTIVE: string = "#888888";    // Inactive player timer - light gray
var COLOR_LABEL_ACTIVE: string = "#ffff00";      // Active player label - bright yellow
var COLOR_LABEL_INACTIVE: string = "#888888";    // Inactive player label - light gray
var COLOR_BUTTON_NEW_GAME: string = "#ffff00";   // New Game button - yellow
var COLOR_MOVE_HISTORY_BG: string = "#ffffff";   // Move history background - white
var COLOR_MOVE_HISTORY_TEXT: string = "#000000"; // Move history text color - black

// Chess piece Unicode symbols (for console display)
var whitePieces: string[7];
whitePieces[0] = "";        // Empty
whitePieces[1] = "\u2659";  // White Pawn
whitePieces[2] = "\u2656";  // White Rook
whitePieces[3] = "\u2658";  // White Knight
whitePieces[4] = "\u2657";  // White Bishop
whitePieces[5] = "\u2655";  // White Queen
whitePieces[6] = "\u2654";  // White King

var blackPieces: string[7];
blackPieces[0] = "";        // Empty
blackPieces[1] = "\u265F";  // Black Pawn
blackPieces[2] = "\u265C";  // Black Rook
blackPieces[3] = "\u265E";  // Black Knight
blackPieces[4] = "\u265D";  // Black Bishop
blackPieces[5] = "\u265B";  // Black Queen
blackPieces[6] = "\u265A";  // Black King

// Image path base for SVG chess pieces
// Path relative to ScriptInterpreter directory (working directory when script runs)
var imgPath: string = "src/main/resources/images/chess/";

// Create the chess board using array.bitmap for bitmap-encoded cell data (8x8 = 64 elements)
var board: array.bitmap[64];

// Timer variables (now in deciseconds - 10ths of a second)
var timerWhite: int = 6000;  // 600 seconds = 6000 deciseconds
var timerBlack: int = 6000;  // 600 seconds = 6000 deciseconds
var currentPlayer: int = 0;

// Selection and move indication variables
var selectedX: int = -1;  // -1 means no selection
var selectedY: int = -1;
var greenIndicator: imagedata;  // Green circle for valid moves
var redIndicator: imagedata;    // Red circle for capture moves
var transparentClear: imagedata; // Transparent rectangle for clearing piece positions

// Board layer images (bottom layer - checkerboard)
var lightSquare: imagedata;     // Light square for board
var darkSquare: imagedata;      // Dark square for board

// Normal (original) piece images - stored for restoring after deselection
var normalWhitePawn: imagedata;
var normalWhiteRook: imagedata;
var normalWhiteKnight: imagedata;
var normalWhiteBishop: imagedata;
var normalWhiteQueen: imagedata;
var normalWhiteKing: imagedata;
var normalBlackPawn: imagedata;
var normalBlackRook: imagedata;
var normalBlackKnight: imagedata;
var normalBlackBishop: imagedata;
var normalBlackQueen: imagedata;
var normalBlackKing: imagedata;

// Yellow piece images - used when a piece is selected/clicked
var yellowWhitePawn: imagedata;
var yellowWhiteRook: imagedata;
var yellowWhiteKnight: imagedata;
var yellowWhiteBishop: imagedata;
var yellowWhiteQueen: imagedata;
var yellowWhiteKing: imagedata;
var yellowBlackPawn: imagedata;
var yellowBlackRook: imagedata;
var yellowBlackKnight: imagedata;
var yellowBlackBishop: imagedata;
var yellowBlackQueen: imagedata;
var yellowBlackKing: imagedata;

// Helper functions
boardIndex(row: int, col: int) return int {
    return row * 8 + col;
}

modulo(a: int, b: int) return int {
    var q: int = a / b;
    return a - (q * b);
}

// Check if a position is within board bounds
isValidPosition(x: int, y: int) return bool {
    return x >= 0 && x < 8 && y >= 0 && y < 8;
}

// Get piece information at a given position (x, y coordinates)
function getPieceAt(x: int, y: int) return int {
    if call isValidPosition(x, y) then {
        var idx: int = call boardIndex(y, x);
        var cellValue: int = board[idx];
        return cellValue;
    } else {
        return -1;
    }
}

// Check if position is occupied by a piece of the given color
function isOccupiedByColor(x: int, y: int, color: int) return bool {
    var cellValue: int = call getPieceAt(x, y);
    if cellValue == -1 then {
        return false;
    }
    var cell = ChessCell(cellValue);
    return cell.pieceType != EMPTY && cell.pieceColor == color;
}

// Get the normal (original) version of a piece image based on piece type and color
function getNormalPiece(pieceType: int, pieceColor: int) return imagedata {
    if pieceColor == WHITE then {
        if pieceType == PAWN then { return normalWhitePawn; }
        if pieceType == ROOK then { return normalWhiteRook; }
        if pieceType == KNIGHT then { return normalWhiteKnight; }
        if pieceType == BISHOP then { return normalWhiteBishop; }
        if pieceType == QUEEN then { return normalWhiteQueen; }
        if pieceType == KING then { return normalWhiteKing; }
    } else {
        if pieceType == PAWN then { return normalBlackPawn; }
        if pieceType == ROOK then { return normalBlackRook; }
        if pieceType == KNIGHT then { return normalBlackKnight; }
        if pieceType == BISHOP then { return normalBlackBishop; }
        if pieceType == QUEEN then { return normalBlackQueen; }
        if pieceType == KING then { return normalBlackKing; }
    }
    return null;
}

// Get the yellow version of a piece image based on piece type and color
function getYellowPiece(pieceType: int, pieceColor: int) return imagedata {
    if pieceColor == WHITE then {
        if pieceType == PAWN then { return yellowWhitePawn; }
        if pieceType == ROOK then { return yellowWhiteRook; }
        if pieceType == KNIGHT then { return yellowWhiteKnight; }
        if pieceType == BISHOP then { return yellowWhiteBishop; }
        if pieceType == QUEEN then { return yellowWhiteQueen; }
        if pieceType == KING then { return yellowWhiteKing; }
    } else {
        if pieceType == PAWN then { return yellowBlackPawn; }
        if pieceType == ROOK then { return yellowBlackRook; }
        if pieceType == KNIGHT then { return yellowBlackKnight; }
        if pieceType == BISHOP then { return yellowBlackBishop; }
        if pieceType == QUEEN then { return yellowBlackQueen; }
        if pieceType == KING then { return yellowBlackKing; }
    }
    return null;
}

// Create board layer images (bottom layer - checkerboard)
createBoardLayer() {
    // Create light square for board
    var lightCanvas: canvas = call canvas.create(60, 60, "light_square");
    call style.setFill(lightCanvas, COLOR_CELL_LIGHT);
    call draw.rect(lightCanvas, 0, 0, 60, 60, true);
    lightSquare = call canvas.toImage(lightCanvas);
    
    // Create dark square for board
    var darkCanvas: canvas = call canvas.create(60, 60, "dark_square");
    call style.setFill(darkCanvas, COLOR_CELL_DARK);
    call draw.rect(darkCanvas, 0, 0, 60, 60, true);
    darkSquare = call canvas.toImage(darkCanvas);
}

// Create indicator images using canvas (middle layer)
createIndicators() {
    // Create green circle indicator for valid moves
    // Canvas size matches cell size (60x60) for proper centering
    var greenCanvas: canvas = call canvas.create(60, 60, "green_indicator");
    call canvas.clear(greenCanvas);  // Make canvas transparent
    call style.setFill(greenCanvas, "#00FF0080");  // Semi-transparent green
    call draw.circle(greenCanvas, 30, 30, 20, true);
    call style.setStroke(greenCanvas, "#00AA00", 2.0);
    call draw.circle(greenCanvas, 30, 30, 20, false);
    greenIndicator = call canvas.toImage(greenCanvas);
    
    // Create red circle indicator for capture moves
    // Canvas size matches cell size (60x60) for proper centering
    var redCanvas: canvas = call canvas.create(60, 60, "red_indicator");
    call canvas.clear(redCanvas);  // Make canvas transparent
    call style.setFill(redCanvas, "#FF000080");  // Semi-transparent red
    call draw.circle(redCanvas, 30, 30, 20, true);
    call style.setStroke(redCanvas, "#AA0000", 2.0);
    call draw.circle(redCanvas, 30, 30, 20, false);
    redIndicator = call canvas.toImage(redCanvas);
    
    // Create transparent rectangle for clearing piece positions
    // Canvas size matches cell size (60x60)
    var clearCanvas: canvas = call canvas.create(60, 60, "transparent_clear");
    call canvas.clear(clearCanvas);  // Make canvas completely transparent
    transparentClear = call canvas.toImage(clearCanvas);
}

// Load normal and yellow piece images
loadPieceImages() {
    // Load normal (original) piece images
    normalWhitePawn = call image.load(imgPath + "white_pawn.svg");
    normalWhiteRook = call image.load(imgPath + "white_rook.svg");
    normalWhiteKnight = call image.load(imgPath + "white_knight.svg");
    normalWhiteBishop = call image.load(imgPath + "white_bishop.svg");
    normalWhiteQueen = call image.load(imgPath + "white_queen.svg");
    normalWhiteKing = call image.load(imgPath + "white_king.svg");
    normalBlackPawn = call image.load(imgPath + "black_pawn.svg");
    normalBlackRook = call image.load(imgPath + "black_rook.svg");
    normalBlackKnight = call image.load(imgPath + "black_knight.svg");
    normalBlackBishop = call image.load(imgPath + "black_bishop.svg");
    normalBlackQueen = call image.load(imgPath + "black_queen.svg");
    normalBlackKing = call image.load(imgPath + "black_king.svg");
    
    // Load yellow piece images (for highlighting selected pieces)
    yellowWhitePawn = call image.load(imgPath + "yellow_white_pawn.svg");
    yellowWhiteRook = call image.load(imgPath + "yellow_white_rook.svg");
    yellowWhiteKnight = call image.load(imgPath + "yellow_white_knight.svg");
    yellowWhiteBishop = call image.load(imgPath + "yellow_white_bishop.svg");
    yellowWhiteQueen = call image.load(imgPath + "yellow_white_queen.svg");
    yellowWhiteKing = call image.load(imgPath + "yellow_white_king.svg");
    yellowBlackPawn = call image.load(imgPath + "yellow_black_pawn.svg");
    yellowBlackRook = call image.load(imgPath + "yellow_black_rook.svg");
    yellowBlackKnight = call image.load(imgPath + "yellow_black_knight.svg");
    yellowBlackBishop = call image.load(imgPath + "yellow_black_bishop.svg");
    yellowBlackQueen = call image.load(imgPath + "yellow_black_queen.svg");
    yellowBlackKing = call image.load(imgPath + "yellow_black_king.svg");
}

// Clear all move indicators on the board
clearIndicators() {
    // Clear all 64 indicator positions
    chessScreen.i00 = null;
    chessScreen.i01 = null;
    chessScreen.i02 = null;
    chessScreen.i03 = null;
    chessScreen.i04 = null;
    chessScreen.i05 = null;
    chessScreen.i06 = null;
    chessScreen.i07 = null;
    chessScreen.i10 = null;
    chessScreen.i11 = null;
    chessScreen.i12 = null;
    chessScreen.i13 = null;
    chessScreen.i14 = null;
    chessScreen.i15 = null;
    chessScreen.i16 = null;
    chessScreen.i17 = null;
    chessScreen.i20 = null;
    chessScreen.i21 = null;
    chessScreen.i22 = null;
    chessScreen.i23 = null;
    chessScreen.i24 = null;
    chessScreen.i25 = null;
    chessScreen.i26 = null;
    chessScreen.i27 = null;
    chessScreen.i30 = null;
    chessScreen.i31 = null;
    chessScreen.i32 = null;
    chessScreen.i33 = null;
    chessScreen.i34 = null;
    chessScreen.i35 = null;
    chessScreen.i36 = null;
    chessScreen.i37 = null;
    chessScreen.i40 = null;
    chessScreen.i41 = null;
    chessScreen.i42 = null;
    chessScreen.i43 = null;
    chessScreen.i44 = null;
    chessScreen.i45 = null;
    chessScreen.i46 = null;
    chessScreen.i47 = null;
    chessScreen.i50 = null;
    chessScreen.i51 = null;
    chessScreen.i52 = null;
    chessScreen.i53 = null;
    chessScreen.i54 = null;
    chessScreen.i55 = null;
    chessScreen.i56 = null;
    chessScreen.i57 = null;
    chessScreen.i60 = null;
    chessScreen.i61 = null;
    chessScreen.i62 = null;
    chessScreen.i63 = null;
    chessScreen.i64 = null;
    chessScreen.i65 = null;
    chessScreen.i66 = null;
    chessScreen.i67 = null;
    chessScreen.i70 = null;
    chessScreen.i71 = null;
    chessScreen.i72 = null;
    chessScreen.i73 = null;
    chessScreen.i74 = null;
    chessScreen.i75 = null;
    chessScreen.i76 = null;
    chessScreen.i77 = null;
}

// Set indicator for a specific cell
setIndicator(x: int, y: int, isCapture: bool) {
    var indicator: imagedata;
    if isCapture then {
        indicator = redIndicator;
    } else {
        indicator = greenIndicator;
    }
    
    // Set the indicator based on position
    if y == 0 then {
        if x == 0 then { chessScreen.i00 = indicator; }
        if x == 1 then { chessScreen.i01 = indicator; }
        if x == 2 then { chessScreen.i02 = indicator; }
        if x == 3 then { chessScreen.i03 = indicator; }
        if x == 4 then { chessScreen.i04 = indicator; }
        if x == 5 then { chessScreen.i05 = indicator; }
        if x == 6 then { chessScreen.i06 = indicator; }
        if x == 7 then { chessScreen.i07 = indicator; }
    } else if y == 1 then {
        if x == 0 then { chessScreen.i10 = indicator; }
        if x == 1 then { chessScreen.i11 = indicator; }
        if x == 2 then { chessScreen.i12 = indicator; }
        if x == 3 then { chessScreen.i13 = indicator; }
        if x == 4 then { chessScreen.i14 = indicator; }
        if x == 5 then { chessScreen.i15 = indicator; }
        if x == 6 then { chessScreen.i16 = indicator; }
        if x == 7 then { chessScreen.i17 = indicator; }
    } else if y == 2 then {
        if x == 0 then { chessScreen.i20 = indicator; }
        if x == 1 then { chessScreen.i21 = indicator; }
        if x == 2 then { chessScreen.i22 = indicator; }
        if x == 3 then { chessScreen.i23 = indicator; }
        if x == 4 then { chessScreen.i24 = indicator; }
        if x == 5 then { chessScreen.i25 = indicator; }
        if x == 6 then { chessScreen.i26 = indicator; }
        if x == 7 then { chessScreen.i27 = indicator; }
    } else if y == 3 then {
        if x == 0 then { chessScreen.i30 = indicator; }
        if x == 1 then { chessScreen.i31 = indicator; }
        if x == 2 then { chessScreen.i32 = indicator; }
        if x == 3 then { chessScreen.i33 = indicator; }
        if x == 4 then { chessScreen.i34 = indicator; }
        if x == 5 then { chessScreen.i35 = indicator; }
        if x == 6 then { chessScreen.i36 = indicator; }
        if x == 7 then { chessScreen.i37 = indicator; }
    } else if y == 4 then {
        if x == 0 then { chessScreen.i40 = indicator; }
        if x == 1 then { chessScreen.i41 = indicator; }
        if x == 2 then { chessScreen.i42 = indicator; }
        if x == 3 then { chessScreen.i43 = indicator; }
        if x == 4 then { chessScreen.i44 = indicator; }
        if x == 5 then { chessScreen.i45 = indicator; }
        if x == 6 then { chessScreen.i46 = indicator; }
        if x == 7 then { chessScreen.i47 = indicator; }
    } else if y == 5 then {
        if x == 0 then { chessScreen.i50 = indicator; }
        if x == 1 then { chessScreen.i51 = indicator; }
        if x == 2 then { chessScreen.i52 = indicator; }
        if x == 3 then { chessScreen.i53 = indicator; }
        if x == 4 then { chessScreen.i54 = indicator; }
        if x == 5 then { chessScreen.i55 = indicator; }
        if x == 6 then { chessScreen.i56 = indicator; }
        if x == 7 then { chessScreen.i57 = indicator; }
    } else if y == 6 then {
        if x == 0 then { chessScreen.i60 = indicator; }
        if x == 1 then { chessScreen.i61 = indicator; }
        if x == 2 then { chessScreen.i62 = indicator; }
        if x == 3 then { chessScreen.i63 = indicator; }
        if x == 4 then { chessScreen.i64 = indicator; }
        if x == 5 then { chessScreen.i65 = indicator; }
        if x == 6 then { chessScreen.i66 = indicator; }
        if x == 7 then { chessScreen.i67 = indicator; }
    } else if y == 7 then {
        if x == 0 then { chessScreen.i70 = indicator; }
        if x == 1 then { chessScreen.i71 = indicator; }
        if x == 2 then { chessScreen.i72 = indicator; }
        if x == 3 then { chessScreen.i73 = indicator; }
        if x == 4 then { chessScreen.i74 = indicator; }
        if x == 5 then { chessScreen.i75 = indicator; }
        if x == 6 then { chessScreen.i76 = indicator; }
        if x == 7 then { chessScreen.i77 = indicator; }
    }
}

// Set a piece image at a specific cell (used for both yellow and normal pieces)
setPieceImage(x: int, y: int, pieceImage: imagedata) {
    // Set the piece image based on position
    if y == 0 then {
        if x == 0 then { chessScreen.c00 = pieceImage; }
        if x == 1 then { chessScreen.c01 = pieceImage; }
        if x == 2 then { chessScreen.c02 = pieceImage; }
        if x == 3 then { chessScreen.c03 = pieceImage; }
        if x == 4 then { chessScreen.c04 = pieceImage; }
        if x == 5 then { chessScreen.c05 = pieceImage; }
        if x == 6 then { chessScreen.c06 = pieceImage; }
        if x == 7 then { chessScreen.c07 = pieceImage; }
    } else if y == 1 then {
        if x == 0 then { chessScreen.c10 = pieceImage; }
        if x == 1 then { chessScreen.c11 = pieceImage; }
        if x == 2 then { chessScreen.c12 = pieceImage; }
        if x == 3 then { chessScreen.c13 = pieceImage; }
        if x == 4 then { chessScreen.c14 = pieceImage; }
        if x == 5 then { chessScreen.c15 = pieceImage; }
        if x == 6 then { chessScreen.c16 = pieceImage; }
        if x == 7 then { chessScreen.c17 = pieceImage; }
    } else if y == 2 then {
        if x == 0 then { chessScreen.c20 = pieceImage; }
        if x == 1 then { chessScreen.c21 = pieceImage; }
        if x == 2 then { chessScreen.c22 = pieceImage; }
        if x == 3 then { chessScreen.c23 = pieceImage; }
        if x == 4 then { chessScreen.c24 = pieceImage; }
        if x == 5 then { chessScreen.c25 = pieceImage; }
        if x == 6 then { chessScreen.c26 = pieceImage; }
        if x == 7 then { chessScreen.c27 = pieceImage; }
    } else if y == 3 then {
        if x == 0 then { chessScreen.c30 = pieceImage; }
        if x == 1 then { chessScreen.c31 = pieceImage; }
        if x == 2 then { chessScreen.c32 = pieceImage; }
        if x == 3 then { chessScreen.c33 = pieceImage; }
        if x == 4 then { chessScreen.c34 = pieceImage; }
        if x == 5 then { chessScreen.c35 = pieceImage; }
        if x == 6 then { chessScreen.c36 = pieceImage; }
        if x == 7 then { chessScreen.c37 = pieceImage; }
    } else if y == 4 then {
        if x == 0 then { chessScreen.c40 = pieceImage; }
        if x == 1 then { chessScreen.c41 = pieceImage; }
        if x == 2 then { chessScreen.c42 = pieceImage; }
        if x == 3 then { chessScreen.c43 = pieceImage; }
        if x == 4 then { chessScreen.c44 = pieceImage; }
        if x == 5 then { chessScreen.c45 = pieceImage; }
        if x == 6 then { chessScreen.c46 = pieceImage; }
        if x == 7 then { chessScreen.c47 = pieceImage; }
    } else if y == 5 then {
        if x == 0 then { chessScreen.c50 = pieceImage; }
        if x == 1 then { chessScreen.c51 = pieceImage; }
        if x == 2 then { chessScreen.c52 = pieceImage; }
        if x == 3 then { chessScreen.c53 = pieceImage; }
        if x == 4 then { chessScreen.c54 = pieceImage; }
        if x == 5 then { chessScreen.c55 = pieceImage; }
        if x == 6 then { chessScreen.c56 = pieceImage; }
        if x == 7 then { chessScreen.c57 = pieceImage; }
    } else if y == 6 then {
        if x == 0 then { chessScreen.c60 = pieceImage; }
        if x == 1 then { chessScreen.c61 = pieceImage; }
        if x == 2 then { chessScreen.c62 = pieceImage; }
        if x == 3 then { chessScreen.c63 = pieceImage; }
        if x == 4 then { chessScreen.c64 = pieceImage; }
        if x == 5 then { chessScreen.c65 = pieceImage; }
        if x == 6 then { chessScreen.c66 = pieceImage; }
        if x == 7 then { chessScreen.c67 = pieceImage; }
    } else if y == 7 then {
        if x == 0 then { chessScreen.c70 = pieceImage; }
        if x == 1 then { chessScreen.c71 = pieceImage; }
        if x == 2 then { chessScreen.c72 = pieceImage; }
        if x == 3 then { chessScreen.c73 = pieceImage; }
        if x == 4 then { chessScreen.c74 = pieceImage; }
        if x == 5 then { chessScreen.c75 = pieceImage; }
        if x == 6 then { chessScreen.c76 = pieceImage; }
        if x == 7 then { chessScreen.c77 = pieceImage; }
    }
}

// Get chess piece letter for move notation (K, Q, R, B, N, p)
getPieceLetter(pieceType: int) return string {
    if pieceType == KING then { return "K"; }
    if pieceType == QUEEN then { return "Q"; }
    if pieceType == ROOK then { return "R"; }
    if pieceType == BISHOP then { return "B"; }
    if pieceType == KNIGHT then { return "N"; }
    if pieceType == PAWN then { return "p"; }
    return "";
}

// Get chess piece Unicode icon for move history display
getPieceIcon(pieceType: int, pieceColor: int) return string {
    // Unicode chess symbols
    // Note: In Unicode chess symbols, ♔-♙ (U+2654-2659) represent WHITE pieces
    // and ♚-♟ (U+265A-265F) represent BLACK pieces
    if pieceColor == WHITE then {
        if pieceType == KING then { return "♔"; }
        if pieceType == QUEEN then { return "♕"; }
        if pieceType == ROOK then { return "♖"; }
        if pieceType == BISHOP then { return "♗"; }
        if pieceType == KNIGHT then { return "♘"; }
        if pieceType == PAWN then { return "♙"; }
    } else {
        // BLACK pieces
        if pieceType == KING then { return "♚"; }
        if pieceType == QUEEN then { return "♛"; }
        if pieceType == ROOK then { return "♜"; }
        if pieceType == BISHOP then { return "♝"; }
        if pieceType == KNIGHT then { return "♞"; }
        if pieceType == PAWN then { return "♟"; }
    }
    return "";
}

// Convert board coordinates to algebraic notation (e.g., 0,0 -> a8, 7,7 -> h1)
coordsToAlgebraic(x: int, y: int) return string {
    var files: string = "abcdefgh";
    var file: string = call str.charAt(files, x);
    var rank: int = 8 - y;  // y=0 is rank 8, y=7 is rank 1
    return file + rank;
}

// Format a move for the move history with piece icon, from position, and to position
formatMove(fromX: int, fromY: int, toX: int, toY: int, pieceType: int, pieceColor: int, isCapture: bool, capturedPieceType: int, capturedPieceColor: int) return string {
    var pieceIcon: string = call getPieceIcon(pieceType, pieceColor);
    var pieceLetter: string = call getPieceLetter(pieceType);
    var fromSquare: string = call coordsToAlgebraic(fromX, fromY);
    var toSquare: string = call coordsToAlgebraic(toX, toY);
    
    // Format: [Icon][Letter] [from]-[to] or [from]x[to][CapturedIcon] for captures
    var moveText: string;
    
    if isCapture then {
        var capturedIcon: string = call getPieceIcon(capturedPieceType, capturedPieceColor);
        moveText = pieceIcon + pieceLetter + " " + fromSquare + "x" + toSquare + capturedIcon;
    } else {
        moveText = pieceIcon + pieceLetter + " " + fromSquare + "-" + toSquare;
    }
    
    return moveText;
}

// Select a piece (change to yellow)
selectPiece(x: int, y: int) {
    print "Selecting piece at (" + x + ", " + y + ")";
    var cellValue: int = call getPieceAt(x, y);
    if cellValue != -1 then {
        var cell = ChessCell(cellValue);
        if cell.pieceType != EMPTY then {
            var yellowPiece: imagedata = call getYellowPiece(cell.pieceType, cell.pieceColor);
            if yellowPiece != null then {
                call setPieceImage(x, y, yellowPiece);
                print "Piece turned yellow at (" + x + ", " + y + ")";
            }
        }
    }
}

// Deselect a piece (change back to normal)
deselectPiece(x: int, y: int) {
    print "Deselecting piece at (" + x + ", " + y + ")";
    var cellValue: int = call getPieceAt(x, y);
    if cellValue != -1 then {
        var cell = ChessCell(cellValue);
        if cell.pieceType != EMPTY then {
            var normalPiece: imagedata = call getNormalPiece(cell.pieceType, cell.pieceColor);
            if normalPiece != null then {
                call setPieceImage(x, y, normalPiece);
                print "Piece returned to normal at (" + x + ", " + y + ")";
            }
        }
    }
}

// Move a piece from source to destination
movePiece(fromX: int, fromY: int, toX: int, toY: int) {
    print "Moving piece from (" + fromX + ", " + fromY + ") to (" + toX + ", " + toY + ")";
    
    // Get the piece being moved
    var fromIdx: int = call boardIndex(fromY, fromX);
    var fromCellValue: int = board[fromIdx];
    var fromCell = ChessCell(fromCellValue);
    
    // Get the destination cell info
    var toIdx: int = call boardIndex(toY, toX);
    var toCellValue: int = board[toIdx];
    var toCell = ChessCell(toCellValue);
    
    // Update the board array
    // Set destination to the moved piece (preserve cell color from destination)
    board[toIdx] = call encodeCellValue(toCell.cellColor, fromCell.pieceType, fromCell.pieceColor);
    
    // Clear the source cell (keep cell color, set piece to EMPTY)
    board[fromIdx] = call encodeCellValue(fromCell.cellColor, EMPTY, WHITE);
    
    // Update the screen images
    // Get the normal piece image (not yellow) for the destination
    var pieceImage: imagedata = call getNormalPiece(fromCell.pieceType, fromCell.pieceColor);
    if pieceImage != null then {
        call setPieceImage(toX, toY, pieceImage);
    }
    
    // Clear the source cell image on screen with transparent rectangle
    call setPieceImage(fromX, fromY, transparentClear);
    
    print "Piece moved successfully";
}

// Handle cell click - select piece and show valid moves, or move piece if valid destination
handleCellClick(x: int, y: int) {
    print "Cell clicked: (" + x + ", " + y + ")";
    
    // Check if a piece is already selected
    if selectedX >= 0 && selectedY >= 0 then {
        // A piece is selected - check if clicked position is a valid move destination
        print "Checking if (" + x + ", " + y + ") is a valid move from (" + selectedX + ", " + selectedY + ")";
        
        var moves = call validMoves(selectedX, selectedY);
        var isValidMove: bool = false;
        var len: int = moves.length;
        var i: int = 0;
        
        // Check if the clicked position is in the valid moves list
        for (i = 0; i < len; i = i + 1) {
            var move = moves[i];
            if move.x == x && move.y == y then {
                isValidMove = true;
                print "Valid move found!";
            }
        }
        
        if isValidMove then {
            // Get information about the move before executing it
            var sourceCellValue: int = call getPieceAt(selectedX, selectedY);
            var destCellValue: int = call getPieceAt(x, y);
            var isCapture: bool = false;
            var capturedPieceType: int = EMPTY;
            var capturedPieceColor: int = WHITE;
            
            // Check if this is a capture move and store captured piece info
            if destCellValue != -1 then {
                var destCell = ChessCell(destCellValue);
                if destCell.pieceType != EMPTY then {
                    isCapture = true;
                    capturedPieceType = destCell.pieceType;
                    capturedPieceColor = destCell.pieceColor;
                }
            }
            
            var sourceCell = ChessCell(sourceCellValue);
            var movingPieceType: int = sourceCell.pieceType;
            var movingPieceColor: int = sourceCell.pieceColor;
            
            // Deselect the piece (turn yellow back to normal) before moving
            call deselectPiece(selectedX, selectedY);
            
            // Move the piece
            call movePiece(selectedX, selectedY, x, y);
            
            // Format and add move to history
            var moveNotation: string = call formatMove(selectedX, selectedY, x, y, movingPieceType, movingPieceColor, isCapture, capturedPieceType, capturedPieceColor);
            var playerName: string;
            if currentPlayer == WHITE then {
                playerName = "White";
            } else {
                playerName = "Black";
            }
            var moveEntry: string = playerName + ": " + moveNotation + "\n";
            chessScreen.moveHistory = chessScreen.moveHistory + moveEntry;
            print "Move added to history: " + moveEntry;
            
            // Clear indicators and selection
            call clearIndicators();
            selectedX = -1;
            selectedY = -1;
            
            // Switch to next player
            if currentPlayer == WHITE then {
                currentPlayer = BLACK;
                chessScreen.statusMessage = "Black to move";
            } else {
                currentPlayer = WHITE;
                chessScreen.statusMessage = "White to move";
            }
            call updateTimerColors();
            print "Switched to next player: " + currentPlayer;
            
            return;
        } else {
            print "Not a valid move destination - will handle as new selection";
            // Deselect the currently selected piece before processing new selection
            call deselectPiece(selectedX, selectedY);
        }
    }
    
    // Clear previous indicators
    call clearIndicators();
    
    // Get piece at clicked position
    var cellValue: int = call getPieceAt(x, y);
    print "Cell value: " + cellValue;
    
    if cellValue == -1 then {
        print "Invalid position, deselecting";
        selectedX = -1;
        selectedY = -1;
        return;
    }
    
    var cell = ChessCell(cellValue);
    print "Piece type: " + cell.pieceType + ", color: " + cell.pieceColor;
    
    // If empty cell or clicking same piece, deselect
    if cell.pieceType == EMPTY || (selectedX == x && selectedY == y) then {
        print "Empty cell or same piece clicked, deselecting";
        selectedX = -1;
        selectedY = -1;
        return;
    }
    
    // Only show valid moves for the current player's pieces
    if cell.pieceColor != currentPlayer then {
        print "Not current player's piece, ignoring";
        selectedX = -1;
        selectedY = -1;
        return;
    }
    
    // Select the piece - update state and change to yellow
    selectedX = x;
    selectedY = y;
    call selectPiece(x, y);
    print "Piece selected at (" + x + ", " + y + ")";
    
    // Get valid moves for this piece
    print "Getting valid moves...";
    var moves = call validMoves(x, y);
    var len: int = moves.length;
    print "Found " + len + " valid moves";
    
    // Show indicators for each valid move
    var i: int = 0;
    for (i = 0; i < len; i = i + 1) {
        var move = moves[i];
        print "  Move to: (" + move.x + ", " + move.y + ")";
        
        // Check if this move captures an enemy piece
        var targetCellValue: int = call getPieceAt(move.x, move.y);
        var isCapture: bool = false;
        
        if targetCellValue != -1 then {
            var targetCell = ChessCell(targetCellValue);
            if targetCell.pieceType != EMPTY then {
                isCapture = true;
                print "    (capture move)";
            }
        }
        
        // Set the indicator
        print "  Setting indicator at (" + move.x + ", " + move.y + ")";
        call setIndicator(move.x, move.y, isCapture);
    }
    
    print "handleCellClick complete";
}

encodeCellValue(cellColor: int, pieceType: int, pieceColor: int) return int {
    return cellColor + (pieceType * 2) + (pieceColor * 128);
}

getPieceSymbol(cellValue: int) return string {
    var cell = ChessCell(cellValue);
    var pt: int = cell.pieceType;
    var pc: int = cell.pieceColor;
    
    if pt == 0 then {
        return "";
    }
    
    if pc == 0 then {
        return whitePieces[pt];
    } else {
        return blackPieces[pt];
    }
}

formatTimer(seconds: int) return string {
    // Check if unlimited time
    if seconds >= UNLIMITED_TIME then {
        return "Unlimited";
    }
    
    var mins: int = seconds / 60;
    var secs: int = call modulo(seconds, 60);
    var minsStr: string = call str.lpad(string(mins), 2, "0");
    var secsStr: string = call str.lpad(string(secs), 2, "0");
    return minsStr + ":" + secsStr;
}

// Format timer with decimal places (for display with tenths of seconds)
formatTimerDecimal(deciseconds: int) return string {
    // Check if unlimited time (deciseconds would be >= UNLIMITED_TIME * 10)
    if deciseconds >= UNLIMITED_TIME * 10 then {
        return "Unlimited";
    }
    
    var totalSeconds: int = deciseconds / 10;
    var tenths: int = call modulo(deciseconds, 10);
    var mins: int = totalSeconds / 60;
    var secs: int = call modulo(totalSeconds, 60);
    var minsStr: string = call str.lpad(string(mins), 2, "0");
    var secsStr: string = call str.lpad(string(secs), 2, "0");
    return minsStr + ":" + secsStr + "." + tenths;
}

// Timer callback function - called every 100ms (0.1 seconds)
// Note: This callback is already executed on JavaFX Platform.runLater by thread.timerStart
timerCallback(timerName: string) {
    // Only update if game has started - exit early if not
    if !gameStarted then {
        return;
    }
    
    // Decrement the active player's timer by 1 decisecond (0.1 seconds)
    if currentPlayer == 0 then {
        // White's turn
        if timerWhite > 0 then {
            timerWhite = timerWhite - 1;
            var timerText: string = call formatTimerDecimal(timerWhite);
            
            // Update screen variable which is bound to the label via varRef
            chessScreen.whiteTimer = timerText;
            
            // Debug: Print every 10 deciseconds (1 second)
            if call modulo(timerWhite, 10) == 0 then {
                print "Timer: White " + timerText + " | Screen updated via variable binding";
            }
        }
    } else {
        // Black's turn
        if timerBlack > 0 then {
            timerBlack = timerBlack - 1;
            var timerText: string = call formatTimerDecimal(timerBlack);
            
            // Update screen variable which is bound to the label via varRef
            chessScreen.blackTimer = timerText;
            
            // Debug: Print every 10 deciseconds (1 second)
            if call modulo(timerBlack, 10) == 0 then {
                print "Timer: Black " + timerText + " | Screen updated via variable binding";
            }
        }
    }
}

initializeBoard() {
    var row: int = 0;
    var col: int = 0;
    var idx: int = 0;
    
    // Initialize all cells with proper colors
    for (row = 0; row < 8; row++) {
        for (col = 0; col < 8; col++) {
            var cellColor: int = call modulo(row + col, 2);
            idx = call boardIndex(row, col);
            board[idx] = call encodeCellValue(cellColor, EMPTY, WHITE);
        }
    }
    
    // Place black pieces (row 0 and 1)
    board[call boardIndex(0, 0)] = call encodeCellValue(0, ROOK, BLACK);
    board[call boardIndex(0, 1)] = call encodeCellValue(1, KNIGHT, BLACK);
    board[call boardIndex(0, 2)] = call encodeCellValue(0, BISHOP, BLACK);
    board[call boardIndex(0, 3)] = call encodeCellValue(1, QUEEN, BLACK);
    board[call boardIndex(0, 4)] = call encodeCellValue(0, KING, BLACK);
    board[call boardIndex(0, 5)] = call encodeCellValue(1, BISHOP, BLACK);
    board[call boardIndex(0, 6)] = call encodeCellValue(0, KNIGHT, BLACK);
    board[call boardIndex(0, 7)] = call encodeCellValue(1, ROOK, BLACK);
    
    // Row 1: Black pawns
    for (col = 0; col < 8; col++) {
        var cellColor: int = call modulo(1 + col, 2);
        idx = call boardIndex(1, col);
        board[idx] = call encodeCellValue(cellColor, PAWN, BLACK);
    }
    
    // Row 6: White pawns
    for (col = 0; col < 8; col++) {
        var cellColor: int = call modulo(6 + col, 2);
        idx = call boardIndex(6, col);
        board[idx] = call encodeCellValue(cellColor, PAWN, WHITE);
    }
    
    // Place white pieces (row 7)
    board[call boardIndex(7, 0)] = call encodeCellValue(1, ROOK, WHITE);
    board[call boardIndex(7, 1)] = call encodeCellValue(0, KNIGHT, WHITE);
    board[call boardIndex(7, 2)] = call encodeCellValue(1, BISHOP, WHITE);
    board[call boardIndex(7, 3)] = call encodeCellValue(0, QUEEN, WHITE);
    board[call boardIndex(7, 4)] = call encodeCellValue(1, KING, WHITE);
    board[call boardIndex(7, 5)] = call encodeCellValue(0, BISHOP, WHITE);
    board[call boardIndex(7, 6)] = call encodeCellValue(1, KNIGHT, WHITE);
    board[call boardIndex(7, 7)] = call encodeCellValue(0, ROOK, WHITE);
    
    // Initialize pieces array with starting positions
    // Piece codes: K=King, Q=Queen, R=Rook, B=Bishop, N=Knight, P=Pawn
    // Color codes: W=White, B=Black
    
    // Black back row (row 0)
    pieces[0] = ChessPiece { piece: "R", color: "B", pos: posType { x: 0, y: 0 } };
    pieces[1] = ChessPiece { piece: "N", color: "B", pos: posType { x: 1, y: 0 } };
    pieces[2] = ChessPiece { piece: "B", color: "B", pos: posType { x: 2, y: 0 } };
    pieces[3] = ChessPiece { piece: "Q", color: "B", pos: posType { x: 3, y: 0 } };
    pieces[4] = ChessPiece { piece: "K", color: "B", pos: posType { x: 4, y: 0 } };
    pieces[5] = ChessPiece { piece: "B", color: "B", pos: posType { x: 5, y: 0 } };
    pieces[6] = ChessPiece { piece: "N", color: "B", pos: posType { x: 6, y: 0 } };
    pieces[7] = ChessPiece { piece: "R", color: "B", pos: posType { x: 7, y: 0 } };
    
    // Black pawns (row 1)
    pieces[8] = ChessPiece { piece: "P", color: "B", pos: posType { x: 0, y: 1 } };
    pieces[9] = ChessPiece { piece: "P", color: "B", pos: posType { x: 1, y: 1 } };
    pieces[10] = ChessPiece { piece: "P", color: "B", pos: posType { x: 2, y: 1 } };
    pieces[11] = ChessPiece { piece: "P", color: "B", pos: posType { x: 3, y: 1 } };
    pieces[12] = ChessPiece { piece: "P", color: "B", pos: posType { x: 4, y: 1 } };
    pieces[13] = ChessPiece { piece: "P", color: "B", pos: posType { x: 5, y: 1 } };
    pieces[14] = ChessPiece { piece: "P", color: "B", pos: posType { x: 6, y: 1 } };
    pieces[15] = ChessPiece { piece: "P", color: "B", pos: posType { x: 7, y: 1 } };
    
    // White pawns (row 6)
    pieces[16] = ChessPiece { piece: "P", color: "W", pos: posType { x: 0, y: 6 } };
    pieces[17] = ChessPiece { piece: "P", color: "W", pos: posType { x: 1, y: 6 } };
    pieces[18] = ChessPiece { piece: "P", color: "W", pos: posType { x: 2, y: 6 } };
    pieces[19] = ChessPiece { piece: "P", color: "W", pos: posType { x: 3, y: 6 } };
    pieces[20] = ChessPiece { piece: "P", color: "W", pos: posType { x: 4, y: 6 } };
    pieces[21] = ChessPiece { piece: "P", color: "W", pos: posType { x: 5, y: 6 } };
    pieces[22] = ChessPiece { piece: "P", color: "W", pos: posType { x: 6, y: 6 } };
    pieces[23] = ChessPiece { piece: "P", color: "W", pos: posType { x: 7, y: 6 } };
    
    // White back row (row 7)
    pieces[24] = ChessPiece { piece: "R", color: "W", pos: posType { x: 0, y: 7 } };
    pieces[25] = ChessPiece { piece: "N", color: "W", pos: posType { x: 1, y: 7 } };
    pieces[26] = ChessPiece { piece: "B", color: "W", pos: posType { x: 2, y: 7 } };
    pieces[27] = ChessPiece { piece: "Q", color: "W", pos: posType { x: 3, y: 7 } };
    pieces[28] = ChessPiece { piece: "K", color: "W", pos: posType { x: 4, y: 7 } };
    pieces[29] = ChessPiece { piece: "B", color: "W", pos: posType { x: 5, y: 7 } };
    pieces[30] = ChessPiece { piece: "N", color: "W", pos: posType { x: 6, y: 7 } };
    pieces[31] = ChessPiece { piece: "R", color: "W", pos: posType { x: 7, y: 7 } };
}

getBoardRow(rowNum: int) return string {
    var result: string = "";
    var col: int = 0;
    var idx: int = 0;
    
    for (col = 0; col < 8; col++) {
        idx = call boardIndex(rowNum, col);
        var cellValue: int = board[idx];
        var cell = ChessCell(cellValue);
        var cellColor: int = cell.cellColor;
        var piece: string = call getPieceSymbol(cellValue);
        
        if piece == "" then {
            if cellColor == 0 then {
                result = result + " . ";
            } else {
                result = result + " # ";
            }
        } else {
            result = result + " " + piece + " ";
        }
        
        if col < 7 then {
            result = result + "|";
        }
    }
    
    return result;
}

printBoard() {
    print "";
    print "   Chess Board";
    print "   ===========";
    print "";
    
    var whiteTimerStr: string = call formatTimerDecimal(timerWhite);
    var blackTimerStr: string = call formatTimerDecimal(timerBlack);
    var currentPlayerStr: string;
    if currentPlayer == 0 then {
        currentPlayerStr = "White";
    } else {
        currentPlayerStr = "Black";
    }
    
    print "   Timer: White " + whiteTimerStr + " | Black " + blackTimerStr;
    print "   Current Turn: " + currentPlayerStr;
    print "";
    
    print "     a   b   c   d   e   f   g   h";
    print "   +---+---+---+---+---+---+---+---+";
    
    var row: int = 0;
    for (row = 0; row < 8; row++) {
        var rowLabel: int = 8 - row;
        var rowStr: string = call getBoardRow(row);
        print " " + rowLabel + " |" + rowStr + "| " + rowLabel;
        print "   +---+---+---+---+---+---+---+---+";
    }
    
    print "     a   b   c   d   e   f   g   h";
    print "";
}

// Variable to store game start status
var gameStarted: bool = false;

// Variable to store selected game mode
var selectedGameMode: string = "2 player";

// Variable to store selected time limit
var selectedTimeLimit: string = "Unlimited";

// Constant for unlimited time (in seconds)
var UNLIMITED_TIME: int = 99999;

// Update timer colors based on current player
updateTimerColors() {
    if currentPlayer == 0 then {
        // White's turn - white is active, black is inactive
        call scr.setproperty("chessScreen.whiteLabelTimer", "textColor", COLOR_LABEL_ACTIVE);
        call scr.setproperty("chessScreen.whiteTimerField", "textColor", COLOR_TIMER_ACTIVE);
        call scr.setproperty("chessScreen.blackLabelTimer", "textColor", COLOR_LABEL_INACTIVE);
        call scr.setproperty("chessScreen.blackTimerField", "textColor", COLOR_TIMER_INACTIVE);
    } else {
        // Black's turn - black is active, white is inactive
        call scr.setproperty("chessScreen.whiteLabelTimer", "textColor", COLOR_LABEL_INACTIVE);
        call scr.setproperty("chessScreen.whiteTimerField", "textColor", COLOR_TIMER_INACTIVE);
        call scr.setproperty("chessScreen.blackLabelTimer", "textColor", COLOR_LABEL_ACTIVE);
        call scr.setproperty("chessScreen.blackTimerField", "textColor", COLOR_TIMER_ACTIVE);
    }
}

// Convert time limit string to seconds
getTimeLimitInDeciseconds(timeLimit: string) return int {
    // Return time in deciseconds (10ths of a second)
    if timeLimit == "10 minutes" then {
        return 6000;  // 600 seconds * 10
    } else if timeLimit == "15 minutes" then {
        return 9000;  // 900 seconds * 10
    } else if timeLimit == "20 minutes" then {
        return 12000;  // 1200 seconds * 10
    } else if timeLimit == "30 minutes" then {
        return 18000;  // 1800 seconds * 10
    } else if timeLimit == "60 minutes" then {
        return 36000;  // 3600 seconds * 10
    } else if timeLimit == "Unlimited" then {
        return UNLIMITED_TIME * 10;
    } else {
        return 6000;  // Default to 10 minutes
    }
}

// Handle Start button click from startup dialog
handleStartGame() {
    print "Start button clicked!";
    
    // Determine game mode from radio button
    // The gameMode variable stores "1" or "2"
    if startupDialog.gameMode == "1" then {
        selectedGameMode = "1 player";
    } else {
        selectedGameMode = "2 player";
    }
    
    selectedTimeLimit = startupDialog.timeLimit;
    print "Selected game mode: " + selectedGameMode;
    print "Selected time limit: " + selectedTimeLimit;
    
    // Set the timer values based on selection (in deciseconds)
    var timeInDeciseconds: int = call getTimeLimitInDeciseconds(selectedTimeLimit);
    timerWhite = timeInDeciseconds;
    timerBlack = timeInDeciseconds;
    
    gameStarted = true;
    
    // Close the startup dialog
    hide screen startupDialog;
    
    print "Starting chess game - Mode: " + selectedGameMode + ", Timer: " + selectedTimeLimit;
    print "";
    print "Initializing chess board...";
    
    call initializeBoard();
    call printBoard();
    
    // Create board layer and indicator images
    print "Creating board layer images...";
    call createBoardLayer();
    
    print "Creating move indicator images...";
    call createIndicators();
    
    print "";
    print "Board Encoding Information:";
    print "===========================";
    print "Each cell uses a bitmap byte:";
    print "  Bit 0: Cell color (0=light, 1=dark)";
    print "  Bits 1-6: Piece type (0=empty, 1-6=piece)";
    print "  Bit 7: Piece color (0=white, 1=black)";
    print "";
    
    print "Sample cell values:";
    var idx00: int = call boardIndex(0, 0);
    var sampleCell = ChessCell(board[idx00]);
    print "  [0,0] Black Rook: raw=" + board[idx00] + ", cellColor=" + sampleCell.cellColor + ", pieceType=" + sampleCell.pieceType + ", pieceColor=" + sampleCell.pieceColor;
    
    var idx74: int = call boardIndex(7, 4);
    sampleCell = ChessCell(board[idx74]);
    print "  [7,4] White King: raw=" + board[idx74] + ", cellColor=" + sampleCell.cellColor + ", pieceType=" + sampleCell.pieceType + ", pieceColor=" + sampleCell.pieceColor;
    
    print "";
    print "Loading chess piece SVG images...";
    
    // Load SVG images for pieces - Row 0 (black back row)
    chessScreen.c00 = call image.load(imgPath + "black_rook.svg");
    chessScreen.c01 = call image.load(imgPath + "black_knight.svg");
    chessScreen.c02 = call image.load(imgPath + "black_bishop.svg");
    chessScreen.c03 = call image.load(imgPath + "black_queen.svg");
    chessScreen.c04 = call image.load(imgPath + "black_king.svg");
    chessScreen.c05 = call image.load(imgPath + "black_bishop.svg");
    chessScreen.c06 = call image.load(imgPath + "black_knight.svg");
    chessScreen.c07 = call image.load(imgPath + "black_rook.svg");
    
    // Load SVG images for pieces - Row 1 (black pawns)
    chessScreen.c10 = call image.load(imgPath + "black_pawn.svg");
    chessScreen.c11 = call image.load(imgPath + "black_pawn.svg");
    chessScreen.c12 = call image.load(imgPath + "black_pawn.svg");
    chessScreen.c13 = call image.load(imgPath + "black_pawn.svg");
    chessScreen.c14 = call image.load(imgPath + "black_pawn.svg");
    chessScreen.c15 = call image.load(imgPath + "black_pawn.svg");
    chessScreen.c16 = call image.load(imgPath + "black_pawn.svg");
    chessScreen.c17 = call image.load(imgPath + "black_pawn.svg");
    
    // Load SVG images for pieces - Row 6 (white pawns)
    chessScreen.c60 = call image.load(imgPath + "white_pawn.svg");
    chessScreen.c61 = call image.load(imgPath + "white_pawn.svg");
    chessScreen.c62 = call image.load(imgPath + "white_pawn.svg");
    chessScreen.c63 = call image.load(imgPath + "white_pawn.svg");
    chessScreen.c64 = call image.load(imgPath + "white_pawn.svg");
    chessScreen.c65 = call image.load(imgPath + "white_pawn.svg");
    chessScreen.c66 = call image.load(imgPath + "white_pawn.svg");
    chessScreen.c67 = call image.load(imgPath + "white_pawn.svg");
    
    // Load SVG images for pieces - Row 7 (white back row)
    chessScreen.c70 = call image.load(imgPath + "white_rook.svg");
    chessScreen.c71 = call image.load(imgPath + "white_knight.svg");
    chessScreen.c72 = call image.load(imgPath + "white_bishop.svg");
    chessScreen.c73 = call image.load(imgPath + "white_queen.svg");
    chessScreen.c74 = call image.load(imgPath + "white_king.svg");
    chessScreen.c75 = call image.load(imgPath + "white_bishop.svg");
    chessScreen.c76 = call image.load(imgPath + "white_knight.svg");
    chessScreen.c77 = call image.load(imgPath + "white_rook.svg");
    
    print "Chess piece images loaded!";
    print "";
    print "Initializing board layer (checkerboard pattern)...";
    
    // Initialize all 64 board squares with the correct checkerboard pattern
    // Note: Manual assignment is used because EBS screen variables (chessScreen.b##)
    // cannot be accessed dynamically via computed names. While verbose, this approach
    // ensures correct checkerboard pattern: light on (row+col)%2==0, dark on (row+col)%2==1
    // Row 0 (board row 8)
    chessScreen.b00 = lightSquare; chessScreen.b01 = darkSquare; chessScreen.b02 = lightSquare; chessScreen.b03 = darkSquare;
    chessScreen.b04 = lightSquare; chessScreen.b05 = darkSquare; chessScreen.b06 = lightSquare; chessScreen.b07 = darkSquare;
    
    // Row 1 (board row 7)
    chessScreen.b10 = darkSquare; chessScreen.b11 = lightSquare; chessScreen.b12 = darkSquare; chessScreen.b13 = lightSquare;
    chessScreen.b14 = darkSquare; chessScreen.b15 = lightSquare; chessScreen.b16 = darkSquare; chessScreen.b17 = lightSquare;
    
    // Row 2 (board row 6)
    chessScreen.b20 = lightSquare; chessScreen.b21 = darkSquare; chessScreen.b22 = lightSquare; chessScreen.b23 = darkSquare;
    chessScreen.b24 = lightSquare; chessScreen.b25 = darkSquare; chessScreen.b26 = lightSquare; chessScreen.b27 = darkSquare;
    
    // Row 3 (board row 5)
    chessScreen.b30 = darkSquare; chessScreen.b31 = lightSquare; chessScreen.b32 = darkSquare; chessScreen.b33 = lightSquare;
    chessScreen.b34 = darkSquare; chessScreen.b35 = lightSquare; chessScreen.b36 = darkSquare; chessScreen.b37 = lightSquare;
    
    // Row 4 (board row 4)
    chessScreen.b40 = lightSquare; chessScreen.b41 = darkSquare; chessScreen.b42 = lightSquare; chessScreen.b43 = darkSquare;
    chessScreen.b44 = lightSquare; chessScreen.b45 = darkSquare; chessScreen.b46 = lightSquare; chessScreen.b47 = darkSquare;
    
    // Row 5 (board row 3)
    chessScreen.b50 = darkSquare; chessScreen.b51 = lightSquare; chessScreen.b52 = darkSquare; chessScreen.b53 = lightSquare;
    chessScreen.b54 = darkSquare; chessScreen.b55 = lightSquare; chessScreen.b56 = darkSquare; chessScreen.b57 = lightSquare;
    
    // Row 6 (board row 2)
    chessScreen.b60 = lightSquare; chessScreen.b61 = darkSquare; chessScreen.b62 = lightSquare; chessScreen.b63 = darkSquare;
    chessScreen.b64 = lightSquare; chessScreen.b65 = darkSquare; chessScreen.b66 = lightSquare; chessScreen.b67 = darkSquare;
    
    // Row 7 (board row 1)
    chessScreen.b70 = darkSquare; chessScreen.b71 = lightSquare; chessScreen.b72 = darkSquare; chessScreen.b73 = lightSquare;
    chessScreen.b74 = darkSquare; chessScreen.b75 = lightSquare; chessScreen.b76 = darkSquare; chessScreen.b77 = lightSquare;
    
    print "Board layer initialized!";
    print "";
    print "Opening chess screen with graphical grid display...";
    
    // Update screen variables before showing
    chessScreen.whiteTimer = call formatTimerDecimal(timerWhite);
    chessScreen.blackTimer = call formatTimerDecimal(timerBlack);
    chessScreen.statusMessage = "White to move";
    call updateTimerColors();
    
    // Show the chess screen
    show screen chessScreen;
    
    // Timer display is automatically updated via varRef binding to whiteTimer and blackTimer variables
    
    // Start the game timer (updates every 100ms = 0.1 seconds)
    call thread.timerStart("chessTimer", 100, "timerCallback");
    
    print "";
    print "Chess screen is now displayed!";
    print "Use the New Game button to reset the board.";
}

// Handle Exit button click from startup dialog
handleExitGame() {
    print "=== handleExitGame() EXECUTED ===";
    print "Exit button clicked!";
    print "Stopping game timer...";
    gameStarted = false;
    
    // Stop the timer if it's running
    call thread.timerStop("chessTimer");
    print "Timer stopped.";
    
    // Close the startup dialog
    hide screen startupDialog;
    print "Startup dialog closed.";
    print "=== handleExitGame() COMPLETE ===";
    print "";
    
    print "Game cancelled.";
}

