// Import chess move calculation functions
import "chess-moves.ebs";

// EBS Chess Game Application
// ===========================
// This script demonstrates using the array.bitmap type for efficient chess board encoding.
//
// Board Encoding:
//   - Uses array.bitmap[64] to store 8x8 chess board
//   - Each cell encoded as a bitmap byte:
//     * Bit 0: Cell color (0=light, 1=dark) - for checkerboard pattern
//     * Bits 1-6: Piece type (0=empty, 1=pawn, 2=rook, 3=knight, 4=bishop, 5=queen, 6=king)
//     * Bit 7: Piece color (0=white, 1=black)
//
// Features:
//   - Console display with Unicode chess symbols
//   - Graphical JavaFX GridPane chess board with SVG piece images
//   - Row labels (1-8) and column labels (a-h)
//   - Timer display for both players
//   - New Game button to reset the board
//
// Usage:
//   Run in EBS Console: /open scripts/app/chess.ebs then Ctrl+Enter


// Define chess piece record type with piece name, color, and position
// Piece codes: K=King, Q=Queen, R=Rook, B=Bishop, N=Knight, P=Pawn
// Color codes: W=White, B=Black
ChessPiece typeof record { piece: string, color: string, pos: posType };

// Array of all 32 chess pieces with their starting positions
var pieces: ChessPiece[32];

// Piece type constants
var EMPTY: int = 0;
var PAWN: int = 1;
var ROOK: int = 2;
var KNIGHT: int = 3;
var BISHOP: int = 4;
var QUEEN: int = 5;
var KING: int = 6;

// Piece color constants
var WHITE: int = 0;
var BLACK: int = 1;

// UI Color scheme - Named colors for easy customization via config screen
var COLOR_BG_MAIN: string = "#2c2c2c";           // Main background - dark gray
var COLOR_BG_TIMER: string = "#3c3c3c";          // Timer area background - medium dark gray
var COLOR_BG_BOARD: string = "#654321";          // Board container background - brown
var COLOR_CELL_LIGHT: string = "#f0d9b5";        // Light chess squares - light wood (beige)
var COLOR_CELL_DARK: string = "#b58863";         // Dark chess squares - dark wood (brown)
var COLOR_TEXT_WHITE: string = "#ffffff";        // White text - for labels on dark backgrounds
var COLOR_TEXT_RULER: string = "#ffcc00";        // Ruler text (a-h, 1-8) - bright gold for high contrast
var COLOR_TEXT_SEPARATOR: string = "#cccccc";    // Separator text - light gray (improved from #666666)
var COLOR_TEXT_TIMER_LABEL: string = "#ffff00";  // Timer label text - bright yellow
var COLOR_TIMER_WHITE: string = "#00ff00";       // White player timer - bright green
var COLOR_TIMER_BLACK: string = "#ff6600";       // Black player timer - orange
var COLOR_TIMER_ACTIVE: string = "#ffff00";      // Active player timer - bright yellow
var COLOR_TIMER_INACTIVE: string = "#888888";    // Inactive player timer - light gray
var COLOR_LABEL_ACTIVE: string = "#ffff00";      // Active player label - bright yellow
var COLOR_LABEL_INACTIVE: string = "#888888";    // Inactive player label - light gray
var COLOR_BUTTON_NEW_GAME: string = "#ffff00";   // New Game button - yellow
var COLOR_MOVE_HISTORY_BG: string = "#ffffff";   // Move history background - white
var COLOR_MOVE_HISTORY_TEXT: string = "#000000"; // Move history text color - black

// Chess piece Unicode symbols (for console display)
var whitePieces: string[7];
whitePieces[0] = "";        // Empty
whitePieces[1] = "\u2659";  // White Pawn
whitePieces[2] = "\u2656";  // White Rook
whitePieces[3] = "\u2658";  // White Knight
whitePieces[4] = "\u2657";  // White Bishop
whitePieces[5] = "\u2655";  // White Queen
whitePieces[6] = "\u2654";  // White King

var blackPieces: string[7];
blackPieces[0] = "";        // Empty
blackPieces[1] = "\u265F";  // Black Pawn
blackPieces[2] = "\u265C";  // Black Rook
blackPieces[3] = "\u265E";  // Black Knight
blackPieces[4] = "\u265D";  // Black Bishop
blackPieces[5] = "\u265B";  // Black Queen
blackPieces[6] = "\u265A";  // Black King

// Image path base for SVG chess pieces
// Path relative to ScriptInterpreter directory (working directory when script runs)
var imgPath: string = "src/main/resources/images/chess/";

// Create the chess board using array.bitmap for bitmap-encoded cell data (8x8 = 64 elements)
var board: array.bitmap[64];

// Timer variables (now in deciseconds - 10ths of a second)
var timerWhite: int = 6000;  // 600 seconds = 6000 deciseconds
var timerBlack: int = 6000;  // 600 seconds = 6000 deciseconds
var initialTimerValue: int = 6000;  // Store initial timer value to calculate elapsed time
var currentPlayer: int = 0;

// Selection and move indication variables
var selectedX: int = -1;  // -1 means no selection
var selectedY: int = -1;
var greenIndicator: imagedata;  // Green circle for valid moves
var redIndicator: imagedata;    // Red circle for capture moves
var yellowCircleIndicator: imagedata; // Yellow circle for moves that check opponent's king
var orangeCircleIndicator: imagedata; // Orange circle for moves that capture AND check
var redCrossIndicator: imagedata;     // Red cross for invalid moves (expose own king)
var redCrossBigIndicator: imagedata;  // Larger red cross for checkmate
var transparentClear: imagedata; // Transparent rectangle for clearing piece positions
var blueCircleIndicator: imagedata; // Blue circle for showing last move endpoints
var purpleCircleIndicator: imagedata; // Purple circle for showing piece defenders
var blueArrowRight: imagedata;  // Blue arrow pointing right
var blueArrowLeft: imagedata;   // Blue arrow pointing left
var blueArrowUp: imagedata;     // Blue arrow pointing up
var blueArrowDown: imagedata;   // Blue arrow pointing down
var blueArrowUpRight: imagedata;   // Blue arrow pointing up-right (diagonal)
var blueArrowUpLeft: imagedata;    // Blue arrow pointing up-left (diagonal)
var blueArrowDownRight: imagedata; // Blue arrow pointing down-right (diagonal)
var blueArrowDownLeft: imagedata;  // Blue arrow pointing down-left (diagonal)
var blueLShapeUpRight: imagedata;  // Blue L-shaped arrow (up then right, 90-degree angle)
var blueLShapeUpLeft: imagedata;   // Blue L-shaped arrow (up then left, 90-degree angle)
var blueLShapeDownRight: imagedata; // Blue L-shaped arrow (down then right, 90-degree angle)
var blueLShapeDownLeft: imagedata;  // Blue L-shaped arrow (down then left, 90-degree angle)
var blueLShapeRightUp: imagedata;  // Blue L-shaped arrow (right then up, 90-degree angle)
var blueLShapeRightDown: imagedata; // Blue L-shaped arrow (right then down, 90-degree angle)
var blueLShapeLeftUp: imagedata;   // Blue L-shaped arrow (left then up, 90-degree angle)
var blueLShapeLeftDown: imagedata;  // Blue L-shaped arrow (left then down, 90-degree angle)

// Game state tracking
var gameOver: bool = false;  // Track if game has ended
var lastMoveFromX: int = -1;  // Last move start X position
var lastMoveFromY: int = -1;  // Last move start Y position
var lastMoveToX: int = -1;    // Last move end X position
var lastMoveToY: int = -1;    // Last move end Y position
var arrowPathX: int[64];      // X coordinates of cells with arrow indicators
var arrowPathY: int[64];      // Y coordinates of cells with arrow indicators
var arrowPathCount: int = 0;  // Number of cells in the arrow path

// Castling tracking variables
var whiteKingMoved: bool = false;
var blackKingMoved: bool = false;
var whiteKingsideRookMoved: bool = false;  // Rook at h1 (x=7, y=7)
var whiteQueensideRookMoved: bool = false; // Rook at a1 (x=0, y=7)
var blackKingsideRookMoved: bool = false;  // Rook at h8 (x=7, y=0)
var blackQueensideRookMoved: bool = false; // Rook at a8 (x=0, y=0)

// En passant tracking variables
// Stores the position of a pawn that just moved two squares (can be captured en passant)
var enPassantTargetX: int = -1;  // X coordinate of pawn that can be captured en passant (-1 = no en passant available)
var enPassantTargetY: int = -1;  // Y coordinate of pawn that can be captured en passant

// Opponent piece selection tracking (for defender visualization)
var lastOpponentX: int = -1;  // X coordinate of last opponent piece clicked (-1 = none)
var lastOpponentY: int = -1;  // Y coordinate of last opponent piece clicked

// Captured pieces tracking - stores piece type for each captured piece
// White pieces captured by black (shown on left side)
var capturedWhitePieces: int[16];  // Max 16 pieces per color
var capturedWhiteCount: int = 0;
// Black pieces captured by white (shown on right side)
var capturedBlackPieces: int[16];  // Max 16 pieces per color
var capturedBlackCount: int = 0;

// Undo/Redo functionality for 2-player games
// Store board states as separate variables (workaround for array limitations)
var undoBoard0: array.bitmap[64];
var undoBoard1: array.bitmap[64];
var undoBoard2: array.bitmap[64];
var undoBoard3: array.bitmap[64];
var undoBoard4: array.bitmap[64];
var undoBoard5: array.bitmap[64];
var undoBoard6: array.bitmap[64];
var undoBoard7: array.bitmap[64];
var undoBoard8: array.bitmap[64];
var undoBoard9: array.bitmap[64];

var redoBoard0: array.bitmap[64];
var redoBoard1: array.bitmap[64];
var redoBoard2: array.bitmap[64];
var redoBoard3: array.bitmap[64];
var redoBoard4: array.bitmap[64];
var redoBoard5: array.bitmap[64];
var redoBoard6: array.bitmap[64];
var redoBoard7: array.bitmap[64];
var redoBoard8: array.bitmap[64];
var redoBoard9: array.bitmap[64];

// Other state arrays (max 10 moves for undo/redo)
var undoStackCurrentPlayer: int[10];
var undoStackTimerWhite: int[10];
var undoStackTimerBlack: int[10];
var undoStackWhiteKingMoved: bool[10];
var undoStackBlackKingMoved: bool[10];
var undoStackWhiteKingsideRookMoved: bool[10];
var undoStackWhiteQueensideRookMoved: bool[10];
var undoStackBlackKingsideRookMoved: bool[10];
var undoStackBlackQueensideRookMoved: bool[10];
var undoStackEnPassantTargetX: int[10];
var undoStackEnPassantTargetY: int[10];
var undoStackCapturedWhiteCount: int[10];
var undoStackCapturedBlackCount: int[10];
var undoStackMoveHistory: string[10];
var undoStackLastMoveFromX: int[10];
var undoStackLastMoveFromY: int[10];
var undoStackLastMoveToX: int[10];
var undoStackLastMoveToY: int[10];
// Captured pieces stored as comma-separated strings (e.g., "1,2,3" for pawn, rook, knight)
var undoStackCapturedWhitePieces: string[10];
var undoStackCapturedBlackPieces: string[10];
var undoStackCount: int = 0;

// Redo stacks (same structure as undo)
var redoStackCurrentPlayer: int[10];
var redoStackTimerWhite: int[10];
var redoStackTimerBlack: int[10];
var redoStackWhiteKingMoved: bool[10];
var redoStackBlackKingMoved: bool[10];
var redoStackWhiteKingsideRookMoved: bool[10];
var redoStackWhiteQueensideRookMoved: bool[10];
var redoStackBlackKingsideRookMoved: bool[10];
var redoStackBlackQueensideRookMoved: bool[10];
var redoStackEnPassantTargetX: int[10];
var redoStackEnPassantTargetY: int[10];
var redoStackCapturedWhiteCount: int[10];
var redoStackCapturedBlackCount: int[10];
var redoStackMoveHistory: string[10];
var redoStackLastMoveFromX: int[10];
var redoStackLastMoveFromY: int[10];
var redoStackLastMoveToX: int[10];
var redoStackLastMoveToY: int[10];
var redoStackCapturedWhitePieces: string[10];
var redoStackCapturedBlackPieces: string[10];
var redoStackCount: int = 0;

// Board layer images (bottom layer - checkerboard)
var lightSquare: imagedata;     // Light square for board
var darkSquare: imagedata;      // Dark square for board

// Piece image arrays - indexed by piece type (0=empty, 1=pawn, 2=rook, 3=knight, 4=bishop, 5=queen, 6=king)
// Normal (original) piece images - stored for restoring after deselection
var normalWhitePieces: imagedata[7];  // [0]=empty, [1]=pawn, [2]=rook, [3]=knight, [4]=bishop, [5]=queen, [6]=king
var normalBlackPieces: imagedata[7];

// Yellow piece images - used when a piece is selected/clicked
var yellowWhitePieces: imagedata[7];
var yellowBlackPieces: imagedata[7];

// Helper functions
boardIndex(row: int, col: int) return int {
    return row * 8 + col;
}

modulo(a: int, b: int) return int {
    var q: int = a / b;
    return a - (q * b);
}

// Check if a position is within board bounds
isValidPosition(x: int, y: int) return bool {
    return x >= 0 && x < 8 && y >= 0 && y < 8;
}

// Get piece information at a given position (x, y coordinates)
function getPieceAt(x: int, y: int) return int {
    if call isValidPosition(x, y) then {
        var idx: int = call boardIndex(y, x);
        var cellValue: int = board[idx];
        return cellValue;
    } else {
        return -1;
    }
}

// Check if position is occupied by a piece of the given color
function isOccupiedByColor(x: int, y: int, color: int) return bool {
    var cellValue: int = call getPieceAt(x, y);
    if cellValue == -1 then {
        return false;
    }
    var cell = ChessCell(cellValue);
    return cell.pieceType != EMPTY && cell.pieceColor == color;
}

// Get the normal (original) version of a piece image based on piece type and color
function getNormalPiece(pieceType: int, pieceColor: int) return imagedata {
    // Use array indexing for O(1) lookup instead of if-else chain
    // For EMPTY (pieceType=0) or invalid types, return transparentClear
    if pieceType == EMPTY || pieceType < 0 || pieceType > 6 then {
        return transparentClear;
    }
    
    if pieceColor == WHITE then {
        return normalWhitePieces[pieceType];
    } else {
        return normalBlackPieces[pieceType];
    }
}

// Get the yellow version of a piece image based on piece type and color
function getYellowPiece(pieceType: int, pieceColor: int) return imagedata {
    // Use array indexing for O(1) lookup instead of if-else chain
    if pieceColor == WHITE then {
        return yellowWhitePieces[pieceType];
    } else {
        return yellowBlackPieces[pieceType];
    }
}

// Add a captured piece to the tracking arrays
function addCapturedPiece(pieceType: int, pieceColor: int) {
    if pieceColor == WHITE then {
        // White piece captured by black - add to left side
        if capturedWhiteCount < 16 then {
            capturedWhitePieces[capturedWhiteCount] = pieceType;
            capturedWhiteCount = capturedWhiteCount + 1;
        }
    } else {
        // Black piece captured by white - add to right side
        if capturedBlackCount < 16 then {
            capturedBlackPieces[capturedBlackCount] = pieceType;
            capturedBlackCount = capturedBlackCount + 1;
        }
    }
    call updateCapturedPiecesDisplay();
}

// Helper function to set a captured piece slot by index
function setCapturedPieceSlot(slotIndex: int, pieceImage: imagedata, color: int) {
    // Set the appropriate screen variable based on color and slot index
    if color == WHITE then {
        if slotIndex == 0 then { chessScreen.capturedWhite0 = pieceImage; }
        else if slotIndex == 1 then { chessScreen.capturedWhite1 = pieceImage; }
        else if slotIndex == 2 then { chessScreen.capturedWhite2 = pieceImage; }
        else if slotIndex == 3 then { chessScreen.capturedWhite3 = pieceImage; }
        else if slotIndex == 4 then { chessScreen.capturedWhite4 = pieceImage; }
        else if slotIndex == 5 then { chessScreen.capturedWhite5 = pieceImage; }
        else if slotIndex == 6 then { chessScreen.capturedWhite6 = pieceImage; }
        else if slotIndex == 7 then { chessScreen.capturedWhite7 = pieceImage; }
        else if slotIndex == 8 then { chessScreen.capturedWhite8 = pieceImage; }
        else if slotIndex == 9 then { chessScreen.capturedWhite9 = pieceImage; }
        else if slotIndex == 10 then { chessScreen.capturedWhite10 = pieceImage; }
        else if slotIndex == 11 then { chessScreen.capturedWhite11 = pieceImage; }
        else if slotIndex == 12 then { chessScreen.capturedWhite12 = pieceImage; }
        else if slotIndex == 13 then { chessScreen.capturedWhite13 = pieceImage; }
        else if slotIndex == 14 then { chessScreen.capturedWhite14 = pieceImage; }
        else if slotIndex == 15 then { chessScreen.capturedWhite15 = pieceImage; }
    } else {
        if slotIndex == 0 then { chessScreen.capturedBlack0 = pieceImage; }
        else if slotIndex == 1 then { chessScreen.capturedBlack1 = pieceImage; }
        else if slotIndex == 2 then { chessScreen.capturedBlack2 = pieceImage; }
        else if slotIndex == 3 then { chessScreen.capturedBlack3 = pieceImage; }
        else if slotIndex == 4 then { chessScreen.capturedBlack4 = pieceImage; }
        else if slotIndex == 5 then { chessScreen.capturedBlack5 = pieceImage; }
        else if slotIndex == 6 then { chessScreen.capturedBlack6 = pieceImage; }
        else if slotIndex == 7 then { chessScreen.capturedBlack7 = pieceImage; }
        else if slotIndex == 8 then { chessScreen.capturedBlack8 = pieceImage; }
        else if slotIndex == 9 then { chessScreen.capturedBlack9 = pieceImage; }
        else if slotIndex == 10 then { chessScreen.capturedBlack10 = pieceImage; }
        else if slotIndex == 11 then { chessScreen.capturedBlack11 = pieceImage; }
        else if slotIndex == 12 then { chessScreen.capturedBlack12 = pieceImage; }
        else if slotIndex == 13 then { chessScreen.capturedBlack13 = pieceImage; }
        else if slotIndex == 14 then { chessScreen.capturedBlack14 = pieceImage; }
        else if slotIndex == 15 then { chessScreen.capturedBlack15 = pieceImage; }
    }
}

// Update the captured pieces display on screen
function updateCapturedPiecesDisplay() {
    // Safety check - only update if transparentClear is initialized
    if transparentClear == null then {
        print "Warning: transparentClear is null, skipping captured pieces update";
        return;
    }
    
    // Update left side (captured white pieces) using loop
    for (var i: int = 0; i < 16; i++) {
        if i < capturedWhiteCount then {
            call setCapturedPieceSlot(i, call getNormalPiece(capturedWhitePieces[i], WHITE), WHITE);
        } else {
            call setCapturedPieceSlot(i, transparentClear, WHITE);
        }
    }
    
    // Update right side (captured black pieces) using loop
    for (var i: int = 0; i < 16; i++) {
        if i < capturedBlackCount then {
            call setCapturedPieceSlot(i, call getNormalPiece(capturedBlackPieces[i], BLACK), BLACK);
        } else {
            call setCapturedPieceSlot(i, transparentClear, BLACK);
        }
    }
}

// Clear captured pieces (for new game)
function clearCapturedPieces() {
    capturedWhiteCount = 0;
    capturedBlackCount = 0;
    call updateCapturedPiecesDisplay();
}

// Undo/Redo functionality

// Helper function to convert captured pieces array to string
function capturedPiecesToString(count: int) return string {
    if count == 0 then {
        return "";
    }
    var result: string = "";
    for (var i: int = 0; i < count; i++) {
        if i > 0 then {
            result = result + ",";
        }
        result = result + call string.fromInt(capturedWhitePieces[i]);
    }
    return result;
}

// Helper function to restore captured pieces from string
function stringToCapturedPieces(str: string) return int {
    if str == "" then {
        return 0;
    }
    var parts: string[] = call string.split(str, ",");
    var count: int = parts.length;
    for (var i: int = 0; i < count; i++) {
        capturedWhitePieces[i] = call string.toInt(parts[i]);
    }
    return count;
}

// Helper function for black pieces
function capturedBlackPiecesToString(count: int) return string {
    if count == 0 then {
        return "";
    }
    var result: string = "";
    for (var i: int = 0; i < count; i++) {
        if i > 0 then {
            result = result + ",";
        }
        result = result + call string.fromInt(capturedBlackPieces[i]);
    }
    return result;
}

// Helper function to restore black captured pieces from string
function stringToBlackCapturedPieces(str: string) return int {
    if str == "" then {
        return 0;
    }
    var parts: string[] = call string.split(str, ",");
    var count: int = parts.length;
    for (var i: int = 0; i < count; i++) {
        capturedBlackPieces[i] = call string.toInt(parts[i]);
    }
    return count;
}

// Helper to save board state to specific undo slot
function saveUndoBoardState(slot: int) {
    if slot == 0 then { undoBoard0 = board; }
    else if slot == 1 then { undoBoard1 = board; }
    else if slot == 2 then { undoBoard2 = board; }
    else if slot == 3 then { undoBoard3 = board; }
    else if slot == 4 then { undoBoard4 = board; }
    else if slot == 5 then { undoBoard5 = board; }
    else if slot == 6 then { undoBoard6 = board; }
    else if slot == 7 then { undoBoard7 = board; }
    else if slot == 8 then { undoBoard8 = board; }
    else if slot == 9 then { undoBoard9 = board; }
}

// Helper to restore board state from specific undo slot
function restoreUndoBoardState(slot: int) {
    if slot == 0 then { board = undoBoard0; }
    else if slot == 1 then { board = undoBoard1; }
    else if slot == 2 then { board = undoBoard2; }
    else if slot == 3 then { board = undoBoard3; }
    else if slot == 4 then { board = undoBoard4; }
    else if slot == 5 then { board = undoBoard5; }
    else if slot == 6 then { board = undoBoard6; }
    else if slot == 7 then { board = undoBoard7; }
    else if slot == 8 then { board = undoBoard8; }
    else if slot == 9 then { board = undoBoard9; }
}

// Helper to save board state to specific redo slot
function saveRedoBoardState(slot: int) {
    if slot == 0 then { redoBoard0 = board; }
    else if slot == 1 then { redoBoard1 = board; }
    else if slot == 2 then { redoBoard2 = board; }
    else if slot == 3 then { redoBoard3 = board; }
    else if slot == 4 then { redoBoard4 = board; }
    else if slot == 5 then { redoBoard5 = board; }
    else if slot == 6 then { redoBoard6 = board; }
    else if slot == 7 then { redoBoard7 = board; }
    else if slot == 8 then { redoBoard8 = board; }
    else if slot == 9 then { redoBoard9 = board; }
}

// Helper to restore board state from specific redo slot
function restoreRedoBoardState(slot: int) {
    if slot == 0 then { board = redoBoard0; }
    else if slot == 1 then { board = redoBoard1; }
    else if slot == 2 then { board = redoBoard2; }
    else if slot == 3 then { board = redoBoard3; }
    else if slot == 4 then { board = redoBoard4; }
    else if slot == 5 then { board = redoBoard5; }
    else if slot == 6 then { board = redoBoard6; }
    else if slot == 7 then { board = redoBoard7; }
    else if slot == 8 then { board = redoBoard8; }
    else if slot == 9 then { board = redoBoard9; }
}

// Save current game state to undo stack (before making a move)
function saveGameState() {
    // Only save for 2-player games
    if selectedGameMode != "2 player" then {
        return;
    }
    
    // Check if we have space in undo stack
    if undoStackCount >= 10 then {
        print "Undo stack full (max 10 moves), cannot save more states";
        return;
    }
    
    // Save board state using helper function
    call saveUndoBoardState(undoStackCount);
    
    // Save game variables
    undoStackCurrentPlayer[undoStackCount] = currentPlayer;
    undoStackTimerWhite[undoStackCount] = timerWhite;
    undoStackTimerBlack[undoStackCount] = timerBlack;
    
    // Save castling rights
    undoStackWhiteKingMoved[undoStackCount] = whiteKingMoved;
    undoStackBlackKingMoved[undoStackCount] = blackKingMoved;
    undoStackWhiteKingsideRookMoved[undoStackCount] = whiteKingsideRookMoved;
    undoStackWhiteQueensideRookMoved[undoStackCount] = whiteQueensideRookMoved;
    undoStackBlackKingsideRookMoved[undoStackCount] = blackKingsideRookMoved;
    undoStackBlackQueensideRookMoved[undoStackCount] = blackQueensideRookMoved;
    
    // Save en passant state
    undoStackEnPassantTargetX[undoStackCount] = enPassantTargetX;
    undoStackEnPassantTargetY[undoStackCount] = enPassantTargetY;
    
    // Save captured pieces
    undoStackCapturedWhiteCount[undoStackCount] = capturedWhiteCount;
    undoStackCapturedBlackCount[undoStackCount] = capturedBlackCount;
    undoStackCapturedWhitePieces[undoStackCount] = call capturedPiecesToString(capturedWhiteCount);
    undoStackCapturedBlackPieces[undoStackCount] = call capturedBlackPiecesToString(capturedBlackCount);
    
    // Save move history
    undoStackMoveHistory[undoStackCount] = chessScreen.moveHistory;
    
    // Save last move tracking
    undoStackLastMoveFromX[undoStackCount] = lastMoveFromX;
    undoStackLastMoveFromY[undoStackCount] = lastMoveFromY;
    undoStackLastMoveToX[undoStackCount] = lastMoveToX;
    undoStackLastMoveToY[undoStackCount] = lastMoveToY;
    
    // Increment stack count
    undoStackCount = undoStackCount + 1;
    
    // Clear redo stack when a new move is made
    redoStackCount = 0;
    
    // Update button states
    call updateUndoRedoButtons();
}

// Restore game state from undo stack at given index
function restoreGameStateFromUndo(index: int) {
    // Restore board state using helper function
    call restoreUndoBoardState(index);
    
    // Restore game variables
    currentPlayer = undoStackCurrentPlayer[index];
    timerWhite = undoStackTimerWhite[index];
    timerBlack = undoStackTimerBlack[index];
    
    // Restore castling rights
    whiteKingMoved = undoStackWhiteKingMoved[index];
    blackKingMoved = undoStackBlackKingMoved[index];
    whiteKingsideRookMoved = undoStackWhiteKingsideRookMoved[index];
    whiteQueensideRookMoved = undoStackWhiteQueensideRookMoved[index];
    blackKingsideRookMoved = undoStackBlackKingsideRookMoved[index];
    blackQueensideRookMoved = undoStackBlackQueensideRookMoved[index];
    
    // Restore en passant state
    enPassantTargetX = undoStackEnPassantTargetX[index];
    enPassantTargetY = undoStackEnPassantTargetY[index];
    
    // Restore captured pieces
    capturedWhiteCount = undoStackCapturedWhiteCount[index];
    capturedBlackCount = undoStackCapturedBlackCount[index];
    capturedWhiteCount = call stringToCapturedPieces(undoStackCapturedWhitePieces[index]);
    capturedBlackCount = call stringToBlackCapturedPieces(undoStackCapturedBlackPieces[index]);
    
    // Restore move history
    chessScreen.moveHistory = undoStackMoveHistory[index];
    
    // Restore last move tracking
    lastMoveFromX = undoStackLastMoveFromX[index];
    lastMoveFromY = undoStackLastMoveFromY[index];
    lastMoveToX = undoStackLastMoveToX[index];
    lastMoveToY = undoStackLastMoveToY[index];
    
    // Update all displays
    call updateBoardDisplay();
    call updateCapturedPiecesDisplay();
    call updateTimerDisplay();
    call updateTimerColors();
    
    // Clear selection and indicators
    selectedX = -1;
    selectedY = -1;
    call clearIndicators();
    
    // Show last move if available
    if lastMoveFromX >= 0 then {
        call showLastMove(lastMoveFromX, lastMoveFromY, lastMoveToX, lastMoveToY);
    }
    
    // Update status message
    if currentPlayer == WHITE then {
        chessScreen.statusMessage = "White to move";
    } else {
        chessScreen.statusMessage = "Black to move";
    }
}

// Restore game state from redo stack at given index
function restoreGameStateFromRedo(index: int) {
    // Restore board state using helper function
    call restoreRedoBoardState(index);
    
    // Restore game variables
    currentPlayer = redoStackCurrentPlayer[index];
    timerWhite = redoStackTimerWhite[index];
    timerBlack = redoStackTimerBlack[index];
    
    // Restore castling rights
    whiteKingMoved = redoStackWhiteKingMoved[index];
    blackKingMoved = redoStackBlackKingMoved[index];
    whiteKingsideRookMoved = redoStackWhiteKingsideRookMoved[index];
    whiteQueensideRookMoved = redoStackWhiteQueensideRookMoved[index];
    blackKingsideRookMoved = redoStackBlackKingsideRookMoved[index];
    blackQueensideRookMoved = redoStackBlackQueensideRookMoved[index];
    
    // Restore en passant state
    enPassantTargetX = redoStackEnPassantTargetX[index];
    enPassantTargetY = redoStackEnPassantTargetY[index];
    
    // Restore captured pieces
    capturedWhiteCount = redoStackCapturedWhiteCount[index];
    capturedBlackCount = redoStackCapturedBlackCount[index];
    capturedWhiteCount = call stringToCapturedPieces(redoStackCapturedWhitePieces[index]);
    capturedBlackCount = call stringToBlackCapturedPieces(redoStackCapturedBlackPieces[index]);
    
    // Restore move history
    chessScreen.moveHistory = redoStackMoveHistory[index];
    
    // Restore last move tracking
    lastMoveFromX = redoStackLastMoveFromX[index];
    lastMoveFromY = redoStackLastMoveFromY[index];
    lastMoveToX = redoStackLastMoveToX[index];
    lastMoveToY = redoStackLastMoveToY[index];
    
    // Update all displays
    call updateBoardDisplay();
    call updateCapturedPiecesDisplay();
    call updateTimerDisplay();
    call updateTimerColors();
    
    // Clear selection and indicators
    selectedX = -1;
    selectedY = -1;
    call clearIndicators();
    
    // Show last move if available
    if lastMoveFromX >= 0 then {
        call showLastMove(lastMoveFromX, lastMoveFromY, lastMoveToX, lastMoveToY);
    }
    
    // Update status message
    if currentPlayer == WHITE then {
        chessScreen.statusMessage = "White to move";
    } else {
        chessScreen.statusMessage = "Black to move";
    }
}

// Update the board display to reflect current board state
function updateBoardDisplay() {
    for (var y: int = 0; y < 8; y++) {
        for (var x: int = 0; x < 8; x++) {
            var cellValue: int = call getPieceAt(x, y);
            if cellValue != -1 then {
                var cell = ChessCell(cellValue);
                var pieceImage: imagedata = call getNormalPiece(cell.pieceType, cell.pieceColor);
                call setPieceCell(x, y, pieceImage);
            }
        }
    }
}

// Update the timer display to reflect current timer values
function updateTimerDisplay() {
    chessScreen.whiteTimer = call formatTimerDecimal(timerWhite);
    chessScreen.blackTimer = call formatTimerDecimal(timerBlack);
}

// Undo the last move
function undoMove() {
    if undoStackCount == 0 then {
        print "No moves to undo";
        return;
    }
    
    // Save current state to redo stack
    call saveRedoBoardState(redoStackCount);
    redoStackCurrentPlayer[redoStackCount] = currentPlayer;
    redoStackTimerWhite[redoStackCount] = timerWhite;
    redoStackTimerBlack[redoStackCount] = timerBlack;
    redoStackWhiteKingMoved[redoStackCount] = whiteKingMoved;
    redoStackBlackKingMoved[redoStackCount] = blackKingMoved;
    redoStackWhiteKingsideRookMoved[redoStackCount] = whiteKingsideRookMoved;
    redoStackWhiteQueensideRookMoved[redoStackCount] = whiteQueensideRookMoved;
    redoStackBlackKingsideRookMoved[redoStackCount] = blackKingsideRookMoved;
    redoStackBlackQueensideRookMoved[redoStackCount] = blackQueensideRookMoved;
    redoStackEnPassantTargetX[redoStackCount] = enPassantTargetX;
    redoStackEnPassantTargetY[redoStackCount] = enPassantTargetY;
    redoStackCapturedWhiteCount[redoStackCount] = capturedWhiteCount;
    redoStackCapturedBlackCount[redoStackCount] = capturedBlackCount;
    redoStackCapturedWhitePieces[redoStackCount] = call capturedPiecesToString(capturedWhiteCount);
    redoStackCapturedBlackPieces[redoStackCount] = call capturedBlackPiecesToString(capturedBlackCount);
    redoStackMoveHistory[redoStackCount] = chessScreen.moveHistory;
    redoStackLastMoveFromX[redoStackCount] = lastMoveFromX;
    redoStackLastMoveFromY[redoStackCount] = lastMoveFromY;
    redoStackLastMoveToX[redoStackCount] = lastMoveToX;
    redoStackLastMoveToY[redoStackCount] = lastMoveToY;
    redoStackCount = redoStackCount + 1;
    
    // Pop state from undo stack
    undoStackCount = undoStackCount - 1;
    
    // Restore the previous state
    call restoreGameStateFromUndo(undoStackCount);
    
    // Update button states
    call updateUndoRedoButtons();
    
    print "Move undone";
}

// Redo the last undone move
function redoMove() {
    if redoStackCount == 0 then {
        print "No moves to redo";
        return;
    }
    
    // Save current state to undo stack
    call saveUndoBoardState(undoStackCount);
    undoStackCurrentPlayer[undoStackCount] = currentPlayer;
    undoStackTimerWhite[undoStackCount] = timerWhite;
    undoStackTimerBlack[undoStackCount] = timerBlack;
    undoStackWhiteKingMoved[undoStackCount] = whiteKingMoved;
    undoStackBlackKingMoved[undoStackCount] = blackKingMoved;
    undoStackWhiteKingsideRookMoved[undoStackCount] = whiteKingsideRookMoved;
    undoStackWhiteQueensideRookMoved[undoStackCount] = whiteQueensideRookMoved;
    undoStackBlackKingsideRookMoved[undoStackCount] = blackKingsideRookMoved;
    undoStackBlackQueensideRookMoved[undoStackCount] = blackQueensideRookMoved;
    undoStackEnPassantTargetX[undoStackCount] = enPassantTargetX;
    undoStackEnPassantTargetY[undoStackCount] = enPassantTargetY;
    undoStackCapturedWhiteCount[undoStackCount] = capturedWhiteCount;
    undoStackCapturedBlackCount[undoStackCount] = capturedBlackCount;
    undoStackCapturedWhitePieces[undoStackCount] = call capturedPiecesToString(capturedWhiteCount);
    undoStackCapturedBlackPieces[undoStackCount] = call capturedBlackPiecesToString(capturedBlackCount);
    undoStackMoveHistory[undoStackCount] = chessScreen.moveHistory;
    undoStackLastMoveFromX[undoStackCount] = lastMoveFromX;
    undoStackLastMoveFromY[undoStackCount] = lastMoveFromY;
    undoStackLastMoveToX[undoStackCount] = lastMoveToX;
    undoStackLastMoveToY[undoStackCount] = lastMoveToY;
    undoStackCount = undoStackCount + 1;
    
    // Pop state from redo stack
    redoStackCount = redoStackCount - 1;
    
    // Restore the next state
    call restoreGameStateFromRedo(redoStackCount);
    
    // Update button states
    call updateUndoRedoButtons();
    
    print "Move redone";
}

// Update undo/redo button states (enable/disable)
function updateUndoRedoButtons() {
    // Only applicable for 2-player games
    if selectedGameMode != "2 player" then {
        return;
    }
    
    // Update undo button
    if undoStackCount > 0 then {
        call scr.setproperty("chessScreen.undoBtn", "disabled", false);
    } else {
        call scr.setproperty("chessScreen.undoBtn", "disabled", true);
    }
    
    // Update redo button
    if redoStackCount > 0 then {
        call scr.setproperty("chessScreen.redoBtn", "disabled", false);
    } else {
        call scr.setproperty("chessScreen.redoBtn", "disabled", true);
    }
}

// Clear undo/redo history (for new game)
function clearUndoRedoHistory() {
    undoStackCount = 0;
    redoStackCount = 0;
    call updateUndoRedoButtons();
}

// Create board layer images (bottom layer - checkerboard)
createBoardLayer() {
    // Create light square for board
    var lightCanvas: canvas = call canvas.create(60, 60, "light_square");
    call style.setFill(lightCanvas, COLOR_CELL_LIGHT);
    call draw.rect(lightCanvas, 0, 0, 60, 60, true);
    lightSquare = call canvas.toImage(lightCanvas);
    
    // Create dark square for board
    var darkCanvas: canvas = call canvas.create(60, 60, "dark_square");
    call style.setFill(darkCanvas, COLOR_CELL_DARK);
    call draw.rect(darkCanvas, 0, 0, 60, 60, true);
    darkSquare = call canvas.toImage(darkCanvas);
}

// Create indicator images using canvas (middle layer)
createIndicators() {
    // Create green circle indicator for valid moves
    // Canvas size matches cell size (60x60) for proper centering
    var greenCanvas: canvas = call canvas.create(60, 60, "green_indicator");
    call canvas.clear(greenCanvas);  // Make canvas transparent
    call style.setFill(greenCanvas, "#00FF0080");  // Semi-transparent green
    call draw.circle(greenCanvas, 30, 30, 20, true);
    call style.setStroke(greenCanvas, "#00AA00", 2.0);
    call draw.circle(greenCanvas, 30, 30, 20, false);
    greenIndicator = call canvas.toImage(greenCanvas);
    
    // Create red circle indicator for capture moves
    // Canvas size matches cell size (60x60) for proper centering
    var redCanvas: canvas = call canvas.create(60, 60, "red_indicator");
    call canvas.clear(redCanvas);  // Make canvas transparent
    call style.setFill(redCanvas, "#FF000080");  // Semi-transparent red
    call draw.circle(redCanvas, 30, 30, 20, true);
    call style.setStroke(redCanvas, "#AA0000", 2.0);
    call draw.circle(redCanvas, 30, 30, 20, false);
    redIndicator = call canvas.toImage(redCanvas);
    
    // Create yellow circle indicator for moves that check opponent's king
    // Canvas size matches cell size (60x60) for proper centering
    var yellowCanvas: canvas = call canvas.create(60, 60, "yellow_indicator");
    call canvas.clear(yellowCanvas);  // Make canvas transparent
    call style.setFill(yellowCanvas, "#FFFF0080");  // Semi-transparent yellow
    call draw.circle(yellowCanvas, 30, 30, 20, true);
    call style.setStroke(yellowCanvas, "#AAAA00", 2.0);
    call draw.circle(yellowCanvas, 30, 30, 20, false);
    yellowCircleIndicator = call canvas.toImage(yellowCanvas);
    
    // Create orange circle indicator for moves that capture AND check opponent's king
    // Canvas size matches cell size (60x60) for proper centering
    var orangeCanvas: canvas = call canvas.create(60, 60, "orange_indicator");
    call canvas.clear(orangeCanvas);  // Make canvas transparent
    call style.setFill(orangeCanvas, "#FFA50080");  // Semi-transparent orange
    call draw.circle(orangeCanvas, 30, 30, 20, true);
    call style.setStroke(orangeCanvas, "#CC8400", 2.0);
    call draw.circle(orangeCanvas, 30, 30, 20, false);
    orangeCircleIndicator = call canvas.toImage(orangeCanvas);
    
    // Create red cross indicator for invalid moves (that would expose own king)
    // Canvas size matches cell size (60x60) for proper centering
    var crossCanvas: canvas = call canvas.create(60, 60, "red_cross_indicator");
    call canvas.clear(crossCanvas);  // Make canvas transparent
    call style.setStroke(crossCanvas, "#FF0000", 4.0);
    // Draw X from corner to corner
    call draw.line(crossCanvas, 15, 15, 45, 45);
    call draw.line(crossCanvas, 45, 15, 15, 45);
    redCrossIndicator = call canvas.toImage(crossCanvas);
    
    // Create larger red cross indicator for checkmate
    // Canvas size matches cell size (60x60) for proper centering
    var bigCrossCanvas: canvas = call canvas.create(60, 60, "red_cross_big_indicator");
    call canvas.clear(bigCrossCanvas);  // Make canvas transparent
    call style.setStroke(bigCrossCanvas, "#FF0000", 6.0);  // Thicker lines (6px instead of 4px)
    // Draw X with larger extent (10-50 instead of 15-45)
    call draw.line(bigCrossCanvas, 10, 10, 50, 50);
    call draw.line(bigCrossCanvas, 50, 10, 10, 50);
    redCrossBigIndicator = call canvas.toImage(bigCrossCanvas);
    
    // Create blue circle indicator for showing last move endpoints
    // Canvas size matches cell size (60x60) for proper centering
    var blueCircleCanvas: canvas = call canvas.create(60, 60, "blue_circle_indicator");
    call canvas.clear(blueCircleCanvas);  // Make canvas transparent
    call style.setFill(blueCircleCanvas, "#0080FF80");  // Semi-transparent blue
    call draw.circle(blueCircleCanvas, 30, 30, 18, true);
    call style.setStroke(blueCircleCanvas, "#0060CC", 2.5);
    call draw.circle(blueCircleCanvas, 30, 30, 18, false);
    blueCircleIndicator = call canvas.toImage(blueCircleCanvas);
    
    // Create purple circle indicator for showing piece defenders
    // Canvas size matches cell size (60x60) for proper centering
    var purpleCircleCanvas: canvas = call canvas.create(60, 60, "purple_circle_indicator");
    call canvas.clear(purpleCircleCanvas);  // Make canvas transparent
    call style.setFill(purpleCircleCanvas, "#A020F080");  // Semi-transparent purple
    call draw.circle(purpleCircleCanvas, 30, 30, 18, true);
    call style.setStroke(purpleCircleCanvas, "#6A0DAD", 2.5);
    call draw.circle(purpleCircleCanvas, 30, 30, 18, false);
    purpleCircleIndicator = call canvas.toImage(purpleCircleCanvas);
    
    // Create blue arrow pointing right (horizontal)
    var arrowRightCanvas: canvas = call canvas.create(60, 60, "blue_arrow_right");
    call canvas.clear(arrowRightCanvas);
    call style.setStroke(arrowRightCanvas, "#0060CC", 3.5);
    call draw.line(arrowRightCanvas, 5, 30, 55, 30);  // Horizontal line
    call draw.line(arrowRightCanvas, 48, 23, 55, 30);  // Arrow head top
    call draw.line(arrowRightCanvas, 48, 37, 55, 30);  // Arrow head bottom
    blueArrowRight = call canvas.toImage(arrowRightCanvas);
    
    // Create blue arrow pointing left (horizontal)
    var arrowLeftCanvas: canvas = call canvas.create(60, 60, "blue_arrow_left");
    call canvas.clear(arrowLeftCanvas);
    call style.setStroke(arrowLeftCanvas, "#0060CC", 3.5);
    call draw.line(arrowLeftCanvas, 5, 30, 55, 30);  // Horizontal line
    call draw.line(arrowLeftCanvas, 12, 23, 5, 30);  // Arrow head top
    call draw.line(arrowLeftCanvas, 12, 37, 5, 30);  // Arrow head bottom
    blueArrowLeft = call canvas.toImage(arrowLeftCanvas);
    
    // Create blue arrow pointing up (vertical)
    var arrowUpCanvas: canvas = call canvas.create(60, 60, "blue_arrow_up");
    call canvas.clear(arrowUpCanvas);
    call style.setStroke(arrowUpCanvas, "#0060CC", 3.5);
    call draw.line(arrowUpCanvas, 30, 5, 30, 55);  // Vertical line
    call draw.line(arrowUpCanvas, 23, 12, 30, 5);  // Arrow head left
    call draw.line(arrowUpCanvas, 37, 12, 30, 5);  // Arrow head right
    blueArrowUp = call canvas.toImage(arrowUpCanvas);
    
    // Create blue arrow pointing down (vertical)
    var arrowDownCanvas: canvas = call canvas.create(60, 60, "blue_arrow_down");
    call canvas.clear(arrowDownCanvas);
    call style.setStroke(arrowDownCanvas, "#0060CC", 3.5);
    call draw.line(arrowDownCanvas, 30, 5, 30, 55);  // Vertical line
    call draw.line(arrowDownCanvas, 23, 48, 30, 55);  // Arrow head left
    call draw.line(arrowDownCanvas, 37, 48, 30, 55);  // Arrow head right
    blueArrowDown = call canvas.toImage(arrowDownCanvas);
    
    // Create blue arrow pointing up-right (diagonal)
    var arrowUpRightCanvas: canvas = call canvas.create(60, 60, "blue_arrow_up_right");
    call canvas.clear(arrowUpRightCanvas);
    call style.setStroke(arrowUpRightCanvas, "#0060CC", 3.5);
    call draw.line(arrowUpRightCanvas, 10, 50, 50, 10);  // Diagonal line
    call draw.line(arrowUpRightCanvas, 50, 10, 42, 14);  // Arrow head
    call draw.line(arrowUpRightCanvas, 50, 10, 46, 18);  // Arrow head
    blueArrowUpRight = call canvas.toImage(arrowUpRightCanvas);
    
    // Create blue arrow pointing up-left (diagonal)
    var arrowUpLeftCanvas: canvas = call canvas.create(60, 60, "blue_arrow_up_left");
    call canvas.clear(arrowUpLeftCanvas);
    call style.setStroke(arrowUpLeftCanvas, "#0060CC", 3.5);
    call draw.line(arrowUpLeftCanvas, 10, 10, 50, 50);  // Diagonal line
    call draw.line(arrowUpLeftCanvas, 10, 10, 18, 14);  // Arrow head
    call draw.line(arrowUpLeftCanvas, 10, 10, 14, 18);  // Arrow head
    blueArrowUpLeft = call canvas.toImage(arrowUpLeftCanvas);
    
    // Create blue arrow pointing down-right (diagonal)
    var arrowDownRightCanvas: canvas = call canvas.create(60, 60, "blue_arrow_down_right");
    call canvas.clear(arrowDownRightCanvas);
    call style.setStroke(arrowDownRightCanvas, "#0060CC", 3.5);
    call draw.line(arrowDownRightCanvas, 10, 10, 50, 50);  // Diagonal line
    call draw.line(arrowDownRightCanvas, 50, 50, 46, 42);  // Arrow head
    call draw.line(arrowDownRightCanvas, 50, 50, 42, 46);  // Arrow head
    blueArrowDownRight = call canvas.toImage(arrowDownRightCanvas);
    
    // Create blue arrow pointing down-left (diagonal)
    var arrowDownLeftCanvas: canvas = call canvas.create(60, 60, "blue_arrow_down_left");
    call canvas.clear(arrowDownLeftCanvas);
    call style.setStroke(arrowDownLeftCanvas, "#0060CC", 3.5);
    call draw.line(arrowDownLeftCanvas, 10, 50, 50, 10);  // Diagonal line
    call draw.line(arrowDownLeftCanvas, 10, 50, 14, 42);  // Arrow head
    call draw.line(arrowDownLeftCanvas, 10, 50, 18, 46);  // Arrow head
    blueArrowDownLeft = call canvas.toImage(arrowDownLeftCanvas);
    
    // Create L-shaped arrows with 90-degree angles for knight moves
    // L-shape: Up then Right (vertical then horizontal)
    var lShapeUpRightCanvas: canvas = call canvas.create(60, 60, "blue_l_up_right");
    call canvas.clear(lShapeUpRightCanvas);
    call style.setStroke(lShapeUpRightCanvas, "#0060CC", 3.5);
    call draw.line(lShapeUpRightCanvas, 30, 55, 30, 30);  // Vertical line (up)
    call draw.line(lShapeUpRightCanvas, 30, 30, 55, 30);  // Horizontal line (right)
    call draw.line(lShapeUpRightCanvas, 48, 23, 55, 30);  // Arrow head top
    call draw.line(lShapeUpRightCanvas, 48, 37, 55, 30);  // Arrow head bottom
    blueLShapeUpRight = call canvas.toImage(lShapeUpRightCanvas);
    
    // L-shape: Up then Left (vertical then horizontal)
    var lShapeUpLeftCanvas: canvas = call canvas.create(60, 60, "blue_l_up_left");
    call canvas.clear(lShapeUpLeftCanvas);
    call style.setStroke(lShapeUpLeftCanvas, "#0060CC", 3.5);
    call draw.line(lShapeUpLeftCanvas, 30, 55, 30, 30);  // Vertical line (up)
    call draw.line(lShapeUpLeftCanvas, 30, 30, 5, 30);   // Horizontal line (left)
    call draw.line(lShapeUpLeftCanvas, 12, 23, 5, 30);   // Arrow head top
    call draw.line(lShapeUpLeftCanvas, 12, 37, 5, 30);   // Arrow head bottom
    blueLShapeUpLeft = call canvas.toImage(lShapeUpLeftCanvas);
    
    // L-shape: Down then Right (vertical then horizontal)
    var lShapeDownRightCanvas: canvas = call canvas.create(60, 60, "blue_l_down_right");
    call canvas.clear(lShapeDownRightCanvas);
    call style.setStroke(lShapeDownRightCanvas, "#0060CC", 3.5);
    call draw.line(lShapeDownRightCanvas, 30, 5, 30, 30);   // Vertical line (down)
    call draw.line(lShapeDownRightCanvas, 30, 30, 55, 30);  // Horizontal line (right)
    call draw.line(lShapeDownRightCanvas, 48, 23, 55, 30);  // Arrow head top
    call draw.line(lShapeDownRightCanvas, 48, 37, 55, 30);  // Arrow head bottom
    blueLShapeDownRight = call canvas.toImage(lShapeDownRightCanvas);
    
    // L-shape: Down then Left (vertical then horizontal)
    var lShapeDownLeftCanvas: canvas = call canvas.create(60, 60, "blue_l_down_left");
    call canvas.clear(lShapeDownLeftCanvas);
    call style.setStroke(lShapeDownLeftCanvas, "#0060CC", 3.5);
    call draw.line(lShapeDownLeftCanvas, 30, 5, 30, 30);   // Vertical line (down)
    call draw.line(lShapeDownLeftCanvas, 30, 30, 5, 30);   // Horizontal line (left)
    call draw.line(lShapeDownLeftCanvas, 12, 23, 5, 30);   // Arrow head top
    call draw.line(lShapeDownLeftCanvas, 12, 37, 5, 30);   // Arrow head bottom
    blueLShapeDownLeft = call canvas.toImage(lShapeDownLeftCanvas);
    
    // L-shape: Right then Up (horizontal then vertical)
    var lShapeRightUpCanvas: canvas = call canvas.create(60, 60, "blue_l_right_up");
    call canvas.clear(lShapeRightUpCanvas);
    call style.setStroke(lShapeRightUpCanvas, "#0060CC", 3.5);
    call draw.line(lShapeRightUpCanvas, 5, 30, 30, 30);   // Horizontal line (right)
    call draw.line(lShapeRightUpCanvas, 30, 30, 30, 5);   // Vertical line (up)
    call draw.line(lShapeRightUpCanvas, 23, 12, 30, 5);   // Arrow head left
    call draw.line(lShapeRightUpCanvas, 37, 12, 30, 5);   // Arrow head right
    blueLShapeRightUp = call canvas.toImage(lShapeRightUpCanvas);
    
    // L-shape: Right then Down (horizontal then vertical)
    var lShapeRightDownCanvas: canvas = call canvas.create(60, 60, "blue_l_right_down");
    call canvas.clear(lShapeRightDownCanvas);
    call style.setStroke(lShapeRightDownCanvas, "#0060CC", 3.5);
    call draw.line(lShapeRightDownCanvas, 5, 30, 30, 30);   // Horizontal line (right)
    call draw.line(lShapeRightDownCanvas, 30, 30, 30, 55);  // Vertical line (down)
    call draw.line(lShapeRightDownCanvas, 23, 48, 30, 55);  // Arrow head left
    call draw.line(lShapeRightDownCanvas, 37, 48, 30, 55);  // Arrow head right
    blueLShapeRightDown = call canvas.toImage(lShapeRightDownCanvas);
    
    // L-shape: Left then Up (horizontal then vertical)
    var lShapeLeftUpCanvas: canvas = call canvas.create(60, 60, "blue_l_left_up");
    call canvas.clear(lShapeLeftUpCanvas);
    call style.setStroke(lShapeLeftUpCanvas, "#0060CC", 3.5);
    call draw.line(lShapeLeftUpCanvas, 55, 30, 30, 30);   // Horizontal line (left)
    call draw.line(lShapeLeftUpCanvas, 30, 30, 30, 5);    // Vertical line (up)
    call draw.line(lShapeLeftUpCanvas, 23, 12, 30, 5);    // Arrow head left
    call draw.line(lShapeLeftUpCanvas, 37, 12, 30, 5);    // Arrow head right
    blueLShapeLeftUp = call canvas.toImage(lShapeLeftUpCanvas);
    
    // L-shape: Left then Down (horizontal then vertical)
    var lShapeLeftDownCanvas: canvas = call canvas.create(60, 60, "blue_l_left_down");
    call canvas.clear(lShapeLeftDownCanvas);
    call style.setStroke(lShapeLeftDownCanvas, "#0060CC", 3.5);
    call draw.line(lShapeLeftDownCanvas, 55, 30, 30, 30);   // Horizontal line (left)
    call draw.line(lShapeLeftDownCanvas, 30, 30, 30, 55);   // Vertical line (down)
    call draw.line(lShapeLeftDownCanvas, 23, 48, 30, 55);   // Arrow head left
    call draw.line(lShapeLeftDownCanvas, 37, 48, 30, 55);   // Arrow head right
    blueLShapeLeftDown = call canvas.toImage(lShapeLeftDownCanvas);

    
    // Create transparent rectangle for clearing piece positions
    // Canvas size matches cell size (60x60)
    var clearCanvas: canvas = call canvas.create(60, 60, "transparent_clear");
    call canvas.clear(clearCanvas);  // Make canvas completely transparent
    transparentClear = call canvas.toImage(clearCanvas);
}

// Load normal and yellow piece images using loops for efficiency
loadPieceImages() {
    // Define piece names in order: [0]=empty, [1]=pawn, [2]=rook, [3]=knight, [4]=bishop, [5]=queen, [6]=king
    var pieceNames: string[7];
    pieceNames[0] = "";  // Empty - no image to load
    pieceNames[1] = "pawn";
    pieceNames[2] = "rook";
    pieceNames[3] = "knight";
    pieceNames[4] = "bishop";
    pieceNames[5] = "queen";
    pieceNames[6] = "king";
    
    // Load normal (original) piece images using loops
    for (var i: int = 1; i < 7; i++) {  // Start at 1 to skip empty
        normalWhitePieces[i] = call image.load(imgPath + "white_" + pieceNames[i] + ".svg");
        normalBlackPieces[i] = call image.load(imgPath + "black_" + pieceNames[i] + ".svg");
    }
    
    // Load yellow piece images (for highlighting selected pieces) using loops
    for (var i: int = 1; i < 7; i++) {  // Start at 1 to skip empty
        yellowWhitePieces[i] = call image.load(imgPath + "yellow_white_" + pieceNames[i] + ".svg");
        yellowBlackPieces[i] = call image.load(imgPath + "yellow_black_" + pieceNames[i] + ".svg");
    }
    
    // Set empty slots to transparent clear (will be set after transparentClear is created)
    normalWhitePieces[0] = null;
    normalBlackPieces[0] = null;
    yellowWhitePieces[0] = null;
    yellowBlackPieces[0] = null;
}

// Helper function to set a piece cell at a specific board position
function setPieceCell(x: int, y: int, pieceImage: imagedata) {
    // Set the appropriate screen variable based on x,y position
    if y == 0 then {
        if x == 0 then { chessScreen.c00 = pieceImage; }
        else if x == 1 then { chessScreen.c01 = pieceImage; }
        else if x == 2 then { chessScreen.c02 = pieceImage; }
        else if x == 3 then { chessScreen.c03 = pieceImage; }
        else if x == 4 then { chessScreen.c04 = pieceImage; }
        else if x == 5 then { chessScreen.c05 = pieceImage; }
        else if x == 6 then { chessScreen.c06 = pieceImage; }
        else if x == 7 then { chessScreen.c07 = pieceImage; }
    } else if y == 1 then {
        if x == 0 then { chessScreen.c10 = pieceImage; }
        else if x == 1 then { chessScreen.c11 = pieceImage; }
        else if x == 2 then { chessScreen.c12 = pieceImage; }
        else if x == 3 then { chessScreen.c13 = pieceImage; }
        else if x == 4 then { chessScreen.c14 = pieceImage; }
        else if x == 5 then { chessScreen.c15 = pieceImage; }
        else if x == 6 then { chessScreen.c16 = pieceImage; }
        else if x == 7 then { chessScreen.c17 = pieceImage; }
    } else if y == 2 then {
        if x == 0 then { chessScreen.c20 = pieceImage; }
        else if x == 1 then { chessScreen.c21 = pieceImage; }
        else if x == 2 then { chessScreen.c22 = pieceImage; }
        else if x == 3 then { chessScreen.c23 = pieceImage; }
        else if x == 4 then { chessScreen.c24 = pieceImage; }
        else if x == 5 then { chessScreen.c25 = pieceImage; }
        else if x == 6 then { chessScreen.c26 = pieceImage; }
        else if x == 7 then { chessScreen.c27 = pieceImage; }
    } else if y == 3 then {
        if x == 0 then { chessScreen.c30 = pieceImage; }
        else if x == 1 then { chessScreen.c31 = pieceImage; }
        else if x == 2 then { chessScreen.c32 = pieceImage; }
        else if x == 3 then { chessScreen.c33 = pieceImage; }
        else if x == 4 then { chessScreen.c34 = pieceImage; }
        else if x == 5 then { chessScreen.c35 = pieceImage; }
        else if x == 6 then { chessScreen.c36 = pieceImage; }
        else if x == 7 then { chessScreen.c37 = pieceImage; }
    } else if y == 4 then {
        if x == 0 then { chessScreen.c40 = pieceImage; }
        else if x == 1 then { chessScreen.c41 = pieceImage; }
        else if x == 2 then { chessScreen.c42 = pieceImage; }
        else if x == 3 then { chessScreen.c43 = pieceImage; }
        else if x == 4 then { chessScreen.c44 = pieceImage; }
        else if x == 5 then { chessScreen.c45 = pieceImage; }
        else if x == 6 then { chessScreen.c46 = pieceImage; }
        else if x == 7 then { chessScreen.c47 = pieceImage; }
    } else if y == 5 then {
        if x == 0 then { chessScreen.c50 = pieceImage; }
        else if x == 1 then { chessScreen.c51 = pieceImage; }
        else if x == 2 then { chessScreen.c52 = pieceImage; }
        else if x == 3 then { chessScreen.c53 = pieceImage; }
        else if x == 4 then { chessScreen.c54 = pieceImage; }
        else if x == 5 then { chessScreen.c55 = pieceImage; }
        else if x == 6 then { chessScreen.c56 = pieceImage; }
        else if x == 7 then { chessScreen.c57 = pieceImage; }
    } else if y == 6 then {
        if x == 0 then { chessScreen.c60 = pieceImage; }
        else if x == 1 then { chessScreen.c61 = pieceImage; }
        else if x == 2 then { chessScreen.c62 = pieceImage; }
        else if x == 3 then { chessScreen.c63 = pieceImage; }
        else if x == 4 then { chessScreen.c64 = pieceImage; }
        else if x == 5 then { chessScreen.c65 = pieceImage; }
        else if x == 6 then { chessScreen.c66 = pieceImage; }
        else if x == 7 then { chessScreen.c67 = pieceImage; }
    } else if y == 7 then {
        if x == 0 then { chessScreen.c70 = pieceImage; }
        else if x == 1 then { chessScreen.c71 = pieceImage; }
        else if x == 2 then { chessScreen.c72 = pieceImage; }
        else if x == 3 then { chessScreen.c73 = pieceImage; }
        else if x == 4 then { chessScreen.c74 = pieceImage; }
        else if x == 5 then { chessScreen.c75 = pieceImage; }
        else if x == 6 then { chessScreen.c76 = pieceImage; }
        else if x == 7 then { chessScreen.c77 = pieceImage; }
    }
}

// Initialize board pieces on screen using already-loaded piece images
initializeBoardPieces() {
    // Row 0 (black back row) - using piece type constants as indices
    var blackBackRowTypes: int[8];
    blackBackRowTypes[0] = ROOK;
    blackBackRowTypes[1] = KNIGHT;
    blackBackRowTypes[2] = BISHOP;
    blackBackRowTypes[3] = QUEEN;
    blackBackRowTypes[4] = KING;
    blackBackRowTypes[5] = BISHOP;
    blackBackRowTypes[6] = KNIGHT;
    blackBackRowTypes[7] = ROOK;
    
    for (var x: int = 0; x < 8; x++) {
        call setPieceCell(x, 0, normalBlackPieces[blackBackRowTypes[x]]);
    }
    
    // Row 1 (black pawns) - use loop
    for (var x: int = 0; x < 8; x++) {
        call setPieceCell(x, 1, normalBlackPieces[PAWN]);
    }
    
    // Rows 2-5 (empty middle rows) - clear with null to avoid displaying stale images
    for (var y: int = 2; y < 6; y++) {
        for (var x: int = 0; x < 8; x++) {
            call setPieceCell(x, y, null);
        }
    }
    
    // Row 6 (white pawns) - use loop
    for (var x: int = 0; x < 8; x++) {
        call setPieceCell(x, 6, normalWhitePieces[PAWN]);
    }
    
    // Row 7 (white back row) - using piece type constants as indices
    var whiteBackRowTypes: int[8];
    whiteBackRowTypes[0] = ROOK;
    whiteBackRowTypes[1] = KNIGHT;
    whiteBackRowTypes[2] = BISHOP;
    whiteBackRowTypes[3] = QUEEN;
    whiteBackRowTypes[4] = KING;
    whiteBackRowTypes[5] = BISHOP;
    whiteBackRowTypes[6] = KNIGHT;
    whiteBackRowTypes[7] = ROOK;
    
    for (var x: int = 0; x < 8; x++) {
        call setPieceCell(x, 7, normalWhitePieces[whiteBackRowTypes[x]]);
    }
}

// Clear all move indicators on the board
clearIndicators() {
    // Clear all 64 indicator positions by setting them directly to transparentClear
    chessScreen.i00 = transparentClear; chessScreen.i01 = transparentClear; chessScreen.i02 = transparentClear; chessScreen.i03 = transparentClear;
    chessScreen.i04 = transparentClear; chessScreen.i05 = transparentClear; chessScreen.i06 = transparentClear; chessScreen.i07 = transparentClear;
    chessScreen.i10 = transparentClear; chessScreen.i11 = transparentClear; chessScreen.i12 = transparentClear; chessScreen.i13 = transparentClear;
    chessScreen.i14 = transparentClear; chessScreen.i15 = transparentClear; chessScreen.i16 = transparentClear; chessScreen.i17 = transparentClear;
    chessScreen.i20 = transparentClear; chessScreen.i21 = transparentClear; chessScreen.i22 = transparentClear; chessScreen.i23 = transparentClear;
    chessScreen.i24 = transparentClear; chessScreen.i25 = transparentClear; chessScreen.i26 = transparentClear; chessScreen.i27 = transparentClear;
    chessScreen.i30 = transparentClear; chessScreen.i31 = transparentClear; chessScreen.i32 = transparentClear; chessScreen.i33 = transparentClear;
    chessScreen.i34 = transparentClear; chessScreen.i35 = transparentClear; chessScreen.i36 = transparentClear; chessScreen.i37 = transparentClear;
    chessScreen.i40 = transparentClear; chessScreen.i41 = transparentClear; chessScreen.i42 = transparentClear; chessScreen.i43 = transparentClear;
    chessScreen.i44 = transparentClear; chessScreen.i45 = transparentClear; chessScreen.i46 = transparentClear; chessScreen.i47 = transparentClear;
    chessScreen.i50 = transparentClear; chessScreen.i51 = transparentClear; chessScreen.i52 = transparentClear; chessScreen.i53 = transparentClear;
    chessScreen.i54 = transparentClear; chessScreen.i55 = transparentClear; chessScreen.i56 = transparentClear; chessScreen.i57 = transparentClear;
    chessScreen.i60 = transparentClear; chessScreen.i61 = transparentClear; chessScreen.i62 = transparentClear; chessScreen.i63 = transparentClear;
    chessScreen.i64 = transparentClear; chessScreen.i65 = transparentClear; chessScreen.i66 = transparentClear; chessScreen.i67 = transparentClear;
    chessScreen.i70 = transparentClear; chessScreen.i71 = transparentClear; chessScreen.i72 = transparentClear; chessScreen.i73 = transparentClear;
    chessScreen.i74 = transparentClear; chessScreen.i75 = transparentClear; chessScreen.i76 = transparentClear; chessScreen.i77 = transparentClear;
}

// Helper function to set a board square (background layer) at a specific position
function setBoardSquare(x: int, y: int, squareImage: imagedata) {
    // Set the appropriate screen variable based on x,y position
    if y == 0 then {
        if x == 0 then { chessScreen.b00 = squareImage; }
        else if x == 1 then { chessScreen.b01 = squareImage; }
        else if x == 2 then { chessScreen.b02 = squareImage; }
        else if x == 3 then { chessScreen.b03 = squareImage; }
        else if x == 4 then { chessScreen.b04 = squareImage; }
        else if x == 5 then { chessScreen.b05 = squareImage; }
        else if x == 6 then { chessScreen.b06 = squareImage; }
        else if x == 7 then { chessScreen.b07 = squareImage; }
    } else if y == 1 then {
        if x == 0 then { chessScreen.b10 = squareImage; }
        else if x == 1 then { chessScreen.b11 = squareImage; }
        else if x == 2 then { chessScreen.b12 = squareImage; }
        else if x == 3 then { chessScreen.b13 = squareImage; }
        else if x == 4 then { chessScreen.b14 = squareImage; }
        else if x == 5 then { chessScreen.b15 = squareImage; }
        else if x == 6 then { chessScreen.b16 = squareImage; }
        else if x == 7 then { chessScreen.b17 = squareImage; }
    } else if y == 2 then {
        if x == 0 then { chessScreen.b20 = squareImage; }
        else if x == 1 then { chessScreen.b21 = squareImage; }
        else if x == 2 then { chessScreen.b22 = squareImage; }
        else if x == 3 then { chessScreen.b23 = squareImage; }
        else if x == 4 then { chessScreen.b24 = squareImage; }
        else if x == 5 then { chessScreen.b25 = squareImage; }
        else if x == 6 then { chessScreen.b26 = squareImage; }
        else if x == 7 then { chessScreen.b27 = squareImage; }
    } else if y == 3 then {
        if x == 0 then { chessScreen.b30 = squareImage; }
        else if x == 1 then { chessScreen.b31 = squareImage; }
        else if x == 2 then { chessScreen.b32 = squareImage; }
        else if x == 3 then { chessScreen.b33 = squareImage; }
        else if x == 4 then { chessScreen.b34 = squareImage; }
        else if x == 5 then { chessScreen.b35 = squareImage; }
        else if x == 6 then { chessScreen.b36 = squareImage; }
        else if x == 7 then { chessScreen.b37 = squareImage; }
    } else if y == 4 then {
        if x == 0 then { chessScreen.b40 = squareImage; }
        else if x == 1 then { chessScreen.b41 = squareImage; }
        else if x == 2 then { chessScreen.b42 = squareImage; }
        else if x == 3 then { chessScreen.b43 = squareImage; }
        else if x == 4 then { chessScreen.b44 = squareImage; }
        else if x == 5 then { chessScreen.b45 = squareImage; }
        else if x == 6 then { chessScreen.b46 = squareImage; }
        else if x == 7 then { chessScreen.b47 = squareImage; }
    } else if y == 5 then {
        if x == 0 then { chessScreen.b50 = squareImage; }
        else if x == 1 then { chessScreen.b51 = squareImage; }
        else if x == 2 then { chessScreen.b52 = squareImage; }
        else if x == 3 then { chessScreen.b53 = squareImage; }
        else if x == 4 then { chessScreen.b54 = squareImage; }
        else if x == 5 then { chessScreen.b55 = squareImage; }
        else if x == 6 then { chessScreen.b56 = squareImage; }
        else if x == 7 then { chessScreen.b57 = squareImage; }
    } else if y == 6 then {
        if x == 0 then { chessScreen.b60 = squareImage; }
        else if x == 1 then { chessScreen.b61 = squareImage; }
        else if x == 2 then { chessScreen.b62 = squareImage; }
        else if x == 3 then { chessScreen.b63 = squareImage; }
        else if x == 4 then { chessScreen.b64 = squareImage; }
        else if x == 5 then { chessScreen.b65 = squareImage; }
        else if x == 6 then { chessScreen.b66 = squareImage; }
        else if x == 7 then { chessScreen.b67 = squareImage; }
    } else if y == 7 then {
        if x == 0 then { chessScreen.b70 = squareImage; }
        else if x == 1 then { chessScreen.b71 = squareImage; }
        else if x == 2 then { chessScreen.b72 = squareImage; }
        else if x == 3 then { chessScreen.b73 = squareImage; }
        else if x == 4 then { chessScreen.b74 = squareImage; }
        else if x == 5 then { chessScreen.b75 = squareImage; }
        else if x == 6 then { chessScreen.b76 = squareImage; }
        else if x == 7 then { chessScreen.b77 = squareImage; }
    }
}

// Show check indicators: yellow circle on king and all attacking pieces
showCheckIndicators() {
    // Check if current player's king is in check
    var inCheck: bool = call isKingInCheck(currentPlayer);
    if inCheck then {
        // Find the king's position
        var kingPos: posType = call findKing(currentPlayer);
        if kingPos.x != -1 then {
            // Mark the king with yellow circle
            call setIndicator(kingPos.x, kingPos.y, "check");
            
            // Determine opponent color
            var opponentColor: int;
            if currentPlayer == WHITE then {
                opponentColor = BLACK;
            } else {
                opponentColor = WHITE;
            }
            
            // Get all pieces attacking the king
            var attackers = call getAttackers(kingPos.x, kingPos.y, opponentColor);
            var i: int = 0;
            var len: int = attackers.length;
            for (i = 0; i < len; i = i + 1) {
                var attacker: posType = attackers[i];
                // Mark each attacking piece with yellow circle
                call setIndicator(attacker.x, attacker.y, "check");
            }
        }
    }
}

// Set indicator for a specific cell
// indicatorType can be: "normal", "capture", "check", "capture_check", "invalid", "checkmate", "defender", "attacker"
setIndicator(x: int, y: int, indicatorType: string) {
    var indicator: imagedata;
    if indicatorType == "capture_check" then {
        indicator = orangeCircleIndicator;
    } else if indicatorType == "attacker" then {
        indicator = orangeCircleIndicator;
    } else if indicatorType == "capture" then {
        indicator = redIndicator;
    } else if indicatorType == "check" then {
        indicator = yellowCircleIndicator;
    } else if indicatorType == "checkmate" then {
        indicator = redCrossBigIndicator;
    } else if indicatorType == "invalid" then {
        indicator = redCrossIndicator;
    } else if indicatorType == "move" then {
        indicator = blueArrowIndicator;
    } else if indicatorType == "defender" then {
        indicator = purpleCircleIndicator;
    } else {
        indicator = greenIndicator;  // "normal" or default
    }
    
    // Set the indicator based on position
    if y == 0 then {
        if x == 0 then { chessScreen.i00 = indicator; }
        if x == 1 then { chessScreen.i01 = indicator; }
        if x == 2 then { chessScreen.i02 = indicator; }
        if x == 3 then { chessScreen.i03 = indicator; }
        if x == 4 then { chessScreen.i04 = indicator; }
        if x == 5 then { chessScreen.i05 = indicator; }
        if x == 6 then { chessScreen.i06 = indicator; }
        if x == 7 then { chessScreen.i07 = indicator; }
    } else if y == 1 then {
        if x == 0 then { chessScreen.i10 = indicator; }
        if x == 1 then { chessScreen.i11 = indicator; }
        if x == 2 then { chessScreen.i12 = indicator; }
        if x == 3 then { chessScreen.i13 = indicator; }
        if x == 4 then { chessScreen.i14 = indicator; }
        if x == 5 then { chessScreen.i15 = indicator; }
        if x == 6 then { chessScreen.i16 = indicator; }
        if x == 7 then { chessScreen.i17 = indicator; }
    } else if y == 2 then {
        if x == 0 then { chessScreen.i20 = indicator; }
        if x == 1 then { chessScreen.i21 = indicator; }
        if x == 2 then { chessScreen.i22 = indicator; }
        if x == 3 then { chessScreen.i23 = indicator; }
        if x == 4 then { chessScreen.i24 = indicator; }
        if x == 5 then { chessScreen.i25 = indicator; }
        if x == 6 then { chessScreen.i26 = indicator; }
        if x == 7 then { chessScreen.i27 = indicator; }
    } else if y == 3 then {
        if x == 0 then { chessScreen.i30 = indicator; }
        if x == 1 then { chessScreen.i31 = indicator; }
        if x == 2 then { chessScreen.i32 = indicator; }
        if x == 3 then { chessScreen.i33 = indicator; }
        if x == 4 then { chessScreen.i34 = indicator; }
        if x == 5 then { chessScreen.i35 = indicator; }
        if x == 6 then { chessScreen.i36 = indicator; }
        if x == 7 then { chessScreen.i37 = indicator; }
    } else if y == 4 then {
        if x == 0 then { chessScreen.i40 = indicator; }
        if x == 1 then { chessScreen.i41 = indicator; }
        if x == 2 then { chessScreen.i42 = indicator; }
        if x == 3 then { chessScreen.i43 = indicator; }
        if x == 4 then { chessScreen.i44 = indicator; }
        if x == 5 then { chessScreen.i45 = indicator; }
        if x == 6 then { chessScreen.i46 = indicator; }
        if x == 7 then { chessScreen.i47 = indicator; }
    } else if y == 5 then {
        if x == 0 then { chessScreen.i50 = indicator; }
        if x == 1 then { chessScreen.i51 = indicator; }
        if x == 2 then { chessScreen.i52 = indicator; }
        if x == 3 then { chessScreen.i53 = indicator; }
        if x == 4 then { chessScreen.i54 = indicator; }
        if x == 5 then { chessScreen.i55 = indicator; }
        if x == 6 then { chessScreen.i56 = indicator; }
        if x == 7 then { chessScreen.i57 = indicator; }
    } else if y == 6 then {
        if x == 0 then { chessScreen.i60 = indicator; }
        if x == 1 then { chessScreen.i61 = indicator; }
        if x == 2 then { chessScreen.i62 = indicator; }
        if x == 3 then { chessScreen.i63 = indicator; }
        if x == 4 then { chessScreen.i64 = indicator; }
        if x == 5 then { chessScreen.i65 = indicator; }
        if x == 6 then { chessScreen.i66 = indicator; }
        if x == 7 then { chessScreen.i67 = indicator; }
    } else if y == 7 then {
        if x == 0 then { chessScreen.i70 = indicator; }
        if x == 1 then { chessScreen.i71 = indicator; }
        if x == 2 then { chessScreen.i72 = indicator; }
        if x == 3 then { chessScreen.i73 = indicator; }
        if x == 4 then { chessScreen.i74 = indicator; }
        if x == 5 then { chessScreen.i75 = indicator; }
        if x == 6 then { chessScreen.i76 = indicator; }
        if x == 7 then { chessScreen.i77 = indicator; }
    }
}

// Clear a single indicator at a specific position
clearIndicator(x: int, y: int) {
    // Set the indicator to null based on position
    if y == 0 then {
        if x == 0 then { chessScreen.i00 = null; }
        if x == 1 then { chessScreen.i01 = null; }
        if x == 2 then { chessScreen.i02 = null; }
        if x == 3 then { chessScreen.i03 = null; }
        if x == 4 then { chessScreen.i04 = null; }
        if x == 5 then { chessScreen.i05 = null; }
        if x == 6 then { chessScreen.i06 = null; }
        if x == 7 then { chessScreen.i07 = null; }
    } else if y == 1 then {
        if x == 0 then { chessScreen.i10 = null; }
        if x == 1 then { chessScreen.i11 = null; }
        if x == 2 then { chessScreen.i12 = null; }
        if x == 3 then { chessScreen.i13 = null; }
        if x == 4 then { chessScreen.i14 = null; }
        if x == 5 then { chessScreen.i15 = null; }
        if x == 6 then { chessScreen.i16 = null; }
        if x == 7 then { chessScreen.i17 = null; }
    } else if y == 2 then {
        if x == 0 then { chessScreen.i20 = null; }
        if x == 1 then { chessScreen.i21 = null; }
        if x == 2 then { chessScreen.i22 = null; }
        if x == 3 then { chessScreen.i23 = null; }
        if x == 4 then { chessScreen.i24 = null; }
        if x == 5 then { chessScreen.i25 = null; }
        if x == 6 then { chessScreen.i26 = null; }
        if x == 7 then { chessScreen.i27 = null; }
    } else if y == 3 then {
        if x == 0 then { chessScreen.i30 = null; }
        if x == 1 then { chessScreen.i31 = null; }
        if x == 2 then { chessScreen.i32 = null; }
        if x == 3 then { chessScreen.i33 = null; }
        if x == 4 then { chessScreen.i34 = null; }
        if x == 5 then { chessScreen.i35 = null; }
        if x == 6 then { chessScreen.i36 = null; }
        if x == 7 then { chessScreen.i37 = null; }
    } else if y == 4 then {
        if x == 0 then { chessScreen.i40 = null; }
        if x == 1 then { chessScreen.i41 = null; }
        if x == 2 then { chessScreen.i42 = null; }
        if x == 3 then { chessScreen.i43 = null; }
        if x == 4 then { chessScreen.i44 = null; }
        if x == 5 then { chessScreen.i45 = null; }
        if x == 6 then { chessScreen.i46 = null; }
        if x == 7 then { chessScreen.i47 = null; }
    } else if y == 5 then {
        if x == 0 then { chessScreen.i50 = null; }
        if x == 1 then { chessScreen.i51 = null; }
        if x == 2 then { chessScreen.i52 = null; }
        if x == 3 then { chessScreen.i53 = null; }
        if x == 4 then { chessScreen.i54 = null; }
        if x == 5 then { chessScreen.i55 = null; }
        if x == 6 then { chessScreen.i56 = null; }
        if x == 7 then { chessScreen.i57 = null; }
    } else if y == 6 then {
        if x == 0 then { chessScreen.i60 = null; }
        if x == 1 then { chessScreen.i61 = null; }
        if x == 2 then { chessScreen.i62 = null; }
        if x == 3 then { chessScreen.i63 = null; }
        if x == 4 then { chessScreen.i64 = null; }
        if x == 5 then { chessScreen.i65 = null; }
        if x == 6 then { chessScreen.i66 = null; }
        if x == 7 then { chessScreen.i67 = null; }
    } else if y == 7 then {
        if x == 0 then { chessScreen.i70 = null; }
        if x == 1 then { chessScreen.i71 = null; }
        if x == 2 then { chessScreen.i72 = null; }
        if x == 3 then { chessScreen.i73 = null; }
        if x == 4 then { chessScreen.i74 = null; }
        if x == 5 then { chessScreen.i75 = null; }
        if x == 6 then { chessScreen.i76 = null; }
        if x == 7 then { chessScreen.i77 = null; }
    }
}

// Set a custom indicator image at a specific cell
setCustomIndicator(x: int, y: int, indicator: imagedata) {
    // Set the custom indicator based on position
    if y == 0 then {
        if x == 0 then { chessScreen.i00 = indicator; }
        if x == 1 then { chessScreen.i01 = indicator; }
        if x == 2 then { chessScreen.i02 = indicator; }
        if x == 3 then { chessScreen.i03 = indicator; }
        if x == 4 then { chessScreen.i04 = indicator; }
        if x == 5 then { chessScreen.i05 = indicator; }
        if x == 6 then { chessScreen.i06 = indicator; }
        if x == 7 then { chessScreen.i07 = indicator; }
    } else if y == 1 then {
        if x == 0 then { chessScreen.i10 = indicator; }
        if x == 1 then { chessScreen.i11 = indicator; }
        if x == 2 then { chessScreen.i12 = indicator; }
        if x == 3 then { chessScreen.i13 = indicator; }
        if x == 4 then { chessScreen.i14 = indicator; }
        if x == 5 then { chessScreen.i15 = indicator; }
        if x == 6 then { chessScreen.i16 = indicator; }
        if x == 7 then { chessScreen.i17 = indicator; }
    } else if y == 2 then {
        if x == 0 then { chessScreen.i20 = indicator; }
        if x == 1 then { chessScreen.i21 = indicator; }
        if x == 2 then { chessScreen.i22 = indicator; }
        if x == 3 then { chessScreen.i23 = indicator; }
        if x == 4 then { chessScreen.i24 = indicator; }
        if x == 5 then { chessScreen.i25 = indicator; }
        if x == 6 then { chessScreen.i26 = indicator; }
        if x == 7 then { chessScreen.i27 = indicator; }
    } else if y == 3 then {
        if x == 0 then { chessScreen.i30 = indicator; }
        if x == 1 then { chessScreen.i31 = indicator; }
        if x == 2 then { chessScreen.i32 = indicator; }
        if x == 3 then { chessScreen.i33 = indicator; }
        if x == 4 then { chessScreen.i34 = indicator; }
        if x == 5 then { chessScreen.i35 = indicator; }
        if x == 6 then { chessScreen.i36 = indicator; }
        if x == 7 then { chessScreen.i37 = indicator; }
    } else if y == 4 then {
        if x == 0 then { chessScreen.i40 = indicator; }
        if x == 1 then { chessScreen.i41 = indicator; }
        if x == 2 then { chessScreen.i42 = indicator; }
        if x == 3 then { chessScreen.i43 = indicator; }
        if x == 4 then { chessScreen.i44 = indicator; }
        if x == 5 then { chessScreen.i45 = indicator; }
        if x == 6 then { chessScreen.i46 = indicator; }
        if x == 7 then { chessScreen.i47 = indicator; }
    } else if y == 5 then {
        if x == 0 then { chessScreen.i50 = indicator; }
        if x == 1 then { chessScreen.i51 = indicator; }
        if x == 2 then { chessScreen.i52 = indicator; }
        if x == 3 then { chessScreen.i53 = indicator; }
        if x == 4 then { chessScreen.i54 = indicator; }
        if x == 5 then { chessScreen.i55 = indicator; }
        if x == 6 then { chessScreen.i56 = indicator; }
        if x == 7 then { chessScreen.i57 = indicator; }
    } else if y == 6 then {
        if x == 0 then { chessScreen.i60 = indicator; }
        if x == 1 then { chessScreen.i61 = indicator; }
        if x == 2 then { chessScreen.i62 = indicator; }
        if x == 3 then { chessScreen.i63 = indicator; }
        if x == 4 then { chessScreen.i64 = indicator; }
        if x == 5 then { chessScreen.i65 = indicator; }
        if x == 6 then { chessScreen.i66 = indicator; }
        if x == 7 then { chessScreen.i67 = indicator; }
    } else if y == 7 then {
        if x == 0 then { chessScreen.i70 = indicator; }
        if x == 1 then { chessScreen.i71 = indicator; }
        if x == 2 then { chessScreen.i72 = indicator; }
        if x == 3 then { chessScreen.i73 = indicator; }
        if x == 4 then { chessScreen.i74 = indicator; }
        if x == 5 then { chessScreen.i75 = indicator; }
        if x == 6 then { chessScreen.i76 = indicator; }
        if x == 7 then { chessScreen.i77 = indicator; }
    }
}

// Set a piece image at a specific cell (used for both yellow and normal pieces)
setPieceImage(x: int, y: int, pieceImage: imagedata) {
    // Set the piece image based on position
    if y == 0 then {
        if x == 0 then { chessScreen.c00 = pieceImage; }
        if x == 1 then { chessScreen.c01 = pieceImage; }
        if x == 2 then { chessScreen.c02 = pieceImage; }
        if x == 3 then { chessScreen.c03 = pieceImage; }
        if x == 4 then { chessScreen.c04 = pieceImage; }
        if x == 5 then { chessScreen.c05 = pieceImage; }
        if x == 6 then { chessScreen.c06 = pieceImage; }
        if x == 7 then { chessScreen.c07 = pieceImage; }
    } else if y == 1 then {
        if x == 0 then { chessScreen.c10 = pieceImage; }
        if x == 1 then { chessScreen.c11 = pieceImage; }
        if x == 2 then { chessScreen.c12 = pieceImage; }
        if x == 3 then { chessScreen.c13 = pieceImage; }
        if x == 4 then { chessScreen.c14 = pieceImage; }
        if x == 5 then { chessScreen.c15 = pieceImage; }
        if x == 6 then { chessScreen.c16 = pieceImage; }
        if x == 7 then { chessScreen.c17 = pieceImage; }
    } else if y == 2 then {
        if x == 0 then { chessScreen.c20 = pieceImage; }
        if x == 1 then { chessScreen.c21 = pieceImage; }
        if x == 2 then { chessScreen.c22 = pieceImage; }
        if x == 3 then { chessScreen.c23 = pieceImage; }
        if x == 4 then { chessScreen.c24 = pieceImage; }
        if x == 5 then { chessScreen.c25 = pieceImage; }
        if x == 6 then { chessScreen.c26 = pieceImage; }
        if x == 7 then { chessScreen.c27 = pieceImage; }
    } else if y == 3 then {
        if x == 0 then { chessScreen.c30 = pieceImage; }
        if x == 1 then { chessScreen.c31 = pieceImage; }
        if x == 2 then { chessScreen.c32 = pieceImage; }
        if x == 3 then { chessScreen.c33 = pieceImage; }
        if x == 4 then { chessScreen.c34 = pieceImage; }
        if x == 5 then { chessScreen.c35 = pieceImage; }
        if x == 6 then { chessScreen.c36 = pieceImage; }
        if x == 7 then { chessScreen.c37 = pieceImage; }
    } else if y == 4 then {
        if x == 0 then { chessScreen.c40 = pieceImage; }
        if x == 1 then { chessScreen.c41 = pieceImage; }
        if x == 2 then { chessScreen.c42 = pieceImage; }
        if x == 3 then { chessScreen.c43 = pieceImage; }
        if x == 4 then { chessScreen.c44 = pieceImage; }
        if x == 5 then { chessScreen.c45 = pieceImage; }
        if x == 6 then { chessScreen.c46 = pieceImage; }
        if x == 7 then { chessScreen.c47 = pieceImage; }
    } else if y == 5 then {
        if x == 0 then { chessScreen.c50 = pieceImage; }
        if x == 1 then { chessScreen.c51 = pieceImage; }
        if x == 2 then { chessScreen.c52 = pieceImage; }
        if x == 3 then { chessScreen.c53 = pieceImage; }
        if x == 4 then { chessScreen.c54 = pieceImage; }
        if x == 5 then { chessScreen.c55 = pieceImage; }
        if x == 6 then { chessScreen.c56 = pieceImage; }
        if x == 7 then { chessScreen.c57 = pieceImage; }
    } else if y == 6 then {
        if x == 0 then { chessScreen.c60 = pieceImage; }
        if x == 1 then { chessScreen.c61 = pieceImage; }
        if x == 2 then { chessScreen.c62 = pieceImage; }
        if x == 3 then { chessScreen.c63 = pieceImage; }
        if x == 4 then { chessScreen.c64 = pieceImage; }
        if x == 5 then { chessScreen.c65 = pieceImage; }
        if x == 6 then { chessScreen.c66 = pieceImage; }
        if x == 7 then { chessScreen.c67 = pieceImage; }
    } else if y == 7 then {
        if x == 0 then { chessScreen.c70 = pieceImage; }
        if x == 1 then { chessScreen.c71 = pieceImage; }
        if x == 2 then { chessScreen.c72 = pieceImage; }
        if x == 3 then { chessScreen.c73 = pieceImage; }
        if x == 4 then { chessScreen.c74 = pieceImage; }
        if x == 5 then { chessScreen.c75 = pieceImage; }
        if x == 6 then { chessScreen.c76 = pieceImage; }
        if x == 7 then { chessScreen.c77 = pieceImage; }
    }
}

// Get chess piece letter for move notation (K, Q, R, B, N, p)
getPieceLetter(pieceType: int) return string {
    if pieceType == KING then { return "K"; }
    if pieceType == QUEEN then { return "Q"; }
    if pieceType == ROOK then { return "R"; }
    if pieceType == BISHOP then { return "B"; }
    if pieceType == KNIGHT then { return "N"; }
    if pieceType == PAWN then { return "p"; }
    return "";
}

// Get chess piece Unicode icon for move history display
getPieceIcon(pieceType: int, pieceColor: int) return string {
    // Unicode chess symbols
    // Note: In Unicode chess symbols, - (U+2654-2659) represent WHITE pieces
    // and - (U+265A-265F) represent BLACK pieces
    if pieceColor == WHITE then {
        if pieceType == KING then { return ""; }
        if pieceType == QUEEN then { return ""; }
        if pieceType == ROOK then { return ""; }
        if pieceType == BISHOP then { return ""; }
        if pieceType == KNIGHT then { return ""; }
        if pieceType == PAWN then { return ""; }
    } else {
        // BLACK pieces
        if pieceType == KING then { return ""; }
        if pieceType == QUEEN then { return ""; }
        if pieceType == ROOK then { return ""; }
        if pieceType == BISHOP then { return ""; }
        if pieceType == KNIGHT then { return ""; }
        if pieceType == PAWN then { return ""; }
    }
    return "";
}

// Convert board coordinates to algebraic notation (e.g., 0,0 -> a8, 7,7 -> h1)
coordsToAlgebraic(x: int, y: int) return string {
    var files: string = "abcdefgh";
    var file: string = call str.charAt(files, x);
    var rank: int = 8 - y;  // y=0 is rank 8, y=7 is rank 1
    return file + rank;
}

// Format a move for the move history with piece icon, from position, and to position
formatMove(fromX: int, fromY: int, toX: int, toY: int, pieceType: int, pieceColor: int, isCapture: bool, capturedPieceType: int, capturedPieceColor: int) return string {
    var pieceIcon: string = call getPieceIcon(pieceType, pieceColor);
    var pieceLetter: string = call getPieceLetter(pieceType);
    var fromSquare: string = call coordsToAlgebraic(fromX, fromY);
    var toSquare: string = call coordsToAlgebraic(toX, toY);
    
    // Format: [Icon][Letter] [from]-[to] or [from]x[to][CapturedIcon] for captures
    var moveText: string;
    
    if isCapture then {
        var capturedIcon: string = call getPieceIcon(capturedPieceType, capturedPieceColor);
        moveText = pieceIcon + pieceLetter + " " + fromSquare + "x" + toSquare + capturedIcon;
    } else {
        moveText = pieceIcon + pieceLetter + " " + fromSquare + "-" + toSquare;
    }
    
    return moveText;
}

// Select a piece (change to yellow)
selectPiece(x: int, y: int) {
    var cellValue: int = call getPieceAt(x, y);
    if cellValue != -1 then {
        var cell = ChessCell(cellValue);
        if cell.pieceType != EMPTY then {
            var yellowPiece: imagedata = call getYellowPiece(cell.pieceType, cell.pieceColor);
            if yellowPiece != null then {
                call setPieceImage(x, y, yellowPiece);
            }
        }
    }
}

// Select an opponent piece (highlight with gray overlay)
selectOpponentPiece(x: int, y: int) {
    var cellValue: int = call getPieceAt(x, y);
    if cellValue != -1 then {
        var cell = ChessCell(cellValue);
        if cell.pieceType != EMPTY then {
            // Get the normal piece image
            var normalPiece: imagedata = call getNormalPiece(cell.pieceType, cell.pieceColor);
            if normalPiece != null then {
                // Create a canvas with the piece and gray overlay
                var pieceCanvas: canvas = call canvas.create(60, 60, "opponent_piece_select");
                call canvas.clear(pieceCanvas);
                
                // Get the actual size of the piece image to center it
                var pieceWidth: int = call image.getWidth(normalPiece);
                var pieceHeight: int = call image.getHeight(normalPiece);
                
                // Calculate center position
                var centerX: int = (60 - pieceWidth) / 2;
                var centerY: int = (60 - pieceHeight) / 2;
                
                // Draw the normal piece centered
                call draw.image(pieceCanvas, normalPiece, centerX, centerY);
                
                // Add a semi-transparent gray overlay
                call style.setFill(pieceCanvas, "#80808060");  // Gray with 37% opacity
                call draw.rect(pieceCanvas, 0, 0, 60, 60, true);
                
                // Convert to image and set
                var grayPiece: imagedata = call canvas.toImage(pieceCanvas);
                call setPieceImage(x, y, grayPiece);
            }
        }
    }
}

// Deselect a piece (change back to normal)
deselectPiece(x: int, y: int) {
    var cellValue: int = call getPieceAt(x, y);
    if cellValue != -1 then {
        var cell = ChessCell(cellValue);
        if cell.pieceType != EMPTY then {
            var normalPiece: imagedata = call getNormalPiece(cell.pieceType, cell.pieceColor);
            if normalPiece != null then {
                call setPieceImage(x, y, normalPiece);
            }
        }
    }
}

// Move a piece from source to destination
movePiece(fromX: int, fromY: int, toX: int, toY: int) {
    // Get the piece being moved
    var fromIdx: int = call boardIndex(fromY, fromX);
    var fromCellValue: int = board[fromIdx];
    var fromCell = ChessCell(fromCellValue);
    
    // Get the destination cell info
    var toIdx: int = call boardIndex(toY, toX);
    var toCellValue: int = board[toIdx];
    var toCell = ChessCell(toCellValue);
    
    // Check if this is a castling move (king moving 2 squares horizontally)
    var isCastling: bool = false;
    if fromCell.pieceType == KING then {
        var xDiff: int = toX - fromX;
        if xDiff == 2 || xDiff == -2 then {
            isCastling = true;
            
            // Determine which rook to move
            var rookFromX: int;
            var rookToX: int;
            var rookY: int = fromY;
            
            if xDiff == 2 then {
                // Kingside castling (O-O): Rook moves from h-file (x=7) to f-file (x=5)
                rookFromX = 7;
                rookToX = 5;
            } else {
                // Queenside castling (O-O-O): Rook moves from a-file (x=0) to d-file (x=3)
                rookFromX = 0;
                rookToX = 3;
            }
            
            // Verify the rook exists before moving it
            var rookFromIdx: int = call boardIndex(rookY, rookFromX);
            var rookCellValue: int = board[rookFromIdx];
            var rookCell = ChessCell(rookCellValue);
            
            // Validate rook is present (should always be true if canCastle validated correctly)
            if rookCell.pieceType == ROOK && rookCell.pieceColor == fromCell.pieceColor then {
                var rookToIdx: int = call boardIndex(rookY, rookToX);
                var rookToCellValue: int = board[rookToIdx];
                var rookToCell = ChessCell(rookToCellValue);
                
                // Move rook on board array
                board[rookToIdx] = call encodeCellValue(rookToCell.cellColor, rookCell.pieceType, rookCell.pieceColor);
                // Clear the source square but preserve cell color - piece color is irrelevant for empty squares
                board[rookFromIdx] = call encodeCellValue(rookCell.cellColor, EMPTY, rookCell.pieceColor);
                
                // Move rook on screen
                var rookImage: imagedata = call getNormalPiece(rookCell.pieceType, rookCell.pieceColor);
                if rookImage != null then {
                    call setPieceImage(rookToX, rookY, rookImage);
                }
                call setPieceImage(rookFromX, rookY, transparentClear);
            } else {
                print "WARNING: Expected rook not found at castling position!";
            }
        }
    }
    
    // Check for en passant capture BEFORE moving the piece
    var isEnPassantCapture: bool = false;
    var capturedPawnX: int = -1;
    var capturedPawnY: int = -1;
    
    if fromCell.pieceType == PAWN && toX != fromX then {
        // Pawn is moving diagonally - check if destination is empty (en passant)
        var targetCellValue: int = call getPieceAt(toX, toY);
        if targetCellValue != -1 then {
            var targetCell = ChessCell(targetCellValue);
            if targetCell.pieceType == EMPTY then {
                // Diagonal move to empty square - this is en passant
                isEnPassantCapture = true;
                capturedPawnX = toX;
                capturedPawnY = fromY;
            }
        }
    }
    
    // Update the board array - move the king (or regular piece)
    // Set destination to the moved piece (preserve cell color from destination)
    board[toIdx] = call encodeCellValue(toCell.cellColor, fromCell.pieceType, fromCell.pieceColor);
    
    // Clear the source cell (keep cell color, set piece to EMPTY)
    // Piece color is irrelevant for empty squares, but keep it for consistency
    board[fromIdx] = call encodeCellValue(fromCell.cellColor, EMPTY, fromCell.pieceColor);
    
    // Update the screen images
    // Get the normal piece image (not yellow) for the destination
    var pieceImage: imagedata = call getNormalPiece(fromCell.pieceType, fromCell.pieceColor);
    if pieceImage != null then {
        call setPieceImage(toX, toY, pieceImage);
    }
    
    // Clear the source cell image on screen with transparent rectangle
    call setPieceImage(fromX, fromY, transparentClear);
    
    // Handle en passant capture if detected
    if isEnPassantCapture then {
        // Remove the captured pawn (it's at capturedPawnX, capturedPawnY)
        var capturedPawnIdx: int = call boardIndex(capturedPawnY, capturedPawnX);
        var capturedPawnCell = ChessCell(board[capturedPawnIdx]);
        
        // Clear the captured pawn from the board
        board[capturedPawnIdx] = call encodeCellValue(capturedPawnCell.cellColor, EMPTY, capturedPawnCell.pieceColor);
        
        // Clear the captured pawn's image on screen
        call setPieceImage(capturedPawnX, capturedPawnY, transparentClear);
        
        // Track the captured pawn for display
        call addCapturedPiece(PAWN, capturedPawnCell.pieceColor);
    }
    
    // Reset en passant state before checking for new double pawn move
    // En passant is only valid for one turn
    enPassantTargetX = -1;
    enPassantTargetY = -1;
    
    // Check if this is a pawn double move (moving 2 squares forward)
    // If so, set en passant target for next turn
    if fromCell.pieceType == PAWN then {
        var yDiff: int = toY - fromY;
        if yDiff == 2 || yDiff == -2 then {
            // Pawn moved two squares - set en passant target
            enPassantTargetX = toX;
            enPassantTargetY = toY;
        }
    }
    
    // Track piece movements for castling rules
    if fromCell.pieceType == KING then {
        if fromCell.pieceColor == WHITE then {
            whiteKingMoved = true;
        } else {
            blackKingMoved = true;
        }
    } else if fromCell.pieceType == ROOK then {
        // Check which rook moved
        if fromCell.pieceColor == WHITE then {
            if fromX == 0 && fromY == 7 then {
                whiteQueensideRookMoved = true;
            } else if fromX == 7 && fromY == 7 then {
                whiteKingsideRookMoved = true;
            }
        } else {
            if fromX == 0 && fromY == 0 then {
                blackQueensideRookMoved = true;
            } else if fromX == 7 && fromY == 0 then {
                blackKingsideRookMoved = true;
            }
        }
    }
}

// Handle cell click - select piece and show valid moves, or move piece if valid destination
handleCellClick(x: int, y: int) {
    // Don't allow moves if game is over
    if gameOver then {
        return;
    }
    
    // Check if a piece is already selected
    if selectedX >= 0 && selectedY >= 0 then {
        // A piece is selected - check if clicked position is a valid move destination
        var moves = call validMoves(selectedX, selectedY);
        var isValidMove: bool = false;
        var len: int = moves.length;
        var i: int = 0;
        
        // Check if the clicked position is in the valid moves list
        for (i = 0; i < len; i = i + 1) {
            var move = moves[i];
            if move.x == x && move.y == y then {
                isValidMove = true;
            }
        }
        
        if isValidMove then {
            // Safety check: Verify the selected piece belongs to the current player
            var selectedPieceCellValue: int = call getPieceAt(selectedX, selectedY);
            if selectedPieceCellValue != -1 then {
                var selectedPieceCell = ChessCell(selectedPieceCellValue);
                if selectedPieceCell.pieceColor != currentPlayer then {
                    chessScreen.statusMessage = "It's not your turn to move that piece!";
                    call clearIndicators();
                    
                    // Redraw last move blue arrows and circles if they exist
                    if lastMoveFromX >= 0 && lastMoveFromY >= 0 && lastMoveToX >= 0 && lastMoveToY >= 0 then {
                        call showLastMove(lastMoveFromX, lastMoveFromY, lastMoveToX, lastMoveToY);
                    }
                    
                    // Show check indicators if king is in check
                    call showCheckIndicators();
                    
                    selectedX = -1;
                    selectedY = -1;
                    return;
                }
            }
            
            // Check if this move would expose the player's own king
            var exposesKing: bool = call wouldMoveExposeKing(selectedX, selectedY, x, y, currentPlayer);
            
            if exposesKing then {
                chessScreen.statusMessage = "Invalid move - would expose your king!";
                call clearIndicators();
                
                // Redraw last move blue arrows and circles if they exist
                if lastMoveFromX >= 0 && lastMoveFromY >= 0 && lastMoveToX >= 0 && lastMoveToY >= 0 then {
                    call showLastMove(lastMoveFromX, lastMoveFromY, lastMoveToX, lastMoveToY);
                }
                
                // Show check indicators if king is in check
                call showCheckIndicators();
                
                call deselectPiece(selectedX, selectedY);
                selectedX = -1;
                selectedY = -1;
                return;
            }
            
            // Get information about the move before executing it
            var sourceCellValue: int = call getPieceAt(selectedX, selectedY);
            var destCellValue: int = call getPieceAt(x, y);
            var isCapture: bool = false;
            var capturedPieceType: int = EMPTY;
            var capturedPieceColor: int = WHITE;
            
            // Check if this is a capture move and store captured piece info
            if destCellValue != -1 then {
                var destCell = ChessCell(destCellValue);
                if destCell.pieceType != EMPTY then {
                    isCapture = true;
                    capturedPieceType = destCell.pieceType;
                    capturedPieceColor = destCell.pieceColor;
                    // Track the captured piece for display
                    call addCapturedPiece(capturedPieceType, capturedPieceColor);
                }
            }
            
            var sourceCell = ChessCell(sourceCellValue);
            var movingPieceType: int = sourceCell.pieceType;
            var movingPieceColor: int = sourceCell.pieceColor;
            
            // Deselect the piece (turn yellow back to normal) before moving
            call deselectPiece(selectedX, selectedY);
            
            // Store move coordinates before clearing selection
            var moveFromX: int = selectedX;
            var moveFromY: int = selectedY;
            var moveToX: int = x;
            var moveToY: int = y;
            
            // Save game state before making the move (for undo/redo)
            call saveGameState();
            
            // Move the piece
            call movePiece(moveFromX, moveFromY, moveToX, moveToY);
            
            // Format and add move to history
            var moveNotation: string = call formatMove(moveFromX, moveFromY, moveToX, moveToY, movingPieceType, movingPieceColor, isCapture, capturedPieceType, capturedPieceColor);
            var playerName: string;
            if currentPlayer == WHITE then {
                playerName = "White";
            } else {
                playerName = "Black";
            }
            var moveEntry: string = playerName + ": " + moveNotation + "\n";
            chessScreen.moveHistory = chessScreen.moveHistory + moveEntry;
            
            // Clear indicators and selection (valid move indicators)
            call clearIndicators();
            selectedX = -1;
            selectedY = -1;
            
            // Show the last move with blue arrows (after clearing other indicators)
            call showLastMove(moveFromX, moveFromY, moveToX, moveToY);
            
            // Switch to next player
            if currentPlayer == WHITE then {
                currentPlayer = BLACK;
            } else {
                currentPlayer = WHITE;
            }
            
            // Check for checkmate or stalemate
            var isInCheckmate: bool = call isCheckmate(currentPlayer);
            var isInStalemate: bool = call isStalemate(currentPlayer);
            
            if isInCheckmate then {
                gameOver = true;
                
                // Stop the game timer
                call thread.timerStop("chessScreen.chessTimer");
                
                // Mark the losing king with a larger red cross
                var kingPos: posType = call findKing(currentPlayer);
                if kingPos.x >= 0 then {
                    call setIndicator(kingPos.x, kingPos.y, "checkmate");
                }
                
                // Update status message
                var winner: string;
                if currentPlayer == WHITE then {
                    winner = "Black";
                    chessScreen.statusMessage = "Checkmate! Black wins!";
                } else {
                    winner = "White";
                    chessScreen.statusMessage = "Checkmate! White wins!";
                }
                
                // Show game over dialog
                call showGameOverDialog(winner, "checkmate");
            } else if isInStalemate then {
                gameOver = true;
                
                // Stop the game timer
                call thread.timerStop("chessScreen.chessTimer");
                
                // Mark both kings with red crosses
                var whiteKingPos: posType = call findKing(WHITE);
                var blackKingPos: posType = call findKing(BLACK);
                
                if whiteKingPos.x >= 0 then {
                    call setIndicator(whiteKingPos.x, whiteKingPos.y, "invalid");
                }
                if blackKingPos.x >= 0 then {
                    call setIndicator(blackKingPos.x, blackKingPos.y, "invalid");
                }
                
                chessScreen.statusMessage = "Stalemate! Game is a draw.";
                
                // Show game over dialog
                call showGameOverDialog("Draw", "stalemate");
            } else {
                // Normal game continues
                if currentPlayer == BLACK then {
                    chessScreen.statusMessage = "Black to move";
                } else {
                    chessScreen.statusMessage = "White to move";
                }
            }
            
            call updateTimerColors();
            
            // Update undo/redo button states (for 2-player games)
            call updateUndoRedoButtons();
            
            // In 1-player mode, trigger computer move if it's now the computer's turn
            if selectedGameMode == "1 player" && !gameOver then {
                // Check if current player is the computer
                if currentPlayer != humanPlayerColor then {
                    // Use util.runlater to allow UI to update and show human player's blue circles
                    // before computer starts calculating. This gives the JavaFX thread a chance
                    // to render the screen updates, then schedules the computer move asynchronously.
                    call util.runlater("makeComputerMove");
                }
            }
            
            return;
        } else {
            // Deselect the currently selected piece before processing new selection
            call deselectPiece(selectedX, selectedY);
            // Reset selection variables so the click can be processed as a new selection
            selectedX = -1;
            selectedY = -1;
        }
    }
    
    // Restore previous opponent piece to normal if one was selected
    if lastOpponentX >= 0 && lastOpponentY >= 0 then {
        call deselectPiece(lastOpponentX, lastOpponentY);
        lastOpponentX = -1;
        lastOpponentY = -1;
    }
    
    // Clear previous indicators
    call clearIndicators();
    
    // Redraw last move blue arrows and circles if they exist
    if lastMoveFromX >= 0 && lastMoveFromY >= 0 && lastMoveToX >= 0 && lastMoveToY >= 0 then {
        call showLastMove(lastMoveFromX, lastMoveFromY, lastMoveToX, lastMoveToY);
    }
    
    // Show check indicators if king is in check
    call showCheckIndicators();
    
    // Get piece at clicked position
    var cellValue: int = call getPieceAt(x, y);
    
    if cellValue == -1 then {
        selectedX = -1;
        selectedY = -1;
        return;
    }
    
    var cell = ChessCell(cellValue);
    
    // If empty cell or clicking same piece, deselect
    if cell.pieceType == EMPTY || (selectedX == x && selectedY == y) then {
        selectedX = -1;
        selectedY = -1;
        return;
    }
    
    // Check if clicking on opponent's piece - show defenders and attackers
    if cell.pieceColor != currentPlayer then {
        // Track this opponent piece so we can restore it later
        lastOpponentX = x;
        lastOpponentY = y;
        
        // Highlight the opponent piece with gray overlay to show it's "selected"
        call selectOpponentPiece(x, y);
        
        // Get all defenders of this piece
        var defenders = call getDefenders(x, y);
        var defenderCount: int = defenders.length;
        
        // Show purple circles on all defender positions
        var i: int = 0;
        for (i = 0; i < defenderCount; i = i + 1) {
            var defender: posType = defenders[i];
            call setIndicator(defender.x, defender.y, "defender");
        }
        
        // Get all attackers of this piece (pieces of the current player's color that can attack it)
        var attackers = call getAttackers(x, y, currentPlayer);
        var attackerCount: int = attackers.length;
        
        // Show orange circles on all attacker positions
        var j: int = 0;
        for (j = 0; j < attackerCount; j = j + 1) {
            var attacker: posType = attackers[j];
            call setIndicator(attacker.x, attacker.y, "attacker");
        }
        
        // Update status message to show defender and attacker counts
        var defenderText: string;
        if defenderCount == 0 then {
            defenderText = "No defenders";
        } else if defenderCount == 1 then {
            defenderText = "1 defender";
        } else {
            defenderText = defenderCount + " defenders";
        }
        
        var attackerText: string;
        if attackerCount == 0 then {
            attackerText = "no attackers";
        } else if attackerCount == 1 then {
            attackerText = "1 attacker";
        } else {
            attackerText = attackerCount + " attackers";
        }
        
        chessScreen.statusMessage = "Opponent piece: " + defenderText + ", " + attackerText;
        
        // DO NOT set selectedX and selectedY for opponent pieces - they should not be selectable
        // selectedX and selectedY remain -1 to prevent moving opponent pieces
        return;
    }
    
    // Select the piece - update state and change to yellow
    selectedX = x;
    selectedY = y;
    call selectPiece(x, y);
    
    // Get valid moves for this piece
    var moves = call validMoves(x, y);
    var len: int = moves.length;
    
    // Show indicators for each valid move
    var i: int = 0;
    for (i = 0; i < len; i = i + 1) {
        var move = moves[i];
        
        // Check if this move would expose own king (invalid move - red cross)
        var exposesKing: bool = call wouldMoveExposeKing(x, y, move.x, move.y, currentPlayer);
        
        if exposesKing then {
            call setIndicator(move.x, move.y, "invalid");
        } else {
            // Check if this move captures an enemy piece
            var targetCellValue: int = call getPieceAt(move.x, move.y);
            var isCapture: bool = false;
            
            if targetCellValue != -1 then {
                var targetCell = ChessCell(targetCellValue);
                if targetCell.pieceType != EMPTY then {
                    isCapture = true;
                }
            }
            
            // Check for en passant capture - pawn moving diagonally to empty square
            if !isCapture && cell.pieceType == PAWN && move.x != x then {
                // Pawn moving diagonally
                if targetCellValue != -1 then {
                    var targetCell2 = ChessCell(targetCellValue);
                    if targetCell2.pieceType == EMPTY then {
                        // Diagonal move to empty square - check if it's en passant
                        if enPassantTargetX == move.x && enPassantTargetY == y then {
                            // This is an en passant capture
                            isCapture = true;
                        }
                    }
                }
            }
            
            // Check if this move would check the opponent's king
            var checksOpponent: bool = call wouldMoveCheckOpponent(x, y, move.x, move.y, currentPlayer);
            
            // Prioritize orange indicator for capture + check combination
            if checksOpponent && isCapture then {
                call setIndicator(move.x, move.y, "capture_check");
            } else if checksOpponent then {
                call setIndicator(move.x, move.y, "check");
            } else if isCapture then {
                call setIndicator(move.x, move.y, "capture");
            } else {
                call setIndicator(move.x, move.y, "normal");
            }
        }
    }
    
    // Show defenders of the selected piece with purple circles
    var defenders = call getDefenders(x, y);
    var defenderCount: int = defenders.length;
    
    var j: int = 0;
    for (j = 0; j < defenderCount; j = j + 1) {
        var defender: posType = defenders[j];
        call setIndicator(defender.x, defender.y, "defender");
    }
}

encodeCellValue(cellColor: int, pieceType: int, pieceColor: int) return int {
    return cellColor + (pieceType * 2) + (pieceColor * 128);
}

getPieceSymbol(cellValue: int) return string {
    var cell = ChessCell(cellValue);
    var pt: int = cell.pieceType;
    var pc: int = cell.pieceColor;
    
    if pt == 0 then {
        return "";
    }
    
    if pc == 0 then {
        return whitePieces[pt];
    } else {
        return blackPieces[pt];
    }
}

formatTimer(seconds: int) return string {
    // Check if unlimited time
    if seconds >= UNLIMITED_TIME then {
        return "Unlimited";
    }
    
    var mins: int = seconds / 60;
    var secs: int = call modulo(seconds, 60);
    var minsStr: string = call str.lpad(string(mins), 2, "0");
    var secsStr: string = call str.lpad(string(secs), 2, "0");
    return minsStr + ":" + secsStr;
}

// Format timer with decimal places (for display with tenths of seconds)
formatTimerDecimal(deciseconds: int) return string {
    // Check if unlimited time (deciseconds would be >= UNLIMITED_TIME * 10)
    if deciseconds >= UNLIMITED_TIME * 10 then {
        return "Unlimited";
    }
    
    var totalSeconds: int = deciseconds / 10;
    var tenths: int = call modulo(deciseconds, 10);
    var mins: int = totalSeconds / 60;
    var secs: int = call modulo(totalSeconds, 60);
    var minsStr: string = call str.lpad(string(mins), 2, "0");
    var secsStr: string = call str.lpad(string(secs), 2, "0");
    return minsStr + ":" + secsStr + "." + tenths;
}

// Calculate and format elapsed game time
formatElapsedTime() return string {
    // Calculate elapsed time: initial time minus remaining time for both players
    var elapsedWhite: int = initialTimerValue - timerWhite;
    var elapsedBlack: int = initialTimerValue - timerBlack;
    var totalElapsedDeciseconds: int = elapsedWhite + elapsedBlack;
    
    // Convert to seconds and minutes
    var totalSeconds: int = totalElapsedDeciseconds / 10;
    var minutes: int = totalSeconds / 60;
    var seconds: int = call modulo(totalSeconds, 60);
    
    var result: string;
    if minutes > 0 then {
        result = string(minutes) + " min " + string(seconds) + " sec";
    } else {
        result = string(seconds) + " sec";
    }
    
    return result;
}

// Timer callback function - called every 100ms (0.1 seconds)
// Note: This callback is already executed on JavaFX Platform.runLater by thread.timerStart
timerCallback(timerName: string) {
    // Only update if game has started - exit early if not
    if gameStarted then {
        // Safety check for null values
        if initialTimerValue != null then {
            // Only process timer updates if not unlimited time
            if initialTimerValue < UNLIMITED_TIME * 10 then {
                // Decrement the active player's timer by 1 decisecond (0.1 seconds)
                if currentPlayer == 0 then {
                    // White's turn
                    if timerWhite > 0 then {
                        timerWhite = timerWhite - 1;
                        var timerText: string = call formatTimerDecimal(timerWhite);
                        
                        // Update screen variable which is bound to the label via varRef
                        chessScreen.whiteTimer = timerText;
                    }
                } else {
                    // Black's turn
                    if timerBlack > 0 then {
                        timerBlack = timerBlack - 1;
                        var timerText: string = call formatTimerDecimal(timerBlack);
                        
                        // Update screen variable which is bound to the label via varRef
                        chessScreen.blackTimer = timerText;
                    }
                }
            }
        }
    }
}

// Cleanup function called when chess screen is closed
cleanupChessScreen() {
    call thread.timerStop("chessTimer");
}

initializeBoard() {
    var row: int = 0;
    var col: int = 0;
    var idx: int = 0;
    
    // Initialize all cells with proper colors
    for (row = 0; row < 8; row++) {
        for (col = 0; col < 8; col++) {
            var cellColor: int = call modulo(row + col, 2);
            idx = call boardIndex(row, col);
            board[idx] = call encodeCellValue(cellColor, EMPTY, WHITE);
        }
    }
    
    // Place black pieces (row 0 and 1)
    board[call boardIndex(0, 0)] = call encodeCellValue(0, ROOK, BLACK);
    board[call boardIndex(0, 1)] = call encodeCellValue(1, KNIGHT, BLACK);
    board[call boardIndex(0, 2)] = call encodeCellValue(0, BISHOP, BLACK);
    board[call boardIndex(0, 3)] = call encodeCellValue(1, QUEEN, BLACK);
    board[call boardIndex(0, 4)] = call encodeCellValue(0, KING, BLACK);
    board[call boardIndex(0, 5)] = call encodeCellValue(1, BISHOP, BLACK);
    board[call boardIndex(0, 6)] = call encodeCellValue(0, KNIGHT, BLACK);
    board[call boardIndex(0, 7)] = call encodeCellValue(1, ROOK, BLACK);
    
    // Row 1: Black pawns
    for (col = 0; col < 8; col++) {
        var cellColor: int = call modulo(1 + col, 2);
        idx = call boardIndex(1, col);
        board[idx] = call encodeCellValue(cellColor, PAWN, BLACK);
    }
    
    // Row 6: White pawns
    for (col = 0; col < 8; col++) {
        var cellColor: int = call modulo(6 + col, 2);
        idx = call boardIndex(6, col);
        board[idx] = call encodeCellValue(cellColor, PAWN, WHITE);
    }
    
    // Place white pieces (row 7)
    board[call boardIndex(7, 0)] = call encodeCellValue(1, ROOK, WHITE);
    board[call boardIndex(7, 1)] = call encodeCellValue(0, KNIGHT, WHITE);
    board[call boardIndex(7, 2)] = call encodeCellValue(1, BISHOP, WHITE);
    board[call boardIndex(7, 3)] = call encodeCellValue(0, QUEEN, WHITE);
    board[call boardIndex(7, 4)] = call encodeCellValue(1, KING, WHITE);
    board[call boardIndex(7, 5)] = call encodeCellValue(0, BISHOP, WHITE);
    board[call boardIndex(7, 6)] = call encodeCellValue(1, KNIGHT, WHITE);
    board[call boardIndex(7, 7)] = call encodeCellValue(0, ROOK, WHITE);
    
    // Initialize pieces array with starting positions
    // Piece codes: K=King, Q=Queen, R=Rook, B=Bishop, N=Knight, P=Pawn
    // Color codes: W=White, B=Black
    
    // Black back row (row 0)
    pieces[0] = ChessPiece { piece: "R", color: "B", pos: posType { x: 0, y: 0 } };
    pieces[1] = ChessPiece { piece: "N", color: "B", pos: posType { x: 1, y: 0 } };
    pieces[2] = ChessPiece { piece: "B", color: "B", pos: posType { x: 2, y: 0 } };
    pieces[3] = ChessPiece { piece: "Q", color: "B", pos: posType { x: 3, y: 0 } };
    pieces[4] = ChessPiece { piece: "K", color: "B", pos: posType { x: 4, y: 0 } };
    pieces[5] = ChessPiece { piece: "B", color: "B", pos: posType { x: 5, y: 0 } };
    pieces[6] = ChessPiece { piece: "N", color: "B", pos: posType { x: 6, y: 0 } };
    pieces[7] = ChessPiece { piece: "R", color: "B", pos: posType { x: 7, y: 0 } };
    
    // Black pawns (row 1)
    pieces[8] = ChessPiece { piece: "P", color: "B", pos: posType { x: 0, y: 1 } };
    pieces[9] = ChessPiece { piece: "P", color: "B", pos: posType { x: 1, y: 1 } };
    pieces[10] = ChessPiece { piece: "P", color: "B", pos: posType { x: 2, y: 1 } };
    pieces[11] = ChessPiece { piece: "P", color: "B", pos: posType { x: 3, y: 1 } };
    pieces[12] = ChessPiece { piece: "P", color: "B", pos: posType { x: 4, y: 1 } };
    pieces[13] = ChessPiece { piece: "P", color: "B", pos: posType { x: 5, y: 1 } };
    pieces[14] = ChessPiece { piece: "P", color: "B", pos: posType { x: 6, y: 1 } };
    pieces[15] = ChessPiece { piece: "P", color: "B", pos: posType { x: 7, y: 1 } };
    
    // White pawns (row 6)
    pieces[16] = ChessPiece { piece: "P", color: "W", pos: posType { x: 0, y: 6 } };
    pieces[17] = ChessPiece { piece: "P", color: "W", pos: posType { x: 1, y: 6 } };
    pieces[18] = ChessPiece { piece: "P", color: "W", pos: posType { x: 2, y: 6 } };
    pieces[19] = ChessPiece { piece: "P", color: "W", pos: posType { x: 3, y: 6 } };
    pieces[20] = ChessPiece { piece: "P", color: "W", pos: posType { x: 4, y: 6 } };
    pieces[21] = ChessPiece { piece: "P", color: "W", pos: posType { x: 5, y: 6 } };
    pieces[22] = ChessPiece { piece: "P", color: "W", pos: posType { x: 6, y: 6 } };
    pieces[23] = ChessPiece { piece: "P", color: "W", pos: posType { x: 7, y: 6 } };
    
    // White back row (row 7)
    pieces[24] = ChessPiece { piece: "R", color: "W", pos: posType { x: 0, y: 7 } };
    pieces[25] = ChessPiece { piece: "N", color: "W", pos: posType { x: 1, y: 7 } };
    pieces[26] = ChessPiece { piece: "B", color: "W", pos: posType { x: 2, y: 7 } };
    pieces[27] = ChessPiece { piece: "Q", color: "W", pos: posType { x: 3, y: 7 } };
    pieces[28] = ChessPiece { piece: "K", color: "W", pos: posType { x: 4, y: 7 } };
    pieces[29] = ChessPiece { piece: "B", color: "W", pos: posType { x: 5, y: 7 } };
    pieces[30] = ChessPiece { piece: "N", color: "W", pos: posType { x: 6, y: 7 } };
    pieces[31] = ChessPiece { piece: "R", color: "W", pos: posType { x: 7, y: 7 } };
}

getBoardRow(rowNum: int) return string {
    var result: string = "";
    var col: int = 0;
    var idx: int = 0;
    
    for (col = 0; col < 8; col++) {
        idx = call boardIndex(rowNum, col);
        var cellValue: int = board[idx];
        var cell = ChessCell(cellValue);
        var cellColor: int = cell.cellColor;
        var piece: string = call getPieceSymbol(cellValue);
        
        if piece == "" then {
            if cellColor == 0 then {
                result = result + " . ";
            } else {
                result = result + " # ";
            }
        } else {
            result = result + " " + piece + " ";
        }
        
        if col < 7 then {
            result = result + "|";
        }
    }
    
    return result;
}

printBoard() {
    print "";
    print "   Chess Board";
    print "   ===========";
    print "";
    
    var whiteTimerStr: string = call formatTimerDecimal(timerWhite);
    var blackTimerStr: string = call formatTimerDecimal(timerBlack);
    var currentPlayerStr: string;
    if currentPlayer == 0 then {
        currentPlayerStr = "White";
    } else {
        currentPlayerStr = "Black";
    }
    
    print "   Current Turn: " + currentPlayerStr;
    print "";
    
    print "     a   b   c   d   e   f   g   h";
    print "   +---+---+---+---+---+---+---+---+";
    
    var row: int = 0;
    for (row = 0; row < 8; row++) {
        var rowLabel: int = 8 - row;
        var rowStr: string = call getBoardRow(row);
        print " " + rowLabel + " |" + rowStr + "| " + rowLabel;
        print "   +---+---+---+---+---+---+---+---+";
    }
    
    print "     a   b   c   d   e   f   g   h";
    print "";
}

// Variable to store game start status
var gameStarted: bool = false;

// Variable to store selected game mode
var selectedGameMode: string = "2 player";

// Variable to store selected time limit
var selectedTimeLimit: string = "Unlimited";

// Variable to store selected difficulty level
var selectedDifficulty: string = "Easy";

// Variable to store human player's color in 1-player mode (0=WHITE, 1=BLACK)
var humanPlayerColor: int = 0;

// Constant for unlimited time (in seconds)
var UNLIMITED_TIME: int = 99999;

// Update timer colors based on current player
updateTimerColors() {
    if currentPlayer == 0 then {
        // White's turn - white is active, black is inactive
        call scr.setproperty("chessScreen.whiteLabelTimer", "textColor", COLOR_LABEL_ACTIVE);
        call scr.setproperty("chessScreen.whiteTimerField", "textColor", COLOR_TIMER_ACTIVE);
        call scr.setproperty("chessScreen.blackLabelTimer", "textColor", COLOR_LABEL_INACTIVE);
        call scr.setproperty("chessScreen.blackTimerField", "textColor", COLOR_TIMER_INACTIVE);
    } else {
        // Black's turn - black is active, white is inactive
        call scr.setproperty("chessScreen.whiteLabelTimer", "textColor", COLOR_LABEL_INACTIVE);
        call scr.setproperty("chessScreen.whiteTimerField", "textColor", COLOR_TIMER_INACTIVE);
        call scr.setproperty("chessScreen.blackLabelTimer", "textColor", COLOR_LABEL_ACTIVE);
        call scr.setproperty("chessScreen.blackTimerField", "textColor", COLOR_TIMER_ACTIVE);
    }
}

// Convert time limit string to seconds
getTimeLimitInDeciseconds(timeLimit: string) return int {
    // Return time in deciseconds (10ths of a second)
    if timeLimit == "10 minutes" then {
        return 6000;  // 600 seconds * 10
    } else if timeLimit == "15 minutes" then {
        return 9000;  // 900 seconds * 10
    } else if timeLimit == "20 minutes" then {
        return 12000;  // 1200 seconds * 10
    } else if timeLimit == "30 minutes" then {
        return 18000;  // 1800 seconds * 10
    } else if timeLimit == "60 minutes" then {
        return 36000;  // 3600 seconds * 10
    } else if timeLimit == "Unlimited" then {
        return UNLIMITED_TIME * 10;
    } else {
        return 6000;  // Default to 10 minutes
    }
}

// Handle game mode change - enable/disable difficulty selection
handleGameModeChange() {
    // Enable difficulty selection only for 1 Player mode
    if startupDialog.gameMode == "1" then {
        call scr.setproperty("startupDialog.difficultyRadio", "disabled", false);
    } else {
        call scr.setproperty("startupDialog.difficultyRadio", "disabled", true);
    }
}

// Handle Start button click from startup dialog
handleStartGame() {
    print "Start button clicked!";
    
    // Reset all game state variables to ensure clean start
    // White always starts in chess
    currentPlayer = WHITE;
    gameOver = false;
    selectedX = -1;
    selectedY = -1;
    lastMoveFromX = -1;
    lastMoveFromY = -1;
    lastMoveToX = -1;
    lastMoveToY = -1;
    arrowPathCount = 0;
    whiteKingMoved = false;
    blackKingMoved = false;
    whiteKingsideRookMoved = false;
    whiteQueensideRookMoved = false;
    blackKingsideRookMoved = false;
    blackQueensideRookMoved = false;
    enPassantTargetX = -1;
    enPassantTargetY = -1;
    lastOpponentX = -1;
    lastOpponentY = -1;
    capturedWhiteCount = 0;
    capturedBlackCount = 0;
    
    // Determine game mode from radio button
    // The gameMode variable stores "1" or "2"
    if startupDialog.gameMode == "1" then {
        selectedGameMode = "1 player";
        
        // Randomly assign white or black to human player
        // Generate random number: 0 or 1
        humanPlayerColor = call random.nextLong(0, 2);
        
        if humanPlayerColor == WHITE then {
            print "You are playing as WHITE. White starts first.";
        } else {
            print "You are playing as BLACK. White (computer) starts first.";
        }
    } else {
        selectedGameMode = "2 player";
    }
    
    selectedTimeLimit = startupDialog.timeLimit;
    
    // Store selected difficulty level
    // The difficulty variable stores "1", "2", "3", or "4"
    if startupDialog.difficulty == "1" then {
        selectedDifficulty = "Easy";
    } else if startupDialog.difficulty == "2" then {
        selectedDifficulty = "Medium";
    } else if startupDialog.difficulty == "3" then {
        selectedDifficulty = "Hard";
    } else {
        selectedDifficulty = "Expert";
    }
    
    print "Selected game mode: " + selectedGameMode;
    print "Selected time limit: " + selectedTimeLimit;
    if selectedGameMode == "1 player" then {
        print "Selected difficulty: " + selectedDifficulty;
    }
    
    // Set the timer values based on selection (in deciseconds)
    var timeInDeciseconds: int = call getTimeLimitInDeciseconds(selectedTimeLimit);
    timerWhite = timeInDeciseconds;
    timerBlack = timeInDeciseconds;
    initialTimerValue = timeInDeciseconds;  // Store for elapsed time calculation
    
    gameStarted = true;
    
    // Close the startup dialog
    close screen startupDialog;
    
    call initializeBoard();
    call printBoard();
    
    // Create board layer and indicator images
    call createBoardLayer();
    
    call createIndicators();
    
    call initializeBoardPieces();
    print "";
    print "Initializing board layer (checkerboard pattern)...";
    
    // Initialize all 64 board squares with the correct checkerboard pattern using loops
    // Checkerboard pattern: light on (row+col)%2==0, dark on (row+col)%2==1
    for (var y: int = 0; y < 8; y++) {
        for (var x: int = 0; x < 8; x++) {
            var sum: int = x + y;
            var remainder: int = call modulo(sum, 2);
            if remainder == 0 then {
                call setBoardSquare(x, y, lightSquare);
            } else {
                call setBoardSquare(x, y, darkSquare);
            }
        }
    }
    
    // Clear all indicators before showing screen to ensure clean state
    call clearIndicators();
    
    // Explicitly initialize all 64 indicator variables BEFORE showing screen
    // This ensures ImageViews are created with valid initial values (transparent)
    chessScreen.i00 = transparentClear; chessScreen.i01 = transparentClear; chessScreen.i02 = transparentClear; chessScreen.i03 = transparentClear;
    chessScreen.i04 = transparentClear; chessScreen.i05 = transparentClear; chessScreen.i06 = transparentClear; chessScreen.i07 = transparentClear;
    chessScreen.i10 = transparentClear; chessScreen.i11 = transparentClear; chessScreen.i12 = transparentClear; chessScreen.i13 = transparentClear;
    chessScreen.i14 = transparentClear; chessScreen.i15 = transparentClear; chessScreen.i16 = transparentClear; chessScreen.i17 = transparentClear;
    chessScreen.i20 = transparentClear; chessScreen.i21 = transparentClear; chessScreen.i22 = transparentClear; chessScreen.i23 = transparentClear;
    chessScreen.i24 = transparentClear; chessScreen.i25 = transparentClear; chessScreen.i26 = transparentClear; chessScreen.i27 = transparentClear;
    chessScreen.i30 = transparentClear; chessScreen.i31 = transparentClear; chessScreen.i32 = transparentClear; chessScreen.i33 = transparentClear;
    chessScreen.i34 = transparentClear; chessScreen.i35 = transparentClear; chessScreen.i36 = transparentClear; chessScreen.i37 = transparentClear;
    chessScreen.i40 = transparentClear; chessScreen.i41 = transparentClear; chessScreen.i42 = transparentClear; chessScreen.i43 = transparentClear;
    chessScreen.i44 = transparentClear; chessScreen.i45 = transparentClear; chessScreen.i46 = transparentClear; chessScreen.i47 = transparentClear;
    chessScreen.i50 = transparentClear; chessScreen.i51 = transparentClear; chessScreen.i52 = transparentClear; chessScreen.i53 = transparentClear;
    chessScreen.i54 = transparentClear; chessScreen.i55 = transparentClear; chessScreen.i56 = transparentClear; chessScreen.i57 = transparentClear;
    chessScreen.i60 = transparentClear; chessScreen.i61 = transparentClear; chessScreen.i62 = transparentClear; chessScreen.i63 = transparentClear;
    chessScreen.i64 = transparentClear; chessScreen.i65 = transparentClear; chessScreen.i66 = transparentClear; chessScreen.i67 = transparentClear;
    chessScreen.i70 = transparentClear; chessScreen.i71 = transparentClear; chessScreen.i72 = transparentClear; chessScreen.i73 = transparentClear;
    chessScreen.i74 = transparentClear; chessScreen.i75 = transparentClear; chessScreen.i76 = transparentClear; chessScreen.i77 = transparentClear;
    
    // Update screen variables before showing
    chessScreen.whiteTimer = call formatTimerDecimal(timerWhite);
    chessScreen.blackTimer = call formatTimerDecimal(timerBlack);
    chessScreen.statusMessage = "White to move";
    chessScreen.moveHistory = "Game started.\nWhite's turn.\n";
    call updateTimerColors();
    
    // Initialize captured pieces display variables BEFORE showing screen
    // This ensures ImageViews are created with valid initial values
    chessScreen.capturedWhite0 = transparentClear;
    chessScreen.capturedWhite1 = transparentClear;
    chessScreen.capturedWhite2 = transparentClear;
    chessScreen.capturedWhite3 = transparentClear;
    chessScreen.capturedWhite4 = transparentClear;
    chessScreen.capturedWhite5 = transparentClear;
    chessScreen.capturedWhite6 = transparentClear;
    chessScreen.capturedWhite7 = transparentClear;
    chessScreen.capturedWhite8 = transparentClear;
    chessScreen.capturedWhite9 = transparentClear;
    chessScreen.capturedWhite10 = transparentClear;
    chessScreen.capturedWhite11 = transparentClear;
    chessScreen.capturedWhite12 = transparentClear;
    chessScreen.capturedWhite13 = transparentClear;
    chessScreen.capturedWhite14 = transparentClear;
    chessScreen.capturedWhite15 = transparentClear;
    chessScreen.capturedBlack0 = transparentClear;
    chessScreen.capturedBlack1 = transparentClear;
    chessScreen.capturedBlack2 = transparentClear;
    chessScreen.capturedBlack3 = transparentClear;
    chessScreen.capturedBlack4 = transparentClear;
    chessScreen.capturedBlack5 = transparentClear;
    chessScreen.capturedBlack6 = transparentClear;
    chessScreen.capturedBlack7 = transparentClear;
    chessScreen.capturedBlack8 = transparentClear;
    chessScreen.capturedBlack9 = transparentClear;
    chessScreen.capturedBlack10 = transparentClear;
    chessScreen.capturedBlack11 = transparentClear;
    chessScreen.capturedBlack12 = transparentClear;
    chessScreen.capturedBlack13 = transparentClear;
    chessScreen.capturedBlack14 = transparentClear;
    chessScreen.capturedBlack15 = transparentClear;
    
    // Show the chess screen
    show screen chessScreen;
    
    // Clear undo/redo history for new game
    call clearUndoRedoHistory();
    
    // Show/hide undo/redo buttons based on game mode
    if selectedGameMode == "2 player" then {
        call scr.setproperty("chessScreen.undoBtn", "visible", true);
        call scr.setproperty("chessScreen.redoBtn", "visible", true);
    } else {
        call scr.setproperty("chessScreen.undoBtn", "visible", false);
        call scr.setproperty("chessScreen.redoBtn", "visible", false);
    }
    
    // Timer display is automatically updated via varRef binding to whiteTimer and blackTimer variables
    
    // Start the game timer (updates every 100ms = 0.1 seconds)
    // Use qualified name to link timer to screen
    call thread.timerStart("chessScreen.chessTimer", 100, "timerCallback");
    
    print "";
    
    // In 1-player mode, if computer plays white (currentPlayer=WHITE and humanPlayerColor=BLACK), 
    // trigger computer move immediately after screen renders
    if selectedGameMode == "1 player" && humanPlayerColor == BLACK then {
        call util.runlater("makeComputerMove");
    }
}

// Handle Exit button click from startup dialog
handleExitGame() {
    print "=== handleExitGame() EXECUTED ===";
    print "Exit button clicked!";
    gameStarted = false;
    
    // Stop the timer if it's running
    call thread.timerStop("chessScreen.chessTimer");
    
    // Close the startup dialog
    close screen startupDialog;
    print "Startup dialog closed.";
    print "=== handleExitGame() COMPLETE ===";
    print "";
    
    print "Game cancelled.";
}

// ====================
// Move Visualization
// ====================

// Show the last move with blue arrow indicators spanning across cells
showLastMove(fromX: int, fromY: int, toX: int, toY: int) {
    // Clear previous arrow path indicators
    var i: int = 0;
    while i < arrowPathCount {
        call clearIndicator(arrowPathX[i], arrowPathY[i]);
        i = i + 1;
    }
    arrowPathCount = 0;
    
    // Store the new move positions
    lastMoveFromX = fromX;
    lastMoveFromY = fromY;
    lastMoveToX = toX;
    lastMoveToY = toY;
    
    // Calculate movement direction
    var dx: int = toX - fromX;
    var dy: int = toY - fromY;
    
    // Determine direction type and select appropriate arrow
    var dirX: int = 0;  // -1=left, 0=none, 1=right
    var dirY: int = 0;  // -1=up, 0=none, 1=down
    
    if dx > 0 then { dirX = 1; }
    if dx < 0 then { dirX = -1; }
    if dy > 0 then { dirY = 1; }
    if dy < 0 then { dirY = -1; }
    
    // Show blue circle on the starting position
    if arrowPathCount < 64 then {
        call setCustomIndicator(fromX, fromY, blueCircleIndicator);
        arrowPathX[arrowPathCount] = fromX;
        arrowPathY[arrowPathCount] = fromY;
        arrowPathCount = arrowPathCount + 1;
    }
    
    // Calculate absolute distances
    var absDx: int = dx;
    var absDy: int = dy;
    if absDx < 0 then { absDx = 0 - absDx; }
    if absDy < 0 then { absDy = 0 - absDy; }
    
    // Determine if this is a knight move (L-shaped: different distances in x and y)
    var isKnightMove: bool = absDx != absDy && absDx != 0 && absDy != 0;
    
    // Handle knight moves with L-shaped arrow path
    if isKnightMove then {
        // Knight moves in an L-shape: 2 squares in one direction, 1 in perpendicular
        // Draw: circle -> 1 arrow -> corner arrow -> circle
        
        // Determine which direction has 2 squares and which has 1
        if absDx == 2 then {
            // Move 2 squares horizontally: draw 1 horizontal arrow, then corner arrow
            if arrowPathCount < 63 then {
                // First arrow: horizontal (after 1 square)
                var mid1X: int = fromX + dirX;
                var arrow1: imagedata;
                if dirX == 1 then {
                    arrow1 = blueArrowRight;
                } else {
                    arrow1 = blueArrowLeft;
                }
                call setCustomIndicator(mid1X, fromY, arrow1);
                arrowPathX[arrowPathCount] = mid1X;
                arrowPathY[arrowPathCount] = fromY;
                arrowPathCount = arrowPathCount + 1;
            }
            
            if arrowPathCount < 63 then {
                // Corner arrow: L-shaped with 90-degree angle at the turn point
                var cornerX: int = fromX + (dirX * 2);
                var cornerY: int = fromY;
                var cornerArrow: imagedata;
                
                // Select L-shaped arrow: horizontal first, then vertical
                if dirX == 1 && dirY == -1 then {
                    cornerArrow = blueLShapeRightUp;  // Right then up
                } else if dirX == 1 && dirY == 1 then {
                    cornerArrow = blueLShapeRightDown;  // Right then down
                } else if dirX == -1 && dirY == -1 then {
                    cornerArrow = blueLShapeLeftUp;  // Left then up
                } else if dirX == -1 && dirY == 1 then {
                    cornerArrow = blueLShapeLeftDown;  // Left then down
                } else {
                    cornerArrow = blueCircleIndicator;
                }
                
                call setCustomIndicator(cornerX, cornerY, cornerArrow);
                arrowPathX[arrowPathCount] = cornerX;
                arrowPathY[arrowPathCount] = cornerY;
                arrowPathCount = arrowPathCount + 1;
            }
        } else if absDy == 2 then {
            // Move 2 squares vertically: draw 1 vertical arrow, then corner arrow
            if arrowPathCount < 63 then {
                // First arrow: vertical (after 1 square)
                var mid1Y: int = fromY + dirY;
                var arrow1: imagedata;
                if dirY == 1 then {
                    arrow1 = blueArrowDown;
                } else {
                    arrow1 = blueArrowUp;
                }
                call setCustomIndicator(fromX, mid1Y, arrow1);
                arrowPathX[arrowPathCount] = fromX;
                arrowPathY[arrowPathCount] = mid1Y;
                arrowPathCount = arrowPathCount + 1;
            }
            
            if arrowPathCount < 63 then {
                // Corner arrow: L-shaped with 90-degree angle at the turn point
                var cornerX: int = fromX;
                var cornerY: int = fromY + (dirY * 2);
                var cornerArrow: imagedata;
                
                // Select L-shaped arrow: vertical first, then horizontal
                if dirX == 1 && dirY == -1 then {
                    cornerArrow = blueLShapeUpRight;  // Up then right
                } else if dirX == 1 && dirY == 1 then {
                    cornerArrow = blueLShapeDownRight;  // Down then right
                } else if dirX == -1 && dirY == -1 then {
                    cornerArrow = blueLShapeUpLeft;  // Up then left
                } else if dirX == -1 && dirY == 1 then {
                    cornerArrow = blueLShapeDownLeft;  // Down then left
                } else {
                    cornerArrow = blueCircleIndicator;
                }
                
                call setCustomIndicator(cornerX, cornerY, cornerArrow);
                arrowPathX[arrowPathCount] = cornerX;
                arrowPathY[arrowPathCount] = cornerY;
                arrowPathCount = arrowPathCount + 1;
            }
        }
    } else {
        // Draw arrow segments from source to destination
        var currentX: int = fromX;
        var currentY: int = fromY;
        var stepX: int = dirX;
        var stepY: int = dirY;
        
        // Calculate maximum steps to prevent infinite loops (safety check)
        var maxSteps: int = absDx;
        if absDy > maxSteps then { maxSteps = absDy; }
        
        // Move one step at a time
        currentX = currentX + stepX;
        currentY = currentY + stepY;
        
        // Draw arrow segments on intermediate cells (not the destination)
        var stepCount: int = 0;
        while ((currentX != toX || currentY != toY) && stepCount < maxSteps) {
            // Safety check: ensure we don't exceed array bounds
            if arrowPathCount >= 63 then {
                break;  // Stop if we're about to overflow
            }
            
            var arrow: imagedata;
            
            // Select the appropriate arrow based on direction
            if dirX == 1 && dirY == 0 then {
                arrow = blueArrowRight;
            } else if dirX == -1 && dirY == 0 then {
                arrow = blueArrowLeft;
            } else if dirX == 0 && dirY == 1 then {
                arrow = blueArrowDown;
            } else if dirX == 0 && dirY == -1 then {
                arrow = blueArrowUp;
            } else if dirX == 1 && dirY == -1 then {
                arrow = blueArrowUpRight;
            } else if dirX == -1 && dirY == -1 then {
                arrow = blueArrowUpLeft;
            } else if dirX == 1 && dirY == 1 then {
                arrow = blueArrowDownRight;
            } else if dirX == -1 && dirY == 1 then {
                arrow = blueArrowDownLeft;
            } else {
                arrow = blueCircleIndicator;  // Fallback for unexpected cases
            }
            
            call setCustomIndicator(currentX, currentY, arrow);
            arrowPathX[arrowPathCount] = currentX;
            arrowPathY[arrowPathCount] = currentY;
            arrowPathCount = arrowPathCount + 1;
            
            currentX = currentX + stepX;
            currentY = currentY + stepY;
            stepCount = stepCount + 1;
        }
    }
    
    // Show blue circle on the destination position
    if arrowPathCount < 64 then {
        call setCustomIndicator(toX, toY, blueCircleIndicator);
        arrowPathX[arrowPathCount] = toX;
        arrowPathY[arrowPathCount] = toY;
        arrowPathCount = arrowPathCount + 1;
    }
}

// ====================
// Computer Player AI
// ====================

// Get the value of a piece type for evaluation
getPieceValue(pieceType: int) return int {
    if pieceType == PAWN then {
        return 1;
    } else if pieceType == KNIGHT then {
        return 3;
    } else if pieceType == BISHOP then {
        return 3;
    } else if pieceType == ROOK then {
        return 5;
    } else if pieceType == QUEEN then {
        return 9;
    } else if pieceType == KING then {
        return 1000;  // King is invaluable
    }
    return 0;
}

// Find all legal moves for the computer player (filters out moves that expose king)
findAllLegalMoves(playerColor: int) return array {
    var allMoves = [];
    
    // Iterate through all board positions
    var y: int = 0;
    for (y = 0; y < 8; y = y + 1) {
        var x: int = 0;
        for (x = 0; x < 8; x = x + 1) {
            var cellValue: int = call getPieceAt(x, y);
            if cellValue != -1 then {
                var cell = ChessCell(cellValue);
                // Check if this piece belongs to the player
                if cell.pieceType != EMPTY && cell.pieceColor == playerColor then {
                    // Get all valid moves for this piece
                    var pieceMoves = call validMoves(x, y);
                    var moveCount: int = pieceMoves.length;
                    var i: int = 0;
                    
                    // Filter out moves that would expose king
                    for (i = 0; i < moveCount; i = i + 1) {
                        var move = pieceMoves[i];
                        var exposesKing: bool = call wouldMoveExposeKing(x, y, move.x, move.y, playerColor);
                        
                        if !exposesKing then {
                            // Create a move record with source and destination
                            var jsonStr: string = '{"fromX": ' + x + ', "fromY": ' + y + 
                                                   ', "toX": ' + move.x + ', "toY": ' + move.y + 
                                                   ', "pieceType": ' + cell.pieceType + '}';
                            var legalMove: json = call json.jsonfromstring(jsonStr);
                            call array.add(allMoves, legalMove);
                        }
                    }
                }
            }
        }
    }
    
    return allMoves;
}

// Evaluate and select the best move for Easy difficulty
// Returns a move object with fromX, fromY, toX, toY, or null if no moves available
selectBestMoveEasy(playerColor: int) return json {
    var allMoves = call findAllLegalMoves(playerColor);
    var moveCount: int = allMoves.length;
    
    if moveCount == 0 then {
        return null;  // No legal moves (shouldn't happen in normal play)
    }
    
    // Find moves that capture pieces and evaluate them considering defenders
    var bestCaptureMove: json = null;
    var bestCaptureValue: int = 0;
    var safeCaptureMovesFound: bool = false;
    
    var i: int = 0;
    for (i = 0; i < moveCount; i = i + 1) {
        var move = allMoves[i];
        var destCellValue: int = call getPieceAt(move.toX, move.toY);
        
        if destCellValue != -1 then {
            var destCell = ChessCell(destCellValue);
            if destCell.pieceType != EMPTY then {
                // This is a capture move - get the value of the piece being captured
                var captureValue: int = call getPieceValue(destCell.pieceType);
                
                // Get the value of the attacking piece
                var attackerPieceType: int = move.pieceType;
                var attackerValue: int = call getPieceValue(attackerPieceType);
                
                // Check if opponent pieces can attack the destination square (potential recapture)
                // Get the opponent's color
                var opponentColor: int = WHITE;
                if playerColor == WHITE then {
                    opponentColor = BLACK;
                }
                
                // Find all opponent pieces that could recapture at the destination
                var recapturers = call getAttackers(move.toX, move.toY, opponentColor);
                var recapturerCount: int = recapturers.length;
                
                // Decide if this capture is safe
                var isSafeCapture: bool = false;
                
                if recapturerCount == 0 then {
                    // No one can recapture - safe to capture
                    isSafeCapture = true;
                } else {
                    // Opponent can recapture - calculate net material gain/loss
                    // We gain: captureValue
                    // We lose: attackerValue (if opponent recaptures)
                    // Net gain = captureValue - attackerValue (if positive, we gain material)
                    var netGain: int = captureValue - attackerValue;
                    
                    // Only capture if we gain material or break even
                    if netGain >= 0 then {
                        isSafeCapture = true;
                    }
                }
                
                // If this is a safe capture, consider it
                if isSafeCapture then {
                    safeCaptureMovesFound = true;
                    if captureValue > bestCaptureValue then {
                        bestCaptureValue = captureValue;
                        bestCaptureMove = move;
                    }
                }
            }
        }
    }
    
    // If we found a safe capture move, return the best one
    if safeCaptureMovesFound then {
        return bestCaptureMove;
    }
    
    // No safe captures available - select a random move
    // Defensive check (should already be handled by moveCount check above)
    if moveCount == 0 then {
        return null;
    }
    var randomIndex: int = call random.nextLong(0, moveCount);
    return allMoves[randomIndex];
}

// Execute a computer move
makeComputerMove() {
    // Track start time for ensuring minimum 1 second delay
    var startTime = call date.now();
    var startMs: long = call date.toEpochMs(startTime);
    
    // Select the best move based on difficulty
    // TODO: Implement Medium, Hard, and Expert difficulty levels
    // For now, all difficulties use Easy logic
    var selectedMove: json = call selectBestMoveEasy(currentPlayer);
    
    if selectedMove == null then {
        return;
    }
    
    // Extract move coordinates
    var fromX: int = selectedMove.fromX;
    var fromY: int = selectedMove.fromY;
    var toX: int = selectedMove.toX;
    var toY: int = selectedMove.toY;
    
    // Get information about the move before executing it
    var sourceCellValue: int = call getPieceAt(fromX, fromY);
    var destCellValue: int = call getPieceAt(toX, toY);
    var isCapture: bool = false;
    var capturedPieceType: int = EMPTY;
    var capturedPieceColor: int = WHITE;
    
    // Check if this is a capture move
    if destCellValue != -1 then {
        var destCell = ChessCell(destCellValue);
        if destCell.pieceType != EMPTY then {
            isCapture = true;
            capturedPieceType = destCell.pieceType;
            capturedPieceColor = destCell.pieceColor;
            // Track the captured piece for display
            call addCapturedPiece(capturedPieceType, capturedPieceColor);
        }
    }
    
    var sourceCell = ChessCell(sourceCellValue);
    var movingPieceType: int = sourceCell.pieceType;
    var movingPieceColor: int = sourceCell.pieceColor;
    
    // Calculate elapsed time and add delay if needed (minimum 1 second)
    // Wait until 1 second has passed before showing the computer's move
    var endTime = call date.now();
    var endMs: long = call date.toEpochMs(endTime);
    var elapsedMs: long = endMs - startMs;
    
    if elapsedMs < 1000 then {
        var delayMs: long = 1000 - elapsedMs;
        call thread.sleep(delayMs);
    }
    
    // Clear the human player's move arrows before showing computer's move
    if lastMoveFromX >= 0 && lastMoveFromY >= 0 then {
        call clearIndicator(lastMoveFromX, lastMoveFromY);
    }
    if lastMoveToX >= 0 && lastMoveToY >= 0 then {
        call clearIndicator(lastMoveToX, lastMoveToY);
    }
    
    // Move the piece
    call movePiece(fromX, fromY, toX, toY);
    
    // Show the last move with blue arrows
    call showLastMove(fromX, fromY, toX, toY);
    
    // Format and add move to history
    var moveNotation: string = call formatMove(fromX, fromY, toX, toY, movingPieceType, movingPieceColor, isCapture, capturedPieceType, capturedPieceColor);
    var playerName: string;
    if currentPlayer == WHITE then {
        playerName = "White";
    } else {
        playerName = "Black";
    }
    var moveEntry: string = playerName + " (Computer): " + moveNotation + "\n";
    chessScreen.moveHistory = chessScreen.moveHistory + moveEntry;
    
    // Switch to next player
    if currentPlayer == WHITE then {
        currentPlayer = BLACK;
    } else {
        currentPlayer = WHITE;
    }
    
    // Check for checkmate or stalemate
    var isInCheckmate: bool = call isCheckmate(currentPlayer);
    var isInStalemate: bool = call isStalemate(currentPlayer);
    
    if isInCheckmate then {
        gameOver = true;
        
        // Stop the game timer
        call thread.timerStop("chessScreen.chessTimer");
        
        // Mark the losing king with a larger red cross
        var kingPos: posType = call findKing(currentPlayer);
        if kingPos.x >= 0 then {
            call setIndicator(kingPos.x, kingPos.y, "checkmate");
        }
        
        // Update status message
        var winner: string;
        if currentPlayer == WHITE then {
            winner = "Black";
            chessScreen.statusMessage = "Checkmate! Black wins!";
        } else {
            winner = "White";
            chessScreen.statusMessage = "Checkmate! White wins!";
        }
        
        // Show game over dialog
        call showGameOverDialog(winner, "checkmate");
    } else if isInStalemate then {
        gameOver = true;
        
        // Stop the game timer
        call thread.timerStop("chessScreen.chessTimer");
        
        // Mark both kings with red crosses
        var whiteKingPos: posType = call findKing(WHITE);
        var blackKingPos: posType = call findKing(BLACK);
        
        if whiteKingPos.x >= 0 then {
            call setIndicator(whiteKingPos.x, whiteKingPos.y, "invalid");
        }
        if blackKingPos.x >= 0 then {
            call setIndicator(blackKingPos.x, blackKingPos.y, "invalid");
        }
        
        chessScreen.statusMessage = "Stalemate! Game is a draw.";
        
        // Show game over dialog
        call showGameOverDialog("Draw", "stalemate");
    } else {
        // Normal game continues
        if currentPlayer == BLACK then {
            chessScreen.statusMessage = "Black to move";
        } else {
            chessScreen.statusMessage = "White to move";
        }
    }
    
    call updateTimerColors();
}

screen chessScreen = {
    "title": "Chess Game",
    "width": 980,
    "height": 850,
    "vars": [
        {"name": "whiteTimer", "type": "string", "default": "10:00"},
        {"name": "blackTimer", "type": "string", "default": "10:00"},
        {"name": "whiteLabelText", "type": "string", "default": "\u2654 White:"},
        {"name": "blackLabelText", "type": "string", "default": "\u265A Black:"},
        {"name": "statusMessage", "type": "string", "default": "White to move"},
        {"name": "moveHistory", "type": "string", "default": "Game started.\nWhite's turn.\n"},
        {"name": "b00", "type": "imagedata"},
        {"name": "b01", "type": "imagedata"},
        {"name": "b02", "type": "imagedata"},
        {"name": "b03", "type": "imagedata"},
        {"name": "b04", "type": "imagedata"},
        {"name": "b05", "type": "imagedata"},
        {"name": "b06", "type": "imagedata"},
        {"name": "b07", "type": "imagedata"},
        {"name": "b10", "type": "imagedata"},
        {"name": "b11", "type": "imagedata"},
        {"name": "b12", "type": "imagedata"},
        {"name": "b13", "type": "imagedata"},
        {"name": "b14", "type": "imagedata"},
        {"name": "b15", "type": "imagedata"},
        {"name": "b16", "type": "imagedata"},
        {"name": "b17", "type": "imagedata"},
        {"name": "b20", "type": "imagedata"},
        {"name": "b21", "type": "imagedata"},
        {"name": "b22", "type": "imagedata"},
        {"name": "b23", "type": "imagedata"},
        {"name": "b24", "type": "imagedata"},
        {"name": "b25", "type": "imagedata"},
        {"name": "b26", "type": "imagedata"},
        {"name": "b27", "type": "imagedata"},
        {"name": "b30", "type": "imagedata"},
        {"name": "b31", "type": "imagedata"},
        {"name": "b32", "type": "imagedata"},
        {"name": "b33", "type": "imagedata"},
        {"name": "b34", "type": "imagedata"},
        {"name": "b35", "type": "imagedata"},
        {"name": "b36", "type": "imagedata"},
        {"name": "b37", "type": "imagedata"},
        {"name": "b40", "type": "imagedata"},
        {"name": "b41", "type": "imagedata"},
        {"name": "b42", "type": "imagedata"},
        {"name": "b43", "type": "imagedata"},
        {"name": "b44", "type": "imagedata"},
        {"name": "b45", "type": "imagedata"},
        {"name": "b46", "type": "imagedata"},
        {"name": "b47", "type": "imagedata"},
        {"name": "b50", "type": "imagedata"},
        {"name": "b51", "type": "imagedata"},
        {"name": "b52", "type": "imagedata"},
        {"name": "b53", "type": "imagedata"},
        {"name": "b54", "type": "imagedata"},
        {"name": "b55", "type": "imagedata"},
        {"name": "b56", "type": "imagedata"},
        {"name": "b57", "type": "imagedata"},
        {"name": "b60", "type": "imagedata"},
        {"name": "b61", "type": "imagedata"},
        {"name": "b62", "type": "imagedata"},
        {"name": "b63", "type": "imagedata"},
        {"name": "b64", "type": "imagedata"},
        {"name": "b65", "type": "imagedata"},
        {"name": "b66", "type": "imagedata"},
        {"name": "b67", "type": "imagedata"},
        {"name": "b70", "type": "imagedata"},
        {"name": "b71", "type": "imagedata"},
        {"name": "b72", "type": "imagedata"},
        {"name": "b73", "type": "imagedata"},
        {"name": "b74", "type": "imagedata"},
        {"name": "b75", "type": "imagedata"},
        {"name": "b76", "type": "imagedata"},
        {"name": "b77", "type": "imagedata"},
        {"name": "c00", "type": "imagedata"},
        {"name": "c01", "type": "imagedata"},
        {"name": "c02", "type": "imagedata"},
        {"name": "c03", "type": "imagedata"},
        {"name": "c04", "type": "imagedata"},
        {"name": "c05", "type": "imagedata"},
        {"name": "c06", "type": "imagedata"},
        {"name": "c07", "type": "imagedata"},
        {"name": "c10", "type": "imagedata"},
        {"name": "c11", "type": "imagedata"},
        {"name": "c12", "type": "imagedata"},
        {"name": "c13", "type": "imagedata"},
        {"name": "c14", "type": "imagedata"},
        {"name": "c15", "type": "imagedata"},
        {"name": "c16", "type": "imagedata"},
        {"name": "c17", "type": "imagedata"},
        {"name": "c20", "type": "imagedata"},
        {"name": "c21", "type": "imagedata"},
        {"name": "c22", "type": "imagedata"},
        {"name": "c23", "type": "imagedata"},
        {"name": "c24", "type": "imagedata"},
        {"name": "c25", "type": "imagedata"},
        {"name": "c26", "type": "imagedata"},
        {"name": "c27", "type": "imagedata"},
        {"name": "c30", "type": "imagedata"},
        {"name": "c31", "type": "imagedata"},
        {"name": "c32", "type": "imagedata"},
        {"name": "c33", "type": "imagedata"},
        {"name": "c34", "type": "imagedata"},
        {"name": "c35", "type": "imagedata"},
        {"name": "c36", "type": "imagedata"},
        {"name": "c37", "type": "imagedata"},
        {"name": "c40", "type": "imagedata"},
        {"name": "c41", "type": "imagedata"},
        {"name": "c42", "type": "imagedata"},
        {"name": "c43", "type": "imagedata"},
        {"name": "c44", "type": "imagedata"},
        {"name": "c45", "type": "imagedata"},
        {"name": "c46", "type": "imagedata"},
        {"name": "c47", "type": "imagedata"},
        {"name": "c50", "type": "imagedata"},
        {"name": "c51", "type": "imagedata"},
        {"name": "c52", "type": "imagedata"},
        {"name": "c53", "type": "imagedata"},
        {"name": "c54", "type": "imagedata"},
        {"name": "c55", "type": "imagedata"},
        {"name": "c56", "type": "imagedata"},
        {"name": "c57", "type": "imagedata"},
        {"name": "c60", "type": "imagedata"},
        {"name": "c61", "type": "imagedata"},
        {"name": "c62", "type": "imagedata"},
        {"name": "c63", "type": "imagedata"},
        {"name": "c64", "type": "imagedata"},
        {"name": "c65", "type": "imagedata"},
        {"name": "c66", "type": "imagedata"},
        {"name": "c67", "type": "imagedata"},
        {"name": "c70", "type": "imagedata"},
        {"name": "c71", "type": "imagedata"},
        {"name": "c72", "type": "imagedata"},
        {"name": "c73", "type": "imagedata"},
        {"name": "c74", "type": "imagedata"},
        {"name": "c75", "type": "imagedata"},
        {"name": "c76", "type": "imagedata"},
        {"name": "c77", "type": "imagedata"},
        {"name": "i00", "type": "imagedata"},
        {"name": "i01", "type": "imagedata"},
        {"name": "i02", "type": "imagedata"},
        {"name": "i03", "type": "imagedata"},
        {"name": "i04", "type": "imagedata"},
        {"name": "i05", "type": "imagedata"},
        {"name": "i06", "type": "imagedata"},
        {"name": "i07", "type": "imagedata"},
        {"name": "i10", "type": "imagedata"},
        {"name": "i11", "type": "imagedata"},
        {"name": "i12", "type": "imagedata"},
        {"name": "i13", "type": "imagedata"},
        {"name": "i14", "type": "imagedata"},
        {"name": "i15", "type": "imagedata"},
        {"name": "i16", "type": "imagedata"},
        {"name": "i17", "type": "imagedata"},
        {"name": "i20", "type": "imagedata"},
        {"name": "i21", "type": "imagedata"},
        {"name": "i22", "type": "imagedata"},
        {"name": "i23", "type": "imagedata"},
        {"name": "i24", "type": "imagedata"},
        {"name": "i25", "type": "imagedata"},
        {"name": "i26", "type": "imagedata"},
        {"name": "i27", "type": "imagedata"},
        {"name": "i30", "type": "imagedata"},
        {"name": "i31", "type": "imagedata"},
        {"name": "i32", "type": "imagedata"},
        {"name": "i33", "type": "imagedata"},
        {"name": "i34", "type": "imagedata"},
        {"name": "i35", "type": "imagedata"},
        {"name": "i36", "type": "imagedata"},
        {"name": "i37", "type": "imagedata"},
        {"name": "i40", "type": "imagedata"},
        {"name": "i41", "type": "imagedata"},
        {"name": "i42", "type": "imagedata"},
        {"name": "i43", "type": "imagedata"},
        {"name": "i44", "type": "imagedata"},
        {"name": "i45", "type": "imagedata"},
        {"name": "i46", "type": "imagedata"},
        {"name": "i47", "type": "imagedata"},
        {"name": "i50", "type": "imagedata"},
        {"name": "i51", "type": "imagedata"},
        {"name": "i52", "type": "imagedata"},
        {"name": "i53", "type": "imagedata"},
        {"name": "i54", "type": "imagedata"},
        {"name": "i55", "type": "imagedata"},
        {"name": "i56", "type": "imagedata"},
        {"name": "i57", "type": "imagedata"},
        {"name": "i60", "type": "imagedata"},
        {"name": "i61", "type": "imagedata"},
        {"name": "i62", "type": "imagedata"},
        {"name": "i63", "type": "imagedata"},
        {"name": "i64", "type": "imagedata"},
        {"name": "i65", "type": "imagedata"},
        {"name": "i66", "type": "imagedata"},
        {"name": "i67", "type": "imagedata"},
        {"name": "i70", "type": "imagedata"},
        {"name": "i71", "type": "imagedata"},
        {"name": "i72", "type": "imagedata"},
        {"name": "i73", "type": "imagedata"},
        {"name": "i74", "type": "imagedata"},
        {"name": "i75", "type": "imagedata"},
        {"name": "i76", "type": "imagedata"},
        {"name": "i77", "type": "imagedata"},
        {"name": "capturedWhite0", "type": "imagedata"},
        {"name": "capturedWhite1", "type": "imagedata"},
        {"name": "capturedWhite2", "type": "imagedata"},
        {"name": "capturedWhite3", "type": "imagedata"},
        {"name": "capturedWhite4", "type": "imagedata"},
        {"name": "capturedWhite5", "type": "imagedata"},
        {"name": "capturedWhite6", "type": "imagedata"},
        {"name": "capturedWhite7", "type": "imagedata"},
        {"name": "capturedWhite8", "type": "imagedata"},
        {"name": "capturedWhite9", "type": "imagedata"},
        {"name": "capturedWhite10", "type": "imagedata"},
        {"name": "capturedWhite11", "type": "imagedata"},
        {"name": "capturedWhite12", "type": "imagedata"},
        {"name": "capturedWhite13", "type": "imagedata"},
        {"name": "capturedWhite14", "type": "imagedata"},
        {"name": "capturedWhite15", "type": "imagedata"},
        {"name": "capturedBlack0", "type": "imagedata"},
        {"name": "capturedBlack1", "type": "imagedata"},
        {"name": "capturedBlack2", "type": "imagedata"},
        {"name": "capturedBlack3", "type": "imagedata"},
        {"name": "capturedBlack4", "type": "imagedata"},
        {"name": "capturedBlack5", "type": "imagedata"},
        {"name": "capturedBlack6", "type": "imagedata"},
        {"name": "capturedBlack7", "type": "imagedata"},
        {"name": "capturedBlack8", "type": "imagedata"},
        {"name": "capturedBlack9", "type": "imagedata"},
        {"name": "capturedBlack10", "type": "imagedata"},
        {"name": "capturedBlack11", "type": "imagedata"},
        {"name": "capturedBlack12", "type": "imagedata"},
        {"name": "capturedBlack13", "type": "imagedata"},
        {"name": "capturedBlack14", "type": "imagedata"},
        {"name": "capturedBlack15", "type": "imagedata"}
    ],
    "area": [
        {
            "name": "mainArea",
            "type": "vbox",
            "spacing": "10",
            "padding": "10",
            "style": "-fx-background-color: $COLOR_BG_MAIN;",
            "items": [
                {"name": "titleLabel", "display": {"type": "label", "labelText": "\u265A Chess Game \u2654", "labelColor": "$COLOR_TEXT_WHITE", "itemFontSize": "28px", "labelBold": true}}
            ],
            "areas": [
                {
                    "name": "timerArea",
                    "type": "hbox",
                    "spacing": "40",
                    "padding": "10",
                    "style": "-fx-background-color: $COLOR_BG_TIMER; -fx-background-radius: 5; -fx-alignment: center; -fx-border-style: solid inside, solid inside; -fx-border-width: 1, 1; -fx-border-insets: 0, 1; -fx-border-color: #ffffff #b6b6b6 #7f7f7f #e6e6e6, #f4f4f4 #cccccc #6a6a6a #f0f0f0; -fx-effect: dropshadow(gaussian, rgba(0,0,0,0.12), 4, 0.0, 0, 1);",
                    "items": [
                        {"name": "whiteLabelTimer", "varRef": "whiteLabelText", "textColor": "$COLOR_LABEL_ACTIVE", "display": {"type": "label", "labelFontSize": "18px"}},
                        {"name": "whiteTimerField", "varRef": "whiteTimer", "textColor": "$COLOR_TIMER_ACTIVE", "display": {"type": "label", "labelText": "10:00.0", "labelFontSize": "24px", "labelBold": true}},
                        {"name": "spacerLabel", "textColor": "$COLOR_TEXT_SEPARATOR", "display": {"type": "label", "labelText": "     |     ", "labelFontSize": "24px"}},
                        {"name": "blackLabelTimer", "varRef": "blackLabelText", "textColor": "$COLOR_LABEL_INACTIVE", "display": {"type": "label", "labelFontSize": "18px"}},
                        {"name": "blackTimerField", "varRef": "blackTimer", "textColor": "$COLOR_TIMER_INACTIVE", "display": {"type": "label", "labelText": "10:00.0", "labelFontSize": "24px", "labelBold": true}}
                    ]
                },
                {
                    "name": "boardAndHistoryContainer",
                    "type": "hbox",
                    "spacing": "0",
                    "padding": "0",
                    "style": "-fx-background-color: $COLOR_BG_MAIN; -fx-fill-height: false;",
                    "areas": [
                        {
                            "name": "capturedWhiteContainer",
                            "type": "vbox",
                            "spacing": "1",
                            "padding": "5",
                            "minWidth": "40",
                            "maxWidth": "40",
                            "minHeight": "100",
                            "prefHeight": "530",
                            "maxHeight": "530",
                            "disableLabelAlignment": true,
                            "style": "-fx-background-color: #3c3c3c; -fx-background-radius: 5; -fx-alignment: top-center;",
                            "items": [
                                {"name": "captPieceW0", "varRef": "capturedWhite0", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                                {"name": "captPieceW1", "varRef": "capturedWhite1", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                                {"name": "captPieceW2", "varRef": "capturedWhite2", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                                {"name": "captPieceW3", "varRef": "capturedWhite3", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                                {"name": "captPieceW4", "varRef": "capturedWhite4", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                                {"name": "captPieceW5", "varRef": "capturedWhite5", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                                {"name": "captPieceW6", "varRef": "capturedWhite6", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                                {"name": "captPieceW7", "varRef": "capturedWhite7", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                                {"name": "captPieceW8", "varRef": "capturedWhite8", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                                {"name": "captPieceW9", "varRef": "capturedWhite9", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                                {"name": "captPieceW10", "varRef": "capturedWhite10", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                                {"name": "captPieceW11", "varRef": "capturedWhite11", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                                {"name": "captPieceW12", "varRef": "capturedWhite12", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                                {"name": "captPieceW13", "varRef": "capturedWhite13", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                                {"name": "captPieceW14", "varRef": "capturedWhite14", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                                {"name": "captPieceW15", "varRef": "capturedWhite15", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}}
                            ]
                        },
                        {
                            "name": "boardContainer",
                            "type": "vbox",
                            "spacing": "0",
                            "padding": "10",
                            "minWidth": "550",
                            "maxWidth": "550",
                            "minHeight": "550",
                            "maxHeight": "550",
                            "style": "-fx-background-color: $COLOR_BG_BOARD; -fx-background-radius: 5;",
                            "areas": [
                                {
                                    "name": "chessBoard",
                                    "type": "gridpane",
                                    "spacing": "0",
                                    "disableLabelAlignment": true,
                                    "style": "-fx-hgap: 0; -fx-vgap: 0; -fx-padding: 2;",
                            "items": [
                                {"name": "lblEmpty1", "layoutPos": "0,0", "display": {"type": "label", "labelText": "", "style": "-fx-min-width: 25; -fx-min-height: 25;"}},
                                {"name": "lblColA", "layoutPos": "0,1", "display": {"type": "label", "labelText": "a", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 60; -fx-min-height: 25; -fx-alignment: center;"}},
                                {"name": "lblColB", "layoutPos": "0,2", "display": {"type": "label", "labelText": "b", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 60; -fx-min-height: 25; -fx-alignment: center;"}},
                                {"name": "lblColC", "layoutPos": "0,3", "display": {"type": "label", "labelText": "c", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 60; -fx-min-height: 25; -fx-alignment: center;"}},
                                {"name": "lblColD", "layoutPos": "0,4", "display": {"type": "label", "labelText": "d", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 60; -fx-min-height: 25; -fx-alignment: center;"}},
                                {"name": "lblColE", "layoutPos": "0,5", "display": {"type": "label", "labelText": "e", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 60; -fx-min-height: 25; -fx-alignment: center;"}},
                                {"name": "lblColF", "layoutPos": "0,6", "display": {"type": "label", "labelText": "f", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 60; -fx-min-height: 25; -fx-alignment: center;"}},
                                {"name": "lblColG", "layoutPos": "0,7", "display": {"type": "label", "labelText": "g", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 60; -fx-min-height: 25; -fx-alignment: center;"}},
                                {"name": "lblColH", "layoutPos": "0,8", "display": {"type": "label", "labelText": "h", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 60; -fx-min-height: 25; -fx-alignment: center;"}},
                                {"name": "lblEmpty2", "layoutPos": "0,9", "display": {"type": "label", "labelText": "", "style": "-fx-min-width: 25; -fx-min-height: 25;"}},
                                
                                {"name": "lblRow8L", "layoutPos": "1,0", "display": {"type": "label", "labelText": "8", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 25; -fx-min-height: 60; -fx-alignment: center;"}},
                                {"name": "board00", "layoutPos": "1,1", "varRef": "b00", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(0, 0);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind00", "layoutPos": "1,1", "varRef": "i00", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell00", "layoutPos": "1,1", "varRef": "c00", "tooltip": "R-8a", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board01", "layoutPos": "1,2", "varRef": "b01", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(1, 0);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind01", "layoutPos": "1,2", "varRef": "i01", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell01", "layoutPos": "1,2", "varRef": "c01", "tooltip": "N-8b", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board02", "layoutPos": "1,3", "varRef": "b02", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(2, 0);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind02", "layoutPos": "1,3", "varRef": "i02", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell02", "layoutPos": "1,3", "varRef": "c02", "tooltip": "B-8c", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board03", "layoutPos": "1,4", "varRef": "b03", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(3, 0);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind03", "layoutPos": "1,4", "varRef": "i03", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell03", "layoutPos": "1,4", "varRef": "c03", "tooltip": "Q-8d", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board04", "layoutPos": "1,5", "varRef": "b04", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(4, 0);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind04", "layoutPos": "1,5", "varRef": "i04", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell04", "layoutPos": "1,5", "varRef": "c04", "tooltip": "K-8e", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board05", "layoutPos": "1,6", "varRef": "b05", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(5, 0);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind05", "layoutPos": "1,6", "varRef": "i05", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell05", "layoutPos": "1,6", "varRef": "c05", "tooltip": "B-8f", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board06", "layoutPos": "1,7", "varRef": "b06", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(6, 0);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind06", "layoutPos": "1,7", "varRef": "i06", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell06", "layoutPos": "1,7", "varRef": "c06", "tooltip": "N-8g", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board07", "layoutPos": "1,8", "varRef": "b07", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(7, 0);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind07", "layoutPos": "1,8", "varRef": "i07", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell07", "layoutPos": "1,8", "varRef": "c07", "tooltip": "R-8h", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "lblRow8R", "layoutPos": "1,9", "display": {"type": "label", "labelText": "8", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 25; -fx-min-height: 60; -fx-alignment: center;"}},
                                
                                {"name": "lblRow7L", "layoutPos": "2,0", "display": {"type": "label", "labelText": "7", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 25; -fx-min-height: 60; -fx-alignment: center;"}},
                                {"name": "board10", "layoutPos": "2,1", "varRef": "b10", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(0, 1);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind10", "layoutPos": "2,1", "varRef": "i10", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell10", "layoutPos": "2,1", "varRef": "c10", "tooltip": "P-7a", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board11", "layoutPos": "2,2", "varRef": "b11", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(1, 1);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind11", "layoutPos": "2,2", "varRef": "i11", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell11", "layoutPos": "2,2", "varRef": "c11", "tooltip": "P-7b", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board12", "layoutPos": "2,3", "varRef": "b12", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(2, 1);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind12", "layoutPos": "2,3", "varRef": "i12", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell12", "layoutPos": "2,3", "varRef": "c12", "tooltip": "P-7c", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board13", "layoutPos": "2,4", "varRef": "b13", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(3, 1);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind13", "layoutPos": "2,4", "varRef": "i13", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell13", "layoutPos": "2,4", "varRef": "c13", "tooltip": "P-7d", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board14", "layoutPos": "2,5", "varRef": "b14", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(4, 1);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind14", "layoutPos": "2,5", "varRef": "i14", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell14", "layoutPos": "2,5", "varRef": "c14", "tooltip": "P-7e", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board15", "layoutPos": "2,6", "varRef": "b15", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(5, 1);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind15", "layoutPos": "2,6", "varRef": "i15", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell15", "layoutPos": "2,6", "varRef": "c15", "tooltip": "P-7f", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board16", "layoutPos": "2,7", "varRef": "b16", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(6, 1);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind16", "layoutPos": "2,7", "varRef": "i16", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell16", "layoutPos": "2,7", "varRef": "c16", "tooltip": "P-7g", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board17", "layoutPos": "2,8", "varRef": "b17", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(7, 1);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind17", "layoutPos": "2,8", "varRef": "i17", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell17", "layoutPos": "2,8", "varRef": "c17", "tooltip": "P-7h", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "lblRow7R", "layoutPos": "2,9", "display": {"type": "label", "labelText": "7", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 25; -fx-min-height: 60; -fx-alignment: center;"}},
                                
                                {"name": "lblRow6L", "layoutPos": "3,0", "display": {"type": "label", "labelText": "6", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 25; -fx-min-height: 60; -fx-alignment: center;"}},
                                {"name": "board20", "layoutPos": "3,1", "varRef": "b20", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(0, 2);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind20", "layoutPos": "3,1", "varRef": "i20", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell20", "layoutPos": "3,1", "varRef": "c20", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board21", "layoutPos": "3,2", "varRef": "b21", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(1, 2);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind21", "layoutPos": "3,2", "varRef": "i21", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell21", "layoutPos": "3,2", "varRef": "c21", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board22", "layoutPos": "3,3", "varRef": "b22", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(2, 2);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind22", "layoutPos": "3,3", "varRef": "i22", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell22", "layoutPos": "3,3", "varRef": "c22", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board23", "layoutPos": "3,4", "varRef": "b23", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(3, 2);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind23", "layoutPos": "3,4", "varRef": "i23", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell23", "layoutPos": "3,4", "varRef": "c23", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board24", "layoutPos": "3,5", "varRef": "b24", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(4, 2);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind24", "layoutPos": "3,5", "varRef": "i24", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell24", "layoutPos": "3,5", "varRef": "c24", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board25", "layoutPos": "3,6", "varRef": "b25", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(5, 2);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind25", "layoutPos": "3,6", "varRef": "i25", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell25", "layoutPos": "3,6", "varRef": "c25", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board26", "layoutPos": "3,7", "varRef": "b26", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(6, 2);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind26", "layoutPos": "3,7", "varRef": "i26", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell26", "layoutPos": "3,7", "varRef": "c26", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board27", "layoutPos": "3,8", "varRef": "b27", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(7, 2);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind27", "layoutPos": "3,8", "varRef": "i27", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell27", "layoutPos": "3,8", "varRef": "c27", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "lblRow6R", "layoutPos": "3,9", "display": {"type": "label", "labelText": "6", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 25; -fx-min-height: 60; -fx-alignment: center;"}},
                                
                                {"name": "lblRow5L", "layoutPos": "4,0", "display": {"type": "label", "labelText": "5", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 25; -fx-min-height: 60; -fx-alignment: center;"}},
                                {"name": "board30", "layoutPos": "4,1", "varRef": "b30", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(0, 3);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind30", "layoutPos": "4,1", "varRef": "i30", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell30", "layoutPos": "4,1", "varRef": "c30", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board31", "layoutPos": "4,2", "varRef": "b31", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(1, 3);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind31", "layoutPos": "4,2", "varRef": "i31", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell31", "layoutPos": "4,2", "varRef": "c31", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board32", "layoutPos": "4,3", "varRef": "b32", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(2, 3);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind32", "layoutPos": "4,3", "varRef": "i32", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell32", "layoutPos": "4,3", "varRef": "c32", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board33", "layoutPos": "4,4", "varRef": "b33", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(3, 3);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind33", "layoutPos": "4,4", "varRef": "i33", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell33", "layoutPos": "4,4", "varRef": "c33", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board34", "layoutPos": "4,5", "varRef": "b34", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(4, 3);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind34", "layoutPos": "4,5", "varRef": "i34", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell34", "layoutPos": "4,5", "varRef": "c34", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board35", "layoutPos": "4,6", "varRef": "b35", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(5, 3);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind35", "layoutPos": "4,6", "varRef": "i35", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell35", "layoutPos": "4,6", "varRef": "c35", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board36", "layoutPos": "4,7", "varRef": "b36", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(6, 3);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind36", "layoutPos": "4,7", "varRef": "i36", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell36", "layoutPos": "4,7", "varRef": "c36", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board37", "layoutPos": "4,8", "varRef": "b37", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(7, 3);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind37", "layoutPos": "4,8", "varRef": "i37", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell37", "layoutPos": "4,8", "varRef": "c37", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "lblRow5R", "layoutPos": "4,9", "display": {"type": "label", "labelText": "5", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 25; -fx-min-height: 60; -fx-alignment: center;"}},
                                
                                {"name": "lblRow4L", "layoutPos": "5,0", "display": {"type": "label", "labelText": "4", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 25; -fx-min-height: 60; -fx-alignment: center;"}},
                                {"name": "board40", "layoutPos": "5,1", "varRef": "b40", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(0, 4);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind40", "layoutPos": "5,1", "varRef": "i40", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell40", "layoutPos": "5,1", "varRef": "c40", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board41", "layoutPos": "5,2", "varRef": "b41", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(1, 4);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind41", "layoutPos": "5,2", "varRef": "i41", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell41", "layoutPos": "5,2", "varRef": "c41", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board42", "layoutPos": "5,3", "varRef": "b42", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(2, 4);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind42", "layoutPos": "5,3", "varRef": "i42", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell42", "layoutPos": "5,3", "varRef": "c42", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board43", "layoutPos": "5,4", "varRef": "b43", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(3, 4);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind43", "layoutPos": "5,4", "varRef": "i43", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell43", "layoutPos": "5,4", "varRef": "c43", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board44", "layoutPos": "5,5", "varRef": "b44", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(4, 4);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind44", "layoutPos": "5,5", "varRef": "i44", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell44", "layoutPos": "5,5", "varRef": "c44", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board45", "layoutPos": "5,6", "varRef": "b45", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(5, 4);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind45", "layoutPos": "5,6", "varRef": "i45", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell45", "layoutPos": "5,6", "varRef": "c45", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board46", "layoutPos": "5,7", "varRef": "b46", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(6, 4);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind46", "layoutPos": "5,7", "varRef": "i46", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell46", "layoutPos": "5,7", "varRef": "c46", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board47", "layoutPos": "5,8", "varRef": "b47", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(7, 4);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind47", "layoutPos": "5,8", "varRef": "i47", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell47", "layoutPos": "5,8", "varRef": "c47", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "lblRow4R", "layoutPos": "5,9", "display": {"type": "label", "labelText": "4", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 25; -fx-min-height: 60; -fx-alignment: center;"}},
                                
                                {"name": "lblRow3L", "layoutPos": "6,0", "display": {"type": "label", "labelText": "3", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 25; -fx-min-height: 60; -fx-alignment: center;"}},
                                {"name": "board50", "layoutPos": "6,1", "varRef": "b50", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(0, 5);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind50", "layoutPos": "6,1", "varRef": "i50", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell50", "layoutPos": "6,1", "varRef": "c50", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board51", "layoutPos": "6,2", "varRef": "b51", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(1, 5);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind51", "layoutPos": "6,2", "varRef": "i51", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell51", "layoutPos": "6,2", "varRef": "c51", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board52", "layoutPos": "6,3", "varRef": "b52", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(2, 5);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind52", "layoutPos": "6,3", "varRef": "i52", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell52", "layoutPos": "6,3", "varRef": "c52", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board53", "layoutPos": "6,4", "varRef": "b53", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(3, 5);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind53", "layoutPos": "6,4", "varRef": "i53", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell53", "layoutPos": "6,4", "varRef": "c53", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board54", "layoutPos": "6,5", "varRef": "b54", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(4, 5);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind54", "layoutPos": "6,5", "varRef": "i54", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell54", "layoutPos": "6,5", "varRef": "c54", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board55", "layoutPos": "6,6", "varRef": "b55", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(5, 5);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind55", "layoutPos": "6,6", "varRef": "i55", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell55", "layoutPos": "6,6", "varRef": "c55", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board56", "layoutPos": "6,7", "varRef": "b56", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(6, 5);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind56", "layoutPos": "6,7", "varRef": "i56", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell56", "layoutPos": "6,7", "varRef": "c56", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board57", "layoutPos": "6,8", "varRef": "b57", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(7, 5);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind57", "layoutPos": "6,8", "varRef": "i57", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell57", "layoutPos": "6,8", "varRef": "c57", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "lblRow3R", "layoutPos": "6,9", "display": {"type": "label", "labelText": "3", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 25; -fx-min-height: 60; -fx-alignment: center;"}},
                                
                                {"name": "lblRow2L", "layoutPos": "7,0", "display": {"type": "label", "labelText": "2", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 25; -fx-min-height: 60; -fx-alignment: center;"}},
                                {"name": "board60", "layoutPos": "7,1", "varRef": "b60", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(0, 6);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind60", "layoutPos": "7,1", "varRef": "i60", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell60", "layoutPos": "7,1", "varRef": "c60", "tooltip": "P-2a", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board61", "layoutPos": "7,2", "varRef": "b61", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(1, 6);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind61", "layoutPos": "7,2", "varRef": "i61", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell61", "layoutPos": "7,2", "varRef": "c61", "tooltip": "P-2b", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board62", "layoutPos": "7,3", "varRef": "b62", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(2, 6);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind62", "layoutPos": "7,3", "varRef": "i62", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell62", "layoutPos": "7,3", "varRef": "c62", "tooltip": "P-2c", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board63", "layoutPos": "7,4", "varRef": "b63", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(3, 6);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind63", "layoutPos": "7,4", "varRef": "i63", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell63", "layoutPos": "7,4", "varRef": "c63", "tooltip": "P-2d", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board64", "layoutPos": "7,5", "varRef": "b64", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(4, 6);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind64", "layoutPos": "7,5", "varRef": "i64", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell64", "layoutPos": "7,5", "varRef": "c64", "tooltip": "P-2e", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board65", "layoutPos": "7,6", "varRef": "b65", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(5, 6);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind65", "layoutPos": "7,6", "varRef": "i65", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell65", "layoutPos": "7,6", "varRef": "c65", "tooltip": "P-2f", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board66", "layoutPos": "7,7", "varRef": "b66", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(6, 6);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind66", "layoutPos": "7,7", "varRef": "i66", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell66", "layoutPos": "7,7", "varRef": "c66", "tooltip": "P-2g", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board67", "layoutPos": "7,8", "varRef": "b67", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(7, 6);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind67", "layoutPos": "7,8", "varRef": "i67", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell67", "layoutPos": "7,8", "varRef": "c67", "tooltip": "P-2h", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "lblRow2R", "layoutPos": "7,9", "display": {"type": "label", "labelText": "2", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 25; -fx-min-height: 60; -fx-alignment: center;"}},
                                
                                {"name": "lblRow1L", "layoutPos": "8,0", "display": {"type": "label", "labelText": "1", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 25; -fx-min-height: 60; -fx-alignment: center;"}},
                                {"name": "board70", "layoutPos": "8,1", "varRef": "b70", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(0, 7);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind70", "layoutPos": "8,1", "varRef": "i70", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell70", "layoutPos": "8,1", "varRef": "c70", "tooltip": "R-1a", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board71", "layoutPos": "8,2", "varRef": "b71", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(1, 7);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind71", "layoutPos": "8,2", "varRef": "i71", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell71", "layoutPos": "8,2", "varRef": "c71", "tooltip": "N-1b", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board72", "layoutPos": "8,3", "varRef": "b72", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(2, 7);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind72", "layoutPos": "8,3", "varRef": "i72", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell72", "layoutPos": "8,3", "varRef": "c72", "tooltip": "B-1c", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board73", "layoutPos": "8,4", "varRef": "b73", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(3, 7);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind73", "layoutPos": "8,4", "varRef": "i73", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell73", "layoutPos": "8,4", "varRef": "c73", "tooltip": "Q-1d", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board74", "layoutPos": "8,5", "varRef": "b74", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(4, 7);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind74", "layoutPos": "8,5", "varRef": "i74", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell74", "layoutPos": "8,5", "varRef": "c74", "tooltip": "K-1e", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board75", "layoutPos": "8,6", "varRef": "b75", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(5, 7);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind75", "layoutPos": "8,6", "varRef": "i75", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell75", "layoutPos": "8,6", "varRef": "c75", "tooltip": "B-1f", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board76", "layoutPos": "8,7", "varRef": "b76", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(6, 7);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind76", "layoutPos": "8,7", "varRef": "i76", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell76", "layoutPos": "8,7", "varRef": "c76", "tooltip": "N-1g", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "board77", "layoutPos": "8,8", "varRef": "b77", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "onClick": "call handleCellClick(7, 7);", "style": "-fx-cursor: hand;"}},
                                {"name": "ind77", "layoutPos": "8,8", "varRef": "i77", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": false, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "cell77", "layoutPos": "8,8", "varRef": "c77", "tooltip": "R-1h", "display": {"type": "image", "fitWidth": 60, "fitHeight": 60, "preserveRatio": true, "pickOnBounds": true, "style": "-fx-mouse-transparent: true;"}},
                                {"name": "lblRow1R", "layoutPos": "8,9", "display": {"type": "label", "labelText": "1", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 25; -fx-min-height: 60; -fx-alignment: center;"}},
                                
                                {"name": "lblEmpty3", "layoutPos": "9,0", "display": {"type": "label", "labelText": "", "style": "-fx-min-width: 25; -fx-min-height: 25;"}},
                                {"name": "lblColA2", "layoutPos": "9,1", "display": {"type": "label", "labelText": "a", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 60; -fx-min-height: 25; -fx-alignment: center;"}},
                                {"name": "lblColB2", "layoutPos": "9,2", "display": {"type": "label", "labelText": "b", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 60; -fx-min-height: 25; -fx-alignment: center;"}},
                                {"name": "lblColC2", "layoutPos": "9,3", "display": {"type": "label", "labelText": "c", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 60; -fx-min-height: 25; -fx-alignment: center;"}},
                                {"name": "lblColD2", "layoutPos": "9,4", "display": {"type": "label", "labelText": "d", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 60; -fx-min-height: 25; -fx-alignment: center;"}},
                                {"name": "lblColE2", "layoutPos": "9,5", "display": {"type": "label", "labelText": "e", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 60; -fx-min-height: 25; -fx-alignment: center;"}},
                                {"name": "lblColF2", "layoutPos": "9,6", "display": {"type": "label", "labelText": "f", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 60; -fx-min-height: 25; -fx-alignment: center;"}},
                                {"name": "lblColG2", "layoutPos": "9,7", "display": {"type": "label", "labelText": "g", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 60; -fx-min-height: 25; -fx-alignment: center;"}},
                                {"name": "lblColH2", "layoutPos": "9,8", "display": {"type": "label", "labelText": "h", "labelColor": "$COLOR_TEXT_RULER", "labelFontSize": "14px", "labelBold": true, "style": "-fx-min-width: 60; -fx-min-height: 25; -fx-alignment: center;"}},
                                {"name": "lblEmpty4", "layoutPos": "9,9", "display": {"type": "label", "labelText": "", "style": "-fx-min-width: 25; -fx-min-height: 25;"}}
                            ]
                        }
                    ]
                },
                {
                    "name": "capturedBlackContainer",
                    "type": "vbox",
                    "spacing": "1",
                    "padding": "5",
                    "minWidth": "40",
                    "maxWidth": "40",
                    "minHeight": "100",
                    "prefHeight": "530",
                    "maxHeight": "530",
                    "disableLabelAlignment": true,
                    "style": "-fx-background-color: #3c3c3c; -fx-background-radius: 5; -fx-alignment: top-center;",
                    "items": [
                        {"name": "captPieceB0", "varRef": "capturedBlack0", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                        {"name": "captPieceB1", "varRef": "capturedBlack1", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                        {"name": "captPieceB2", "varRef": "capturedBlack2", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                        {"name": "captPieceB3", "varRef": "capturedBlack3", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                        {"name": "captPieceB4", "varRef": "capturedBlack4", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                        {"name": "captPieceB5", "varRef": "capturedBlack5", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                        {"name": "captPieceB6", "varRef": "capturedBlack6", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                        {"name": "captPieceB7", "varRef": "capturedBlack7", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                        {"name": "captPieceB8", "varRef": "capturedBlack8", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                        {"name": "captPieceB9", "varRef": "capturedBlack9", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                        {"name": "captPieceB10", "varRef": "capturedBlack10", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                        {"name": "captPieceB11", "varRef": "capturedBlack11", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                        {"name": "captPieceB12", "varRef": "capturedBlack12", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                        {"name": "captPieceB13", "varRef": "capturedBlack13", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                        {"name": "captPieceB14", "varRef": "capturedBlack14", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}},
                        {"name": "captPieceB15", "varRef": "capturedBlack15", "display": {"type": "image", "fitWidth": 30, "fitHeight": 30, "preserveRatio": true}}
                    ]
                },
                {
                    "name": "moveHistoryContainer",
                    "type": "vbox",
                    "spacing": "5",
                    "padding": "10",
                    "minWidth": "300",
                    "maxWidth": "300",
                    "minHeight": "550",
                    "maxHeight": "550",
                    "style": "-fx-background-color: $COLOR_MOVE_HISTORY_BG; -fx-background-radius: 5;",
                    "items": [
                        {"name": "moveHistoryTitle", "display": {"type": "label", "labelText": "Move History", "labelColor": "$COLOR_MOVE_HISTORY_TEXT", "labelFontSize": "16px", "labelBold": true}, "labelPos": "top"}
                    ],
                    "areas": [
                        {
                            "name": "moveHistoryArea",
                            "type": "vbox",
                            "spacing": "0",
                            "padding": "0",
                            "disableLabelAlignment": true,
                            "items": [
                                {"name": "moveHistoryText", "varRef": "moveHistory", "editable": false, "display": {"type": "textarea", "wrapText": true, "height": 30, "style": "-fx-control-inner-background: $COLOR_MOVE_HISTORY_BG; -fx-text-fill: $COLOR_MOVE_HISTORY_TEXT; -fx-font-family: 'Courier New'; -fx-font-size: 14px; -fx-border-color: #555555; -fx-border-width: 1;"}, "labelPos": "top"}
                            ]
                        }
                    ]
                }
            ]
        },
                {
                    "name": "statusArea",
                    "type": "hbox",
                    "spacing": "20",
                    "padding": "10",
                    "style": "-fx-background-color: #3c3c3c; -fx-background-radius: 5;",
                    "items": [
                        {"name": "statusLabel", "varRef": "statusMessage", "display": {"type": "label", "labelColor": "$COLOR_BUTTON_NEW_GAME", "labelFontSize": "16px", "labelBold": true}}
                    ]
                },
                {
                    "name": "buttonArea",
                    "type": "hbox",
                    "spacing": "20",
                    "padding": "10",
                    "items": [
                        {"name": "undoBtn", "disabled": true, "display": {"type": "button", "labelText": "Undo", "onClick": "call undoMove();"}},
                        {"name": "redoBtn", "disabled": true, "display": {"type": "button", "labelText": "Redo", "onClick": "call redoMove();"}},
                        {"name": "newGameBtn", "display": {"type": "button", "labelText": "New Game", "onClick": "call resetGame();"}},
                        {"name": "closeBtn", "display": {"type": "button", "labelText": "Close", "onClick": "call closeChessScreen();"}}
                    ]
                }
            ]
        }
    ]
};

// Game Over dialog screen
screen gameOverDialog = {
    "title": "Game Over",
    "width": 400,
    "height": 250,
    "showMenu": false,
    "vars": [
        {
            "name": "resultMessage",
            "type": "string",
            "default": "Game Over"
        }
    ],
    "area": [
        {
            "name": "mainArea",
            "type": "vbox",
            "alignment": "center",
            "spacing": "20",
            "padding": "20",
            "style": "-fx-background-color: #2c2c2c;",
            "items": [
                {"name": "resultLabel", "varRef": "resultMessage", "display": {"type": "label", "labelColor": "#ffcc00", "labelFontSize": "24px", "labelBold": true}},
                {"name": "messageLabel", "display": {"type": "label", "labelText": "What would you like to do?", "labelColor": "#ffffff", "labelFontSize": "16px"}}
            ],
            "areas": [
                {
                    "name": "buttonArea",
                    "type": "hbox",
                    "alignment": "center",
                    "spacing": "20",
                    "padding": "20",
                    "items": [
                        {"name": "restartBtn", "display": {"type": "button", "labelText": "New Game", "onClick": "call handleRestartGame();", "style": "-fx-font-size: 16px; -fx-padding: 10 30 10 30;"}},
                        {"name": "exitBtn", "display": {"type": "button", "labelText": "Exit", "onClick": "call handleExitFromGameOver();", "style": "-fx-font-size: 16px; -fx-padding: 10 30 10 30;"}}
                    ]
                }
            ]
        }
    ]
};

// Show game over dialog
showGameOverDialog(winner: string, gameType: string) {
    print "Showing game over dialog...";
    
    var elapsedTime: string = call formatElapsedTime();
    
    var message: string;
    if gameType == "checkmate" then {
        message = "Checkmate! " + winner + " wins!\nGame time: " + elapsedTime;
    } else {
        message = "Stalemate - " + winner + "!\nGame time: " + elapsedTime;
    }
    
    gameOverDialog.resultMessage = message;
    show screen gameOverDialog;
}

// Handle restart game from game over dialog
handleRestartGame() {
    print "Restarting game...";
    close screen gameOverDialog;
    call resetGame();
}

// Handle exit from game over dialog
handleExitFromGameOver() {
    print "Exiting from game over dialog...";
    close screen gameOverDialog;
    call closeChessScreen();
}

// Reset the game to initial state
resetGame() {
    print "Returning to startup screen...";
    
    // Stop the game
    gameStarted = false;
    
    // Stop the timer if it's running
    call thread.timerStop("chessScreen.chessTimer");
    
    // Close the chess screen
    close screen chessScreen;
    
    // Show the startup dialog to start a new game
    show screen startupDialog;
    
    print "Startup screen displayed.";
}

// Close chess screen handler
closeChessScreen() {
    print "Closing chess screen...";
    gameStarted = false;
    
    // Stop the timer if it's running
    call thread.timerStop("chessScreen.chessTimer");
    
    close screen chessScreen;
    
    print "Chess screen closed.";
}
